{"./":{"url":"./","title":"Introduction","keywords":"","body":"LeetCode Daily Challenge 一个记录 leetcode 每日一题的仓库 汇总（按题目序号排列） 1. Two Sum(easy) 2. Add Two Numbers(medium) 3. Longest Substring Without Repeating Characters(medium) 5. Longest Palindromic Substring(medium) 6. Zigzag Conversion(medium) 7. Reverse Integer(medium) 8. String to Integer (atoi)(medium) 9. Palindrome Number(easy) 11. Container With Most Water(medium) 12. Integer to Roman(medium) 14. Longest Common Prefix(easy) 15. 3Sum(medium) 16. 3Sum Closest(medium) 17. Letter Combinations of a Phone Number(medium) 18. 4Sum(medium) 19. Remove Nth Node From End of List(medium) 20. Valid Parentheses(easy) 21. Merge Two Sorted Lists(easy) 22. Generate Parentheses(medium) 23. Merge k Sorted Lists(hard) 24. Swap Nodes in Pairs(medium) 25. Reverse Nodes in k-Group(hard) 26. Remove Duplicates from Sorted Array(easy) 27. Remove Element(easy) 28. Find the Index of the First Occurrence in a String(easy) 29. Divide Two Integers(medium) 31. Next Permutation(medium) 32. Longest Valid Parentheses(hard) 33. Search in Rotated Sorted Array(medium) 34. Find First and Last Position of Element in Sorted Array(medium) 35. Search Insert Position(easy) 36. Valid Sudoku(medium) 39. Combination Sum(medium) 40. Combination Sum II(medium) 41. First Missing Positive(hard) 42. Trapping Rain Water(hard) 45. Jump Game II(medium) 46. Permutations(medium) 47. Permutations II(medium) 48. Rotate Image(medium) 49. Group Anagrams(medium) 51. N-Queens(hard) 52. N-Queens II(hard) 53. Maximum Subarray(medium) 54. Spiral Matrix(medium) 55. Jump Game(medium) 56. Merge Intervals(medium) 59. Spiral Matrix II(medium) 61. Rotate List(medium) 62. Unique Paths(medium) 63. Unique Paths II(medium) 64. Minimum Path Sum(medium) 70. Climbing Stairs(easy) 72. Edit Distance(medium) 73. Set Matrix Zeroes(medium) 74. Search a 2D Matrix(medium) 75. Sort Colors(medium) 76. Minimum Window Substring(hard) 78. Subsets(medium) 81. Search in Rotated Sorted Array II(medium) 84. Largest Rectangle in Histogram(hard) 88. Merge Sorted Array(easy) 98. Validate Binary Search Tree(medium) 99. Recover Binary Search Tree(medium) 101. Symmetric Tree(easy) 102. Binary Tree Level Order Traversal(medium) 104. Maximum Depth of Binary Tree(easy) 105. Construct Binary Tree from Preorder and Inorder Traversal(medium) 108. Convert Sorted Array to Binary Search Tree(easy) 114. Flatten Binary Tree to Linked List(medium) 117. Populating Next Right Pointers in Each Node II(medium) 118. Pascal's Triangle(easy) 119. Pascal's Triangle II(easy) 120. Triangle(medium) 121. Best Time to Buy and Sell Stock(easy) 124. Binary Tree Maximum Path Sum(hard) 128. Longest Consecutive Sequence(medium) 131. Palindrome Partitioning(medium) 135. Candy(hard) 136. Single Number(easy) 138. Copy List with Random Pointer(medium) 139. Word Break(medium) 141. Linked List Cycle(easy) 142. Linked List Cycle II(medium) 146. LRU Cache(medium) 151. Reverse Words in a String(medium) 152. Maximum Product Subarray(medium) 153. Find Minimum in Rotated Sorted Array(medium) 155. Min Stack(medium) 160. Intersection of Two Linked Lists(easy) 165. Compare Version Numbers(medium) 166. Fraction to Recurring Decimal(medium) 167. Two Sum II - Input Array Is Sorted(medium) 169. Majority Element(easy) 173. Binary Search Tree Iterator(medium) 189. Rotate Array(medium) 191. Number of 1 Bits(easy) 198. House Robber(medium) 199. Binary Tree Right Side View(medium) 200. Number of Islands(medium) 206. Reverse Linked List(easy) 207. Course Schedule(medium) 208. Implement Trie (Prefix Tree)(medium) 215. Kth Largest Element in an Array(medium) 216. Combination Sum III(medium) 225. Implement Stack using Queues(easy) 226. Invert Binary Tree(easy) 230. Kth Smallest Element in a BST(medium) 234. Palindrome Linked List(easy) 236. Lowest Common Ancestor of a Binary Tree(medium) 238. Product of Array Except Self(medium) 239. Sliding Window Maximum(hard) 240. Search a 2D Matrix II(medium) 268. Missing Number(easy) 279. Perfect Squares(medium) 283. Move Zeroes(easy) 284. Peeking Iterator(medium) 287. Find the Duplicate Number(medium) 289. Game of Life(medium) 295. Find Median from Data Stream(hard) 300. Longest Increasing Subsequence(medium) 304. Range Sum Query 2D - Immutable(medium) 318. Maximum Product of Word Lengths(medium) 322. Coin Change(medium) 328. Odd Even Linked List(medium) 329. Longest Increasing Path in a Matrix(hard) 330. Patching Array(hard) 334. Increasing Triplet Subsequence(medium) 341. Flatten Nested List Iterator(medium) 344. Reverse String(easy) 345. Reverse Vowels of a String(easy) 347. Top K Frequent Elements(medium) 354. Russian Doll Envelopes(hard) 376. Wiggle Subsequence(medium) 392. Is Subsequence(easy) 394. Decode String(medium) 399. Evaluate Division(medium) 406. Queue Reconstruction by Height(medium) 407. Trapping Rain Water II(hard) 410. Split Array Largest Sum(hard) 416. Partition Equal Subset Sum(medium) 417. Pacific Atlantic Water Flow(medium) 429. N-ary Tree Level Order Traversal(medium) 437. Path Sum III(medium) 438. Find All Anagrams in a String(medium) 443. String Compression(medium) 450. Delete Node in a BST(medium) 456. 132 Pattern(medium) 462. Minimum Moves to Equal Array Elements II(medium) 474. Ones and Zeroes(medium) 535. Encode and Decode TinyURL(medium) 538. Convert BST to Greater Tree(medium) 543. Diameter of Binary Tree(easy) 547. Number of Provinces(medium) 560. Subarray Sum Equals K(medium) 581. Shortest Unsorted Continuous Subarray(medium) 583. Delete Operation for Two Strings(medium) 605. Can Place Flowers(easy) 611. Valid Triangle Number(medium) 633. Sum of Square Numbers(medium) 643. Maximum Average Subarray I(easy) 647. Palindromic Substrings(medium) 649. Dota2 Senate(medium) 665. Non-decreasing Array(medium) 669. Trim a Binary Search Tree(medium) 680. Valid Palindrome II(easy) 682. Baseball Game(easy) 700. Search in a Binary Search Tree(easy) 703. Kth Largest Element in a Stream(easy) 704. Binary Search(easy) 705. Design HashSet(easy) 706. Design HashMap(easy) 717. 1-bit and 2-bit Characters(easy) 724. Find Pivot Index(easy) 726. Number of Atoms(hard) 735. Asteroid Collision(medium) 739. Daily Temperatures(medium) 763. Partition Labels(medium) 769. Max Chunks To Make Sorted(medium) 778. Swim in Rising Water(hard) 785. Is Graph Bipartite?(medium) 812. Largest Triangle Area(easy) 820. Short Encoding of Words(medium) 826. Most Profit Assigning Work(medium) 844. Backspace String Compare(easy) 867. Transpose Matrix(easy) 872. Leaf-Similar Trees(easy) 897. Increasing Order Search Tree(easy) 905. Sort Array By Parity(easy) 912. Sort an Array(medium) 923. 3Sum With Multiplicity(medium) 933. Number of Recent Calls(easy) 966. Vowel Spellchecker(medium) 968. Binary Tree Cameras(hard) 976. Largest Perimeter Triangle(easy) 994. Rotting Oranges(medium) 1004. Max Consecutive Ones III(medium) 1015. Smallest Integer Divisible by K(medium) 1018. Binary Prefix Divisible By 5(easy) 1029. Two City Scheduling(medium) 1039. Minimum Score Triangulation of Polygon(medium) 1046. Last Stone Weight(easy) 1048. Longest String Chain(medium) 1052. Grumpy Bookstore Owner(medium) 1071. Greatest Common Divisor of Strings(easy) 1091. Shortest Path in Binary Matrix(medium) 1110. Delete Nodes And Return Forest(medium) 1143. Longest Common Subsequence(medium) 1161. Maximum Level Sum of a Binary Tree(medium) 1190. Reverse Substrings Between Each Pair of Parentheses(medium) 1192. Critical Connections in a Network(hard) 1202. Smallest String With Swaps(medium) 1207. Unique Number of Occurrences(easy) 1209. Remove All Adjacent Duplicates in String II(medium) 1260. Shift 2D Grid(easy) 1262. Greatest Sum Divisible by Three(medium) 1268. Search Suggestions System(medium) 1302. Deepest Leaves Sum(medium) 1304. Find N Unique Integers Sum up to Zero(easy) 1317. Convert Integer to the Sum of Two No-Zero Integers(easy) 1332. Remove Palindromic Subsequences(easy) 1337. The K Weakest Rows in a Matrix(easy) 1342. Number of Steps to Reduce a Number to Zero(easy) 1352. Product of the Last K Numbers(medium) 1372. Longest ZigZag Path in a Binary Tree(medium) 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree(medium) 1380. Lucky Numbers in a Matrix(easy) 1396. Design Underground System(medium) 1423. Maximum Points You Can Obtain from Cards(medium) 1431. Kids With the Greatest Number of Candies(easy) 1437. Check If All 1's Are at Least Length K Places Away(easy) 1448. Count Good Nodes in Binary Tree(medium) 1456. Maximum Number of Vowels in a Substring of Given Length(medium) 1461. Check If a String Contains All Binary Codes of Size K(medium) 1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts(medium) 1475. Final Prices With a Special Discount in a Shop(easy) 1482. Minimum Number of Days to Make m Bouquets(medium) 1488. Avoid Flood in The City(medium) 1493. Longest Subarray of 1's After Deleting One Element(medium) 1513. Number of Substrings With Only 1s(medium) 1518. Water Bottles(easy) 1526. Minimum Number of Increments on Subarrays to Form a Target Array(hard) 1530. Number of Good Leaf Nodes Pairs(medium) 1552. Magnetic Force Between Two Balls(medium) 1578. Minimum Time to Make Rope Colorful(medium) 1584. Min Cost to Connect All Points(medium) 1598. Crawler Log Folder(easy) 1625. Lexicographically Smallest String After Applying Operations(medium) 1631. Path With Minimum Effort(medium) 1636. Sort Array by Increasing Frequency(easy) 1641. Count Sorted Vowel Strings(medium) 1642. Furthest Building You Can Reach(medium) 1653. Minimum Deletions to Make String Balanced(medium) 1657. Determine if Two Strings Are Close(medium) 1658. Minimum Operations to Reduce X to Zero(medium) 1679. Max Number of K-Sum Pairs(medium) 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers(medium) 1695. Maximum Erasure Value(medium) 1710. Maximum Units on a Truck(easy) 1716. Calculate Money in Leetcode Bank(easy) 1717. Maximum Score From Removing Substrings(medium) 1721. Swapping Nodes in a Linked List(medium) 1732. Find the Highest Altitude(easy) 1733. Minimum Number of People to Teach(medium) 1768. Merge Strings Alternately(easy) 1912. Design Movie Rental System(hard) 1926. Nearest Exit from Entrance in Maze(medium) 1930. Unique Length-3 Palindromic Subsequences(medium) 1935. Maximum Number of Words You Can Type(easy) 2011. Final Value of Variable After Performing Operations(easy) 2043. Simple Bank System(medium) 2048. Next Greater Numerically Balanced Number(medium) 2095. Delete the Middle Node of a Linked List(medium) 2096. Step-By-Step Directions From a Binary Tree Node to Another(medium) 2125. Number of Laser Beams in a Bank(medium) 2130. Maximum Twin Sum of a Linked List(medium) 2154. Keep Multiplying Found Values by Two(easy) 2169. Count Operations to Obtain Zero(easy) 2191. Sort the Jumbled Numbers(medium) 2196. Create Binary Tree From Descriptions(medium) 2197. Replace Non-Coprime Numbers in Array(hard) 2215. Find the Difference of Two Arrays(easy) 2221. Find Triangular Sum of an Array(medium) 2257. Count Unguarded Cells in the Grid(medium) 2273. Find Resultant Array After Removing Anagrams(easy) 2300. Successful Pairs of Spells and Potions(medium) 2327. Number of People Aware of a Secret(medium) 2352. Equal Row and Column Pairs(medium) 2353. Design a Food Rating System(medium) 2390. Removing Stars From a String(medium) 2415. Reverse Odd Levels of Binary Tree(medium) 2418. Sort the People(easy) 2471. Minimum Number of Operations to Sort a Binary Tree by Level(medium) 2536. Increment Submatrices by One(medium) 2598. Smallest Missing Non-negative Integer After Operations(medium) 2636. Promise Pool(medium) 2654. Minimum Number of Operations to Make All Array Elements Equal to 1(medium) 2749. Minimum Operations to Make the Integer Zero(medium) 2751. Robot Collisions(hard) 2785. Sort Vowels in a String(medium) 2872. Maximum Number of K-Divisible Components(hard) 3005. Count Elements With Maximum Frequency(easy) 3025. Find the Number of Ways to Place People I(medium) 3027. Find the Number of Ways to Place People II(hard) 3100. Water Bottles II(medium) 3147. Taking Maximum Energy From the Mystic Dungeon(medium) 3186. Maximum Total Damage With Spell Casting(medium) 3190. Find Minimum Operations to Make All Elements Divisible by Three(easy) 3217. Delete Nodes From Linked List Present in Array(medium) 3227. Vowels Game in a String(medium) 3228. Maximum Number of Operations to Move Ones to the End(medium) 3264. Final Array State After K Multiplication Operations I(easy) 3289. The Two Sneaky Numbers of Digitville(easy) 3318. Find X-Sum of All K-Long Subarrays I(easy) 3346. Maximum Frequency of an Element After Performing Operations I(medium) 3347. Maximum Frequency of an Element After Performing Operations II(hard) 3349. Adjacent Increasing Subarrays Detection I(easy) 3350. Adjacent Increasing Subarrays Detection II(medium) 3354. Make Array Elements Equal to Zero(easy) 3370. Smallest Number With All Set Bits(easy) 3381. Maximum Subarray Sum With Length Divisible by K(medium) 3397. Maximum Number of Distinct Elements After Operations(medium) 3408. Design Task Manager(medium) 3461. Check If Digits Are Equal in String After Operations I(easy) 3484. Design Spreadsheet(medium) 3495. Minimum Operations to Make Array Elements Zero(hard) 3508. Implement Router(medium) 3512. Minimum Operations to Make Array Sum Divisible by K(easy) 3516. Find Closest Person(easy) 3541. Find Most Frequent Vowel and Consonant(easy) 3542. Minimum Operations to Convert All Elements to Zero(medium) 3607. Power Grid Maintenance(medium) "},"easy/":{"url":"easy/","title":"Easy","keywords":"","body":"Easy "},"easy/1.html":{"url":"easy/1.html","title":"1. Two Sum(easy)","keywords":"","body":"1. Two Sum Leetcode link 解题思路——O(n^2) 这是一道简单题，一个最直接的解题思路就是用双循环：外侧循环输入数组，内侧循环寻找target - nums[i]的差，如果找到就把两个下标装到一个数组中返回出去。 注：在 JS 中的 indexOf 本质上也是用了遍历O(n) C++ class Solution { public: vector twoSum(vector& nums, int target) { vector result; for (int i = 0; i Javascript var twoSum = function(nums, target) { for(let i=0;i 解题思路——O(n) 想当然尔，一个简单题用了 O(n^2)的算法复杂度，不只是题目最下面的 Follow-up 不满意，面试官也肯定不满意&#x1F436; 所以就有了空间换时间的思路：用一个 map 来保存之前出现过的值以及对应的下标，之后直接用 O(1) 在 map 里找就完事了。 注：JS用了另一种思路，保存了当前下标及当前的值与target的差，但是本质是一样的。 C++ class Solution { public: vector twoSum(vector& nums, int target) { unordered_map map; for (int i = 0; i Javascript var twoSum = function(nums, target) { let cache = {}; for(let i=0;i "},"easy/9.html":{"url":"easy/9.html","title":"9. Palindrome Number(easy)","keywords":"","body":"9. Palindrome Number Leetcode link 解题思路 本题要求我们检查出一个数字是否是回文的，因为比较数字的首尾比较麻烦，所以我们可以先把它转换成字符串的形式，转换成字符串口有两种思路： 夹紧法：写一个 for 循环并且用两个指针分别从首尾取出数字比较 反转法：创建另一个与题目给的数字相反的字符串，然后比较两个字符串 Javascript 1. 夹紧法 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { const str = x.toString(); const len = str.length; for(let i=0, j=len-1;i 2. 反转法 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { const str = x.toString(); const reversedStr = str.split(\"\").reverse().join(\"\"); return reversedStr === str; }; "},"easy/14.html":{"url":"easy/14.html","title":"14. Longest Common Prefix(easy)","keywords":"","body":"14. Longest Common Prefix Leetcode link 题目简介 /** * @param {string[]} strs * @return {string} */ 本题给我们一个字符串数组 strs，要求我们找出 strs 中所有字符串的共同前缀 解题思路 找字符串前缀我们可以用 String.startsWith 方法判断一个字符串是否为另外一个字符串前缀 Javascript /** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function(strs) { let prefix = strs[0] for(let i=1;i "},"easy/20.html":{"url":"easy/20.html","title":"20. Valid Parentheses(easy)","keywords":"","body":"20. Valid Parentheses Leetcode link 解题思路 看到这种有对称性并且对输入输出顺序有的题目，第一个想到的就是先进先出的栈了。 我们可以设计这样一个栈：当遇到左括号时，就把他们压入栈，而当遇到右括号时，只需确定两件事： 当前栈是否为空？ 如果是直接返回 false 当前栈顶是否是相对应的括号？ 如果不是直接返回 false 如果上述两个校验都通过了，那么只需要把当前的栈顶弹出去继续对比就好了。 最后，当输入的 字符串比对完了之后，我们需要检查当前的栈是否为空，如果为空表示所有左右括号是对称的，可以返回 true 了。如果不是则表示左括号多于右括号，返回 false C++ class Solution { public: bool isValid(string s) { stack stack; for (char c : s) { switch (c) { case '(': case '{': case '[': stack.push(c); break; case ')': if (stack.empty() || stack.top() != '(') return false; stack.pop(); break; case '}': if (stack.empty() || stack.top() != '{') return false; stack.pop(); break; case ']': if (stack.empty() || stack.top() != '[') return false; stack.pop(); break; } } return stack.empty(); } }; Javascript var isValid = function(s) { const stack = []; for(let c of s) { if(c === '(' || c === '{' || c === '['){ stack.push(c); } else { if(stack.length === 0) return false if(c === ')' && stack[stack.length-1] !== '(') return false; if(c === '}' && stack[stack.length-1] !== '{') return false; if(c === ']' && stack[stack.length-1] !== '[') return false; stack.pop() } } return stack.length === 0; }; "},"easy/21.html":{"url":"easy/21.html","title":"21. Merge Two Sorted Lists(easy)","keywords":"","body":"21. Merge Two Sorted Lists Leetcode link 题目简介 /** * @param {ListNode} list1 * @param {ListNode} list2 * @return {ListNode} */ 题目给我们两个链表 list1 与 list2，两个链表都是升序排列 要求我们按照升序组合两个链表成一个新链表 解题思路 按照题目要求模拟即可 Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} list1 * @param {ListNode} list2 * @return {ListNode} */ var mergeTwoLists = function (list1, list2) { const dummy = new ListNode() let cur = dummy while (list1 && list2) { if (list1.val "},"easy/26.html":{"url":"easy/26.html","title":"26. Remove Duplicates from Sorted Array(easy)","keywords":"","body":"26. Remove Duplicates from Sorted Array Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目要求我们把一个排序好的递增数组 nums 在数组内部去重 最后返回数组内不同元素的个数，nums 中的不同元素必须在前面部份 解题思路 要解答这题我们首先需要一个指针 i 用来遍历整个数组 其次，为了将当前遍历到的新元素替换前面遇到的重复元素，我们需要另一个指针 dup 来指向数组最左边重复的元素 所以这道题我们需要用到双指针中的快慢指针 所以这个问题就变成了我们要如何操作我们的两个指针呢？ 首先我们从数组元素来逐个判断： 第一个元素必定是新元素，所以它不可能是重复元素 数组的第二个元素有可能是重复元素，所以我们指向重复元素的慢指针 dup 初始值应该是指向第二个元素（也就是下标 1） 如果第二个元素是重复元素（通过 nums[dup - 1] === nums[i] 判断）我们只需要更新 i 指针 如果第二个元素不是重复元素，我们需要做两件事： 将当前 i 指针指向的值（也就是新的元素）赋值给下标 dup 的元素 更新 dup 指针的位置 Javascript /** * @param {number[]} nums * @return {number} */ var removeDuplicates = function (nums) { // 'dup' points to the position where the next unique element should be placed let dup = 1 for (let i = 1; i "},"easy/27.html":{"url":"easy/27.html","title":"27. Remove Element(easy)","keywords":"","body":"27. Remove Element Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} val * @return {number} */ 这题跟 26 有点像，题目给我们一个数字数组 nums 以及一个数字 val 要求我们将 nums 中不等于 val 的数字往前丢（修改原数组），最后返回有多少个不等于 val 的数字在数组中 解题思路 这题我们也需要用到两个指针来辅助 一个指针 target 负责指向最左边的等于 val 的元素下标 另一个指针 i 正常遍历数组 如果我们指针 i 遇到了不等于 val 的元素（nums[i] !== val），我们将 nums[i] 赋值给 nums[target]，然后将 target++ 最后我们返回 target 就是题目所求的不等于 val 的数字的数量 Javascript /** * @param {number[]} nums * @param {number} val * @return {number} */ var removeElement = function (nums, val) { let target = 0 for (let i = 0; i "},"easy/28.html":{"url":"easy/28.html","title":"28. Find the Index of the First Occurrence in a String(easy)","keywords":"","body":"28. Find the Index of the First Occurrence in a String Leetcode link 题目简介 /** * @param {string} haystack * @param {string} needle * @return {number} */ 题目给了两个数组：haystack 与 needle 要求在 haystack 中找到与 needle 完全匹配的子字符串并返回该子字符串在 haystack 中开头的下标 解题思路 这题我们还是用双指针来分别指向 haystack 与 needle 我们用 i 指针遍历 haystack，needlePtr 指针指向 needle 的第一个元素 如果 haystack[i] === needle[needlePtr] 则我们让两个指针一起前进直到其中一个遇到字符串尾或者两个指针指向的字符不同 如果 needlePtr === needle.length 表示我们遍历完了整个 needle 字符串，我们已经找到一个完全符合的子字符串了 否则我们重新把 needlePtr 指向 needle 的开头（也就是 needlePtr = 0） 需要留意的是，我们还原 needlePtr 的时候需要一并还原指针 i（也就是 i -= needlePtr）否则可能错过重复的字符串 Javascript /** * @param {string} haystack * @param {string} needle * @return {number} */ var strStr = function (haystack, needle) { let needlePtr = 0 // we can optimize this to i "},"easy/35.html":{"url":"easy/35.html","title":"35. Search Insert Position(easy)","keywords":"","body":"35. Search Insert Position Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} target * @return {number} */ 题目给我们一个升序数字数组 nums 以及一个数字 target 要求我们返回 target 在数组中的下标；如果不存在，则返回 target 插入数组的时候应该在的下标 要求 logn 的时间复杂度 解题思路 要求 logn 的复杂度的已排序数组搜索，我们优先使用二分搜索来做 Javascript /** * @param {number[]} nums * @param {number} target * @return {number} */ var searchInsert = function (nums, target) { let left = 0 let right = nums.length - 1 while (left > 1 if (nums[mid] === target) { return mid } else if (nums[mid] > target) { right = mid - 1 } else { left = mid + 1 } } return left }; "},"easy/70.html":{"url":"easy/70.html","title":"70. Climbing Stairs(easy)","keywords":"","body":"70. Climbing Stairs Leetcode link 题目简介 /** * @param {number} n * @return {number} */ 题目给我们一个数字 n 代表需要登上的台阶数量 登上台阶的方法有： 一次上一阶 一次上两阶 题目要求我们计算，一共有多少种方法可以登上第 n 阶 解题思路 通过观察我们发现，这个问题满足动态规划的条件： 首先，这个问题可以被拆分成多个子问题（满足 最优子结构性质）： 假设登上台阶 n 的状态为 f(n) f(n) 可以拆分成 f(n-1) 与 f(n-2) 其次，多个子问题是有重复性质的（满足 子问题重叠性质）： f(n-1) 可以被拆分成 f(n-2) 与 f(n-3) f(n-2) 重复了 最后，最终的问题并不会影响到子问题的结果（满足 无后效性）： f(n) 的结果并不会影响到 f(n-1) 接下来我们只需要确定初始状态以及状态转移方程就可以用 dp 求解了 状态转移方程： f(n) = f(n-1) + f(n-2) 解释：登上第 n-1 个台阶的可能方法数 + 登上第 n-2 个台阶可能的方法数 = 登上第 n 个台阶的可能方法数 初始状态： f(1)=1；f(2)=2 解释：登上一个台阶，只能有一种方法、登上两个台阶可以：一次上一个，上两次；一次上两个（两种方法） Javascript /** * @param {number} n * @return {number} */ var climbStairs = function (n) { const dp = [1, 2] for (let i = 2; i "},"easy/88.html":{"url":"easy/88.html","title":"88. Merge Sorted Array(easy)","keywords":"","body":"88. Merge Sorted Array Leetcode link 解题思路 题目要求我们将两个升序的数组按照升序合并到第一个数组中 由于第一个数组的多余空间是在后面，所以我们考虑一种由后往前遍历的方法 首先我们需要定义一个变量 k，表示数组 1 的真实长度的最后一位 然后我们从数组 1 与数组 2 的有效位 m-1 与 n-1 由后往前遍历 如果数组 1 的数比数组 2 的大，则将其放到 k 的位置……以此类推 最后我们只需要再检查一次数组 2 有没有漏网之鱼就好，因为数组 1 剩下的部分恰好在排列好应该在的位置 C++ class Solution { public: void merge(vector& nums1, int m, vector& nums2, int n) { int k = m+n-1; m--; n--; while(m >= 0 && n >= 0) { if(nums1[m]>=nums2[n]) { nums1[k--] = nums1[m--]; } else { nums1[k--] = nums2[n--]; } } while(n>=0) { nums1[k--] = nums2[n--]; } } }; Javascript /** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */ var merge = function(nums1, m, nums2, n) { let k = m+n-1; m--; n--; while(m>=0 && n>=0) { if(nums1[m]>=nums2[n]) { nums1[k--] = nums1[m--]; } else { nums1[k--] = nums2[n--]; } } while(n>=0) { nums1[k--] = nums2[n--]; } }; "},"easy/101.html":{"url":"easy/101.html","title":"101. Symmetric Tree(easy)","keywords":"","body":"101. Symmetric Tree Leetcode link 题目简介 /** * @param {TreeNode} root * @return {boolean} */ 题目给我们一个二叉树的根节点 root，要求我们判断该二叉树是否对称 解题思路 我们可以把 root 拆分成两个子树 left 与 right，这两者对称的条件是： 两者同时为 null left.val === right.val left.right 与 right.left 对称 left.left 与 right.right 对称 必须同时满足这四个条件 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isSymmetric = function(root) { const isMirror = (left, right) => { if(!left && !right) { // if both left and right are null return true } if(!left || !right) { // if only 1 is null return false } return left.val === right.val && isMirror(left.right, right.left) && isMirror(left.left, right.right) } return isMirror(root.left, root.right) }; "},"easy/104.html":{"url":"easy/104.html","title":"104. Maximum Depth of Binary Tree(easy)","keywords":"","body":"104. Maximum Depth of Binary Tree Leetcode link 题目简介 /** * @param {TreeNode} root * @return {number} */ 题目给我们一个二叉树根节点 root，要求我们计算树的深度 解题思路 我们直接深度遍历当前的树，在每个节点返回的时候把深度 + 1 即可 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function(root) { if(!root) { return 0 } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1 }; "},"easy/108.html":{"url":"easy/108.html","title":"108. Convert Sorted Array to Binary Search Tree(easy)","keywords":"","body":"108. Convert Sorted Array to Binary Search Tree Leetcode link 题目简介 /** * @param {number[]} nums * @return {TreeNode} */ 题目给我们一个升序数组 nums 要求我们根据 nums 生成一个平衡二叉树 平衡二叉树特性： 它是一个二叉排序树（二叉搜索树），即左子树中所有节点的值都小于根节点，右子树中所有节点的值都大于根节点。 它满足平衡条件：对于树中的每一个节点，其左子树和右子树的高度差的绝对值不超过1。 解题思路 借用评论区 的图 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} nums * @return {TreeNode} */ var sortedArrayToBST = function (nums) { const len = nums.length if (len === 0) { return null } const mid = Math.floor(len / 2) const root = new TreeNode(nums[mid]) root.left = sortedArrayToBST(nums.slice(0, mid)) root.right = sortedArrayToBST(nums.slice(mid + 1)) return root }; "},"easy/118.html":{"url":"easy/118.html","title":"118. Pascal's Triangle(easy)","keywords":"","body":"118. Pascal's Triangle Leetcode link 题目简介 /** * @param {number} numRows * @return {number[][]} */ 题目给我们一个数字 numRows 要求我们返回 Pascal's triangle 从第 1 行到第 numRows 行的所有元素组成的数组 Javascript /** * @param {number} numRows * @return {number[][]} */ var generate = function (numRows) { const res = [] for (let i = 0; i "},"easy/119.html":{"url":"easy/119.html","title":"119. Pascal's Triangle II(easy)","keywords":"","body":"119. Pascal's Triangle II Leetcode link 解题思路 TC: O(n) SC: O(n) 这是一道简单题，只要求我们求得 Pascal's triangle 中的某一行的所有数字 这道题有挑战的点在于题目要求我们只能使用 O(rowIndex) 的空间，也就是说，我们应该直接计算出对应的行，而非把整个三角形都算出来 有了这个思路之后我们还需要三个信息： Pascal's triangle 的第 n 行第 r 个值可以用 $\\tbinom{n}{r}$ 来表示（其中 n 跟 r 都是 0-index 的） 承上，$\\tbinom{n}{r + 1} = \\tbinom{n}{r} \\times \\frac{n-r}{r+1}$ （具体推导过程省略，可以用组合数公式自己算一下就有了） 每一行的第一个数都是 1 综合上述三个信息，我们就可以直接计算出任意一行的 Pascal's triangle 了，具体代码如下 Javascript /** * @param {number} rowIndex * @return {number[]} */ var getRow = function(rowIndex) { const res = [1]; for(let i=0;i "},"easy/121.html":{"url":"easy/121.html","title":"121. Best Time to Buy and Sell Stock(easy)","keywords":"","body":"121. Best Time to Buy and Sell Stock Leetcode link 题目简介 /** * @param {number[]} prices * @return {number} */ 题目给我们一个数字数组 prices 代表某只股票每日的价格 我们可以选择一天买入股票，选择一天卖出股票，题目希望我们得出最大的可能收益是多少 如果收益为负，则返回 0 解题思路 我们仍然使用贪心的策略，在这个题目中，我们的优势是可以随时反悔，所以我们要找到对我们最有利的返回时机 我们以 [7,1,5,3,6,4] 为例 假设我们在 7 块的时候买入了，在 1 块的时候我们意识到吃大亏了，这个时候我们需要反悔，重新选择在 1 块的时候买入 而后面股票的价格都比 1 块高，所以我们不需要反悔，只需要比较利润，在利润最高的时候出手即可 所以，我们反悔的时机点是：当后面股价比当前买入价低时，我们需要反悔 而为了避免反悔后比反悔前利润低的情况（比如 [2, 20, 1, 5]），我们需要用一个变量 profit 记录当前利润最大值 最后返回 profit 即可 Javascript /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { let profit = 0 let buyPrice = prices[0] for(const price of prices) { if(buyPrice > price) { buyPrice = price } profit = Math.max(profit, price - buyPrice) } return profit }; "},"easy/136.html":{"url":"easy/136.html","title":"136. Single Number(easy)","keywords":"","body":"136. Single Number Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums，数组之中大部分的数字都出现了两次，只有一个数字出现了一次 要求我们在 O(n) 时间复杂度与 O(1) 时间复杂度下把只出现一次的数字找出来返回 解题思路 这题我们可以用异或来解 两个相同的数字异或最后的结果为 0，所以只要我们把 nums 中所有数字进行异或，剩下来的数字就是答案 Javascript /** * @param {number[]} nums * @return {number} */ var singleNumber = function(nums) { let res = 0 for(const num of nums) { res ^= num } return res }; "},"easy/141.html":{"url":"easy/141.html","title":"141. Linked List Cycle(easy)","keywords":"","body":"141. Linked List Cycle Leetcode link 题目简介 /** * @param {ListNode} head * @return {boolean} */ 题目给我们一个链表头 head，要求我们判断该链表是否成环 解题思路 题目要求我们想出一个空间复杂度为 O(1) 的解法，所以我们要用到快慢指针 快指针 fast 一次前进两步；慢指针 slow 一次前进一步 我们让快慢指针同时从 head 出发，直到两者相遇（有环）或者快指针先碰到链表尾的 null（无环） Javascript /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {boolean} */ var hasCycle = function (head) { let slow = head let fast = head while(fast && fast.next) { fast = fast.next.next slow = slow.next if(fast === slow) { return true } } return false }; "},"easy/160.html":{"url":"easy/160.html","title":"160. Intersection of Two Linked Lists(easy)","keywords":"","body":"160. Intersection of Two Linked Lists Leetcode link 解题思路——拼接 题目要求我们找出两个链表 A、B 第一个相交的节点 第一个思路就是拼接，我们需要做三个操作： 把链表 A 的尾巴拼接上链表 B 得到链表 C 把链表 B 的尾巴拼接上链表 A 得到链表 D 从头到尾同时遍历链表 C 和 D，找到第一个相同的元素就是链表 A、B 第一个相交的节点 C++ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *p=headA; ListNode *q=headB; // flag 表示还没经过拼接，在遍历到链表尾的时候需要做一下拼接 bool flagA = true; bool flagB = true; while(p != q) { if(p == nullptr && flagA) { // 只需要拼接一次，不然如果没有交点的话会一直循环下去 flagA = false; p = headB; } else { p = p->next; } if(q == nullptr && flagB) { flagB = false; q = headA; } else { q = q->next; } } // 找到第一个相同的就是所求节点，如果没有就是 nullptr return p; } }; 解题思路——计算长度 这个思路也挺有意思的 我们知道两个有相交节点的相交部分长度是一样的，所以我们只需要计算两个链表的长度差 diff 然后将较长的那个链表先遍历 diff 个元素，这样一来两个链表剩下的长度就想等了 最后我们只需要同时遍历两个链表的剩余部分比较是否相同就好 C++ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *p=headA; ListNode *q=headB; int lenA = 0; int lenB = 0; // 计算两个链表长度 while(p != nullptr) { lenA++; p = p->next; } while(q != nullptr) { lenB++; q = q->next; } int diff; // 把 p 指向比较长的链表 if(lenA > lenB) { diff = lenA - lenB; p = headA; q = headB; } else { diff = lenB - lenA; p = headB; q = headA; } // 将比较长的那个链表先遍历一点 while(diff-- > 0) { p = p->next; } // 这个时候两个链表剩余部分长度相同，直接一起遍历就好 while(p != q) { p = p->next; q = q->next; } return p; } }; "},"easy/169.html":{"url":"easy/169.html","title":"169. Majority Element(easy)","keywords":"","body":"169. Majority Element Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums 要求我们找出其中出现次数找过一半以上的次数（题目保证每个数组都有这个元素） 此外要求我们需要使用 O(n) 时间复杂度与 O(1) 空间复杂度 解题思路 由于题目保证有元素超过了一半以上，所以我们只需要用一个变量 res 记录当前元素、用变量 majorityCount 记录当前元素出现次数 如果当前元素再次出现，我们让 majorityCount++；如果出现其他元素，我们让 majorityCount-- 如果 majorityCount === 0，我们更新 res 为当前遍历的元素即可 最后 res 的值为答案 Javascript /** * @param {number[]} nums * @return {number} */ var majorityElement = function(nums) { let res = 0 let majorityCount = 0 for(const num of nums) { if(majorityCount === 0) { res = num } if(res === num) { majorityCount++ } else { majorityCount-- } } return res }; "},"easy/191.html":{"url":"easy/191.html","title":"191. Number of 1 Bits(easy)","keywords":"","body":"191. Number of 1 Bits Leetcode link 解题思路 本题要求我们计算一个 32 位 unsigned int 中 1 的个数 主要考察点事位运算，我们可以用 n &= n - 1 来减少最后一位的 1 只需要不断的减少直到 n 最后为 0，减少的次数就是 1 的次数 C++ class Solution { public: int hammingWeight(uint32_t n) { int res = 0; while(n != 0) { n &= n - 1; res++; } return res; } }; "},"easy/206.html":{"url":"easy/206.html","title":"206. Reverse Linked List(easy)","keywords":"","body":"206. Reverse Linked List Leetcode link 题目简介 /** * @param {ListNode} head * @return {ListNode} */ 题目给我们一个链表头 head 要求我们翻转链表的元素并返回新的头指针 解题思路 我们只需要把链表所有元素的 next 指针指向前一个元素，就可以翻转整个链表 为了修改链表指针，我们需要三个变量： left 指向要修改的元素的前一个元素、mid 指向要修改的当前元素、right 指向要修改的下一个元素 在每次循环中，我们修改 mid.next，然后把 mid 赋值给 left，right 赋值给 mid ，直到 mid 指向 null 最后我们还需要修改一下 head 的 next 指向，将其指向 null Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { if(!head) { return null } let left = head let mid = head.next while(mid) { let right = mid.next mid.next = left left = mid mid = right } head.next = null return left }; "},"easy/225.html":{"url":"easy/225.html","title":"225. Implement Stack using Queues(easy)","keywords":"","body":"225. Implement Stack using Queues Leetcode link 这个题目用 JS 做就没意义了，我只写了 C++ 的三个版本 解题思路——两个 queue，对 push 做手脚 push 操作时间复杂度：O(n) 维护两个队列，在 push 元素的时候首先把元素 push 到辅助队列 p2，然后把 p1 的元素逐个丢到 p2 ，最后把两个队列交换 C++ class MyStack { private: queue q1; queue q2; public: MyStack() {} void push(int x) { q2.push(x); while (q1.size() > 0) { q2.push(q1.front()); q1.pop(); } swap(q1, q2); } int pop() { int res = q1.front(); q1.pop(); return res; } int top() { return q1.front(); } bool empty() { return q1.size() == 0; } }; 解题思路——两个 queue，对 pop 做手脚 pop 操作时间复杂度：O(n) 在做 pop 操作的时候，首先把队列 p1 除了最后一个元素之外都往 p2 丢，丢到最后一个元素的时候记得保存一下，然后先交换两个队列，最后再返回最后一个元素。 C++ class MyStack { private: queue q1; queue q2; public: MyStack() {} void push(int x) { q1.push(x); } int pop() { // 除了最后一个元素之外其他都往 q2 丢 while (q1.size() > 1) { q2.push(q1.front()); q1.pop(); } // 把最后一个元素保存一下 int res = q1.front(); q1.pop(); // 把 q2 的元素丢回来 while (q2.size() > 0) { q1.push(q2.front()); q2.pop(); } return res; } int top() { return q1.back(); } bool empty() { return q1.size() == 0; } }; 解题思路—— 一个 queue push 操作时间复杂度：O(n) 只有一个队列的时候情况有些不同了，考虑在 push 元素的时候，需要多出以下步骤 先正常往队列尾部 push 元素 把队列尾部之前的元素都从头部弹出之后插入尾部 这样以来，队列之后 pop 操作弹出的就是最后加进来的元素了 C++ class MyStack { private: queue q; public: MyStack() {} void push(int x) { q.push(x); int size = q.size(); // 把最后一个元素以外的元素全部往队列尾部丢 while (size > 1) { q.push(q.front()); q.pop(); size--; } } int pop() { int res = q.front(); q.pop(); return res; } int top() { return q.front(); } bool empty() { return q.size() == 0; } }; "},"easy/226.html":{"url":"easy/226.html","title":"226. Invert Binary Tree(easy)","keywords":"","body":"226. Invert Binary Tree Leetcode link 题目简介 /** * @param {TreeNode} root * @return {TreeNode} */ 题目给我们一个二叉树的根节点 root 要求我们在原地反转二叉树，并且返回根节点 root 解题思路 这题的核心就是，把每一个节点的左右子树都进行交换 我们可以用 dfs 遍历完左右子树后，交换节点的 left 与 right 指针 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {TreeNode} */ var invertTree = function (root) { const dfs = (node) => { if (!node) { return } dfs(node.left) dfs(node.right) ;[node.left, node.right] = [node.right, node.left] } dfs(root) return root }; "},"easy/234.html":{"url":"easy/234.html","title":"234. Palindrome Linked List(easy)","keywords":"","body":"234. Palindrome Linked List Leetcode link 题目简介 /** * @param {ListNode} head * @return {boolean} */ 题目给我们一个链表头 head 要求我们判断该链表是否能构成回文 解题思路 这题有很多种解决方法，但是如果要用到 O(1) 的空间复杂度，我们需要一些额外的操作 整体思路如下： 我们找到链表中的中间节点 把中间节点后的链表翻转 从原来链表的两侧向中间比较节点元素 Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {boolean} */ var isPalindrome = function(head) { // 1. find the middle node let fast = head let slow = head while(fast && fast.next) { fast = fast.next.next slow = slow.next } // 2. reverse the second half of the list let prev = null let cur = slow while(cur) { let next = cur.next cur.next = prev prev = cur cur = next } // 3. compare 2 list let first = head let second = prev while(second) { if(first.val !== second.val) { return false } first = first.next second = second.next } return true }; "},"easy/268.html":{"url":"easy/268.html","title":"268. Missing Number(easy)","keywords":"","body":"268. Missing Number Leetcode link 解题思路——加总 本题要我们求一个值由 0 ~ n 组成的长度为 n 的数组里缺失的数字 总共有两种方法来求解，第一种思路是： 用 0 ~ n 的加总减去数组元素的加总 C++ class Solution { public: int missingNumber(vector& nums) { int res = nums.size(); for(int i=0;i Javascript /** * @param {number[]} nums * @return {number} */ var missingNumber = function(nums) { let len = nums.length; let sum = nums.reduce((prev, cur)=>prev + cur, 0); return len * (len + 1) / 2 - sum; }; 解题思路——亦或 另一种思路则是用到了亦或的操作： 我们把所有数组元素进行亦或 然后把 0 ~ n 的数字也进行亦或 最后把上述两个结果亦或就是答案了 C++ class Solution { public: int missingNumber(vector& nums) { int res = nums.size(); int i = 0; for(int num : nums) { res ^= num ^ i++; } return res; } }; JavaScript /** * @param {number[]} nums * @return {number} */ var missingNumber = function(nums) { let res = nums.length, cur = 0; for(let num of nums) { res ^= num ^ cur; cur++; } return res; }; "},"easy/283.html":{"url":"easy/283.html","title":"283. Move Zeroes(easy)","keywords":"","body":"283. Move Zeroes Leetcode link 题目简介 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ 题目给我们一个数字数组 nums 要求我们把 nums 中所有非零的元素原地前移 解题思路 我们用一个指针 pos 指向当前可以交换的位置 然后用另外一个指针 i 遍历数组，如果遇到不为 0 的元素则跟 pos 交换，交换完成后将 pos++ 即可 Javascript /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var moveZeroes = function (nums) { let pos = 0 for (let i = 0; i "},"easy/344.html":{"url":"easy/344.html","title":"344. Reverse String(easy)","keywords":"","body":"344. Reverse String Leetcode link 解题思路 TC: O(n) SC: O(1) 本题要求逆转一个字符数组，一个简单的思路就是用两个指针分别从数组头与尾前进，并依次交换直到指针相遇。 C++ // for 版本 class Solution { public: void reverseString(vector& s) { int len = s.size(); for (int i = 0; i & s) { int left = 0, right = s.size() - 1; while (left Javascript var reverseString = function(s) { let left = 0, right = s.length - 1; while (left "},"easy/345.html":{"url":"easy/345.html","title":"345. Reverse Vowels of a String(easy)","keywords":"","body":"345. Reverse Vowels of a String Leetcode link 题目简介 /** * @param {string} s * @return {string} */ 题目给我们一个字符串 s，其中包含有大小写的母音字母以及一些 ASC2 字符 题目要求我们把 s 中的所有母音字符全部反转，然后返回一个新的字符串 解题思路 我们可以用一个数组 res 来保存字符串 s 然后我们使用双指针分别从数组头尾往中间遍历 遍历过程中如果两个指针同时指向了母音字符则交换两个指针指向的元素，否则继续遍历 最后我们将数组 res 重新组合为字符串返回即可 Javascript /** * @param {string} s * @return {string} */ var reverseVowels = function(s) { const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']) const res = s.split('') let left = 0 let right = s.length - 1 while(left "},"easy/392.html":{"url":"easy/392.html","title":"392. Is Subsequence(easy)","keywords":"","body":"392. Is Subsequence Leetcode link 题目简介 /** * @param {string} s * @param {string} t * @return {boolean} */ 题目给我们两个字符串 s 与 t 要求我们判断 s 是否是 t 的子序列 解题思路 我们可以用两个指针分别指向 s 与 t 字符串，当遍历 t 的时候，如果两个指针指向的元素相等，则把指向 s 的指针加一 如果最后指向 s 的指针遇到了 s 字符串的末尾，则返回 true，否则返回 false Javascript /** * @param {string} s * @param {string} t * @return {boolean} */ var isSubsequence = function (s, t) { let idx = 0 for (let i = 0; i "},"easy/543.html":{"url":"easy/543.html","title":"543. Diameter of Binary Tree(easy)","keywords":"","body":"543. Diameter of Binary Tree Leetcode link 题目简介 /** * @param {TreeNode} root * @return {number} */ 题目给我们一个二叉树的根节点 root 要求我们计算树中最远的两个节点的距离是多少（节点的距离由节点之间的连接数量决定） 解题思路 题目的要求翻译：我们需要找到二叉树的一个节点，这个节点的左右子树高度加起来最高 要求左右子树的高度，我们需要用到 dfs 的思路 由于我们需要找到左右子树高度和最高的节点，我们需要一个变量 maxDiameter 来记录当前左右子树高度之和的最高值 我们在 dfs 回溯的时候要做两件事： 比较 maxDiameter 与 leftHeight + rightHeight 使用其最大值更新 maxDiameter（leftHeight 与 rightHeight 分别代表当前节点的左右子树高度） 返回 max(leftHeight, rightHeight) + 1 用于给当前节点父节点提供判断子树高度的依据 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var diameterOfBinaryTree = function(root) { let maxDiameter = 0 const dfs = (node) => { if(!node) { return 0 } const leftHeight = dfs(node.left) const rightHeight = dfs(node.right) maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight) return Math.max(leftHeight, rightHeight) + 1 } dfs(root) return maxDiameter }; "},"easy/605.html":{"url":"easy/605.html","title":"605. Can Place Flowers(easy)","keywords":"","body":"605. Can Place Flowers Leetcode link 题目简介 /** * @param {number[]} flowerbed * @param {number} n * @return {boolean} */ 题目给我们一个数字数组 flowerbed 与数字 n 要求我们把 n 束花插到 flowerbed 中 flowerbed 的元素由 1 或 0 组成：1 代表该位置有花了；0 代表该位置是空的 题目约束相邻的位置不能够插两束花 我们需要返回 flowerbed 是否有足够空间插入 n 束花 解题思路 能够插入花束的 flowerbed 有三个条件： 当前位置 flowerbed[i] 为 0 前一个位置 flowerbed[i-1] 为数组边界或者为 0 后一个位置 flowerbed[i+!] 为数组边界或者为 0 当有位置同时满足以上三个条件，才能插新的花束 此外，如果有个位置满足了条件，我们可以暂时将其置为 1，表示该位置已经被占据了 遍历 flowerbed 找出所有可能的位置跟 n 比较，如果大于等于 n，则返回 true；否则返回 false Javascript /** * @param {number[]} flowerbed * @param {number} n * @return {boolean} */ var canPlaceFlowers = function (flowerbed, n) { let avalibleFlowerbed = 0 const len = flowerbed.length for (let i = 0; i = n }; "},"easy/643.html":{"url":"easy/643.html","title":"643. Maximum Average Subarray I(easy)","keywords":"","body":"643. Maximum Average Subarray I Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {number} */ 题目给我们一个数字数组 nums 以及一个数字 k 要求我们在数组中找到长度为 k 的连续子数组使其平均值最大 最后返回平均值 解题思路 这题我们需要使用滑动窗口的思路来求解 我们构建一个长度为 k 的滑动窗口，在每次滑动的时候记录当前窗口元素之和 然后我们用一个变量 max 来记录和最大的窗口是多少 最后我们用 max / k 就能获得平均值了 Javascript /** * @param {number[]} nums * @param {number} k * @return {number} */ var findMaxAverage = function (nums, k) { let max = 0 let left = 0 let right = 0 while (right "},"easy/680.html":{"url":"easy/680.html","title":"680. Valid Palindrome II(easy)","keywords":"","body":"680. Valid Palindrome II Leetcode link 解题思路 本题要求我们检测回文字符串，并且可以最多丢弃任一字符。 检测回文的其中一个方法就是用双指针往中间遍历，由于我们可以丢弃任一字符，我们需要考虑遇到不匹配的情况下要删除哪一边的字符。 解决方法是两边都试一下，只要有一边成功了，就表示这个字符是符合要求的。 C++ class Solution { public: bool isValid(string s, int left, int right) { while (left Javascript var validPalindrome = function(s) { let left = 0, right = s.length - 1; while (left "},"easy/682.html":{"url":"easy/682.html","title":"682. Baseball Game(easy)","keywords":"","body":"682. Baseball Game Leetcode link 解题思路 这题跟棒球没有半毛钱关系。。。。 本题给了我们一些字符串形式的数字，还有三个不同的运算符，自然而然的就能想到可以用栈这个数据结构先进先出的特性来处理 要注意的点在于变量的类型转换。 C++ class Solution { public: int calPoints(vector& ops) { stack stack; int res = 0; for (string ele : ops) { if (ele == \"C\") { stack.pop(); } else if (ele == \"D\") { // 对字符串用乘法会自动转成数字 stack.push(stack.top() * 2); } else if (ele == \"+\") { int value1 = stack.top(); stack.pop(); int value2 = stack.top(); stack.push(value1); // 加法也是 stack.push(value1 + value2); } else { // 需要显式转换为数字 stack.push(stoi(ele)); } } while (!stack.empty()) { res += stack.top(); stack.pop(); } return res; } }; Javascript /** * @param {string[]} ops * @return {number} */ var calPoints = function(ops) { let res = 0; let stack = []; for(let ele of ops) { switch (ele) { case \"C\": stack.pop(); break; case \"D\": // js 对数字形式的字符串用乘法会类型转换为数字 stack.push(stack[stack.length-1] * 2); break; case \"+\": let value1 = stack[stack.length-1]; let value2 = stack[stack.length-2]; // 必须显式类型转换，不然会字符串拼接 stack.push(Number(value1) + Number(value2)); break; default : // 显式转换 stack.push(Number(ele)); } } for(let num of stack) { res+=num; } return res; }; "},"easy/700.html":{"url":"easy/700.html","title":"700. Search in a Binary Search Tree(easy)","keywords":"","body":"700. Search in a Binary Search Tree Leetcode link 解题思路 这题非常简单，我们用 BST 左小右大的特性，循环查找就可以了。 C++ class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { while (root != nullptr && root->val != val) { root = (val > root->val) ? root->right : root->left; } return root; } }; Javascript var searchBST = function(root, val) { while(root!== null && root.val!== val) { root = root.val > val ? root.left : root.right; } return root; }; "},"easy/703.html":{"url":"easy/703.html","title":"703. Kth Largest Element in a Stream(easy)","keywords":"","body":"703. Kth Largest Element in a Stream Leetcode link 解题思路 本题要求我们给出流的第 k 大数字。 本题的核心思路在于，我们维护一个大小为 k 的排序数组，始终让它保存着前 k 大的数字。 有了数组之后，当流再次来数据的时候，有两种可能： 来的数据比第 k 大的数字小，则直接丢弃，返回原来的第 k 大的数字 来的数据比第 k 大的数字，把原来第 k 大的数字丢弃，之后把新数据在插入数组相应位置保持排序 只要处理好这两种状态这题就结束了 C++ class KthLargest { private: int size = 0; // 用了一个优先队列来封装插入的操作 priority_queue, greater> pq; public: KthLargest(int k, vector& nums) { size = k; for (int num : nums) { add(num); } } int add(int val) { // 始终保持队列只有 k 个数字 if (pq.size() pq.top()) { pq.pop(); pq.push(val); } } return pq.top(); } }; Javascript /** * @param {number} k * @param {number[]} nums */ var KthLargest = function(k, nums) { this.size = k; this.stream = nums.sort((a,b)=>b-a).slice(0,k); }; /** * @param {number} val * @return {number} */ KthLargest.prototype.add = function(val) { if(this.stream.length === 0 || val > this.stream[0]) { this.stream.unshift(val); }else if(val = val && this.stream[i + 1] "},"easy/704.html":{"url":"easy/704.html","title":"704. Binary Search(easy)","keywords":"","body":"704. Binary Search Leetcode link 解题思路 题目要求我们从一个升序数组中找出一个特定的数，这种情况下二分法肯定是不二之选了，所以接下来的问题是怎么构造呢？ 首先我们需要三个点：left, right, mid left 用来确定二分范围的左边界 right 用来确定二分范围的右边界 mid 是本次二分范围的中心，用来确定下一次二分的区域 每次循环我们用 nums[mid] 的值做判断，如果 target 比较大，那么表示它如果存在必定在右边的区域，反之则一定在左边的区域 我们只需要通过调整二分的范围，然后重复上述步骤就可以不断缩小范围了，最后如果 left 超过了 right 则表示不存在这个数，直接返回 -1 就好 C++ class Solution { public: int search(vector& nums, int target) { int left = 0, right = nums.size() - 1; while (left nums[mid]) left = mid + 1; // 如果 target 比当前的数小，那我们可以将范围移到左边区域 else if (target Javascript var search = function(nums, target) { let left = 0, right = nums.length-1; while(left nums[mid]) left = mid + 1; } return -1; }; "},"easy/705.html":{"url":"easy/705.html","title":"705. Design HashSet(easy)","keywords":"","body":"705. Design HashSet Leetcode link 解题思路 本题要求我们实现一个简单的 hashSet 的 add、contains、remove 方法 一个最简单的想法就是用一个 map 去建立所有新增进来的 key 的映射，这样就会非常简单，下面我用 JS 实现了这个思路 另一个想法就是用 N 个 “桶” 来 “分类” 一下要新增的 key，具体而言，我们用 key % N 来做分类。这样可以降低空间使用。下面我用 C++ 实现这种思路。 C++ class MyHashSet { private: // 由于题目说 key 的范围大概在 10^6，所以取个 10^2 就差不多了，当然可以随意调整 const int BUCKET_SIZE = 100; vector bucket[100]; public: MyHashSet() {} void add(int key) { int index = key % BUCKET_SIZE; if (!contains(key)) { bucket[index].push_back(key); } } void remove(int key) { int index = key % BUCKET_SIZE; auto it = find(bucket[index].begin(), bucket[index].end(), key); if (it != bucket[index].end()) { bucket[index].erase(it); } } bool contains(int key) { int index = key % BUCKET_SIZE; if (find(bucket[index].begin(), bucket[index].end(), key) != bucket[index].end()) { return true; } else { return false; } } }; Javascript var MyHashSet = function() { this.set = {}; }; /** * @param {number} key * @return {void} */ MyHashSet.prototype.add = function(key) { this.set[key] = key; }; /** * @param {number} key * @return {void} */ MyHashSet.prototype.remove = function(key) { delete this.set[key]; }; /** * @param {number} key * @return {boolean} */ MyHashSet.prototype.contains = function(key) { return key in this.set }; "},"easy/706.html":{"url":"easy/706.html","title":"706. Design HashMap(easy)","keywords":"","body":"706. Design HashMap Leetcode link 解题思路 本题跟 705 的思路基本相同，区别在于这题的 map 在添加已经存在的 key 的时候需要覆盖原来的值；而 705 的 set 是直接不处理。 在 JS 中，因为已经有天然的 map 了，我就直接用了。 C++ 的话我还是选择用多个桶，来降低空间的使用。 C++ class MyHashMap { private: const int BUCKET_SIZE = 100; vector> bucket[100]; public: MyHashMap() {} void put(int key, int value) { for (auto& [k, v] : bucket[key % BUCKET_SIZE]) { if (key == k) { v = value; return; } } bucket[key % BUCKET_SIZE].push_back({key, value}); } int get(int key) { for (auto& [k, v] : bucket[key % BUCKET_SIZE]) { if (key == k) { return v; } } return -1; } void remove(int key) { int i = 0; auto& target = bucket[key % BUCKET_SIZE]; for (auto& [k, v] : target) { if (key == k) { target.erase(target.begin() + i); } i++; } } }; Javascript var MyHashSet = function() { this.set = {}; }; /** * @param {number} key * @return {void} */ MyHashSet.prototype.add = function(key) { this.set[key] = key; }; /** * @param {number} key * @return {void} */ MyHashSet.prototype.remove = function(key) { delete this.set[key]; }; /** * @param {number} key * @return {boolean} */ MyHashSet.prototype.contains = function(key) { return key in this.set }; "},"easy/717.html":{"url":"easy/717.html","title":"717. 1-bit and 2-bit Characters(easy)","keywords":"","body":"717. 1-bit and 2-bit Characters Leetcode link 题目简介 /** * @param {number[]} bits * @return {boolean} */ 本题给了一个数字数组 bits，它的元素只有可能是 1 或 0，且数组的最后一个元素必为 0 如果相邻的两个元素是 [1, 1] 或 [1, 0] 他们可以被合并为 [11] 或 [10]，这种情况我们称之为 2 比特字符 如果某个元素是 [0]，则它可以被合并为 [0]，这种情况我们称之为 1 比特字符 题目要求我们回答给定的字符串 bits 的最后一个 0 是否是 1 比特字符 解题思路 我们可以遍历数组，如果遇到 1 的话，则表示遇到 2 比特字符了，我们把遍历下标加 2 反之如果遇到 0，我们就正常把遍历下标加 1 即可 遍历下标的边界是 0～bits.length - 2 如果最后遍历下标指向了数组的最后一个元素，则表示最后一个 0 是 1 比特字符，否则就是 2 比特字符 Javascript /** * @param {number[]} bits * @return {boolean} */ var isOneBitCharacter = function(bits) { const len = bits.length let i = 0 while(i "},"easy/724.html":{"url":"easy/724.html","title":"724. Find Pivot Index(easy)","keywords":"","body":"724. Find Pivot Index Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums 要求我们找出一个元素下标使得其左右两边的元素之和相等 最后返回该元素下标 解题思路 我们用两个变量 leftSum 与 rightSum 来记录任意元素所有两边元素之和 在遍历的过程中，我们不断更新与判断两个变量是否相等，如果相等则马上返回当前下标 否则遍历完成后返回 -1 Javascript /** * @param {number[]} nums * @return {number} */ var pivotIndex = function (nums) { let rightSum = nums.reduce((acc, cur) => acc + cur, 0) let leftSum = 0 for (let i = 0; i "},"easy/812.html":{"url":"easy/812.html","title":"812. Largest Triangle Area(easy)","keywords":"","body":"812. Largest Triangle Area Leetcode link 题目简介 这题是一道纯数学的简单题 题目给我们一个参数 points 代表直角坐标上的若干个点，要求我们求出这些点能够构成的最大三角形面积 解题思路 这道题需要用到一个公式：https://en.wikipedia.org/wiki/Shoelace_formula 简单来说，平面直角坐标系的三角形面积可以通过：$\\frac{1}{2}|(x_1y_2 - y_1x_2) + (x_2y_3 - y_2x_3) + (x_3y_1 - x_1y_3)|$ 来计算 然后我们用三个循环依次遍历所有的点就可以得到最大的面积了 Javascript /** * @param {number[][]} points * @return {number} */ var largestTriangleArea = function (points) { let maxArea = 0 const len = points.length for (let i = 0; i "},"easy/844.html":{"url":"easy/844.html","title":"844. Backspace String Compare(easy)","keywords":"","body":"844. Backspace String Compare Leetcode link 解题思路——栈 这个题目还是比较简单的，用两个栈分别存放两个字符串，只要遇到 # 就把当前栈顶弹出去就好 C++ class Solution { private: string convert(string &S) { string res; for (char c : S) { if (c == '#') { if (!res.empty()) { res.pop_back(); } } else { res += c; } } return res; } public: bool backspaceCompare(string s, string t) { return convert(s) == convert(t); } }; Javascript var backspaceCompare = function(s, t) { return convert(s) === convert(t); }; function convert(S) { let res = []; for (let i = 0;i 解题思路——SC: O(1) 如果不使用栈的话可以用两个变量来 “模拟” 一下 class Solution { public: bool backspaceCompare(string s, string t) { int k = 0, l = 0; for (int i = 0; i "},"easy/867.html":{"url":"easy/867.html","title":"867. Transpose Matrix(easy)","keywords":"","body":"867. Transpose Matrix Leetcode link 解题思路 题目要求一个沿着主轴转置的矩阵 一个简单的思路就是创建一个新的矩阵，但是长跟宽要跟原来的相反 之后遍历旧的矩阵，将行与列的下标呼唤赋值到新的矩阵就好 C++ class Solution { public: vector> transpose(vector>& matrix) { int m = matrix.size(); int n = matrix[0].size(); vector> res(n, vector(m, 0)); for(int i=0;i Javascript /** * @param {number[][]} matrix * @return {number[][]} */ var transpose = function(matrix) { let m = matrix.length; let n = matrix[0].length; let res = new Array(n); for(let i=0;i "},"easy/872.html":{"url":"easy/872.html","title":"872. Leaf-Similar Trees(easy)","keywords":"","body":"872. Leaf-Similar Trees Leetcode link 题目简介 /** * @param {TreeNode} root1 * @param {TreeNode} root2 * @return {boolean} */ 题目给我们两个二叉树的根节点 要求我们求出两棵树是否是叶子节点相似的 叶子节点相似的意思是，从左到右遍历叶子节点其元素与顺序一致 解题思路 我们分别准备两个数组 arr1 与 arr2 来保存我们遍历到的叶子节点元素 接下来我们用 dfs 进行树的前序遍历，在遍历过程中把遇到的所有叶子节点推进数组中 最后对比两个数组即可 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root1 * @param {TreeNode} root2 * @return {boolean} */ var leafSimilar = function (root1, root2) { const arr1 = [] const arr2 = [] const dfs = (node, arr) => { if (!node) { return } if (!node.left && !node.right) { arr.push(node.val) } dfs(node.left, arr) dfs(node.right, arr) } dfs(root1, arr1) dfs(root2, arr2) if (arr1.length !== arr2.length) { return false } for (let i = 0; i 复杂度分析 时间 假设 N = root1.length, M = root2.length 我们对两棵树都进行了 dfs，需要遍历所有的树节点，时间分别是 O(N)、O(M) 此外我们进行了数组的比较，但是数组元素小于 N 或 M（最差的情况就是树节点的一半），所以不是主导 最后的时间复杂度就是 O(N + M) 空间 我们使用了两个数组 arr1，arr2 这两个数组最坏的情况会有树节点的一半数量的元素，所以分别是 O(N)、O(M) 此外我们还用了 DFS 遍历了两棵树，遍历的空间取决于树的高度： 最好的情况：O(logN)、O(logM) 最差的情况（单边树）：O(N)、O(M) 最后整体的空间复杂度是 O(N + M) "},"easy/897.html":{"url":"easy/897.html","title":"897. Increasing Order Search Tree(easy)","keywords":"","body":"897. Increasing Order Search Tree Leetcode link 解题思路 要把一个 BST 转变为单边递增的树，第一个想到的方法就是深度优先遍历的中序遍历，为了提高效率，最好是利用题目给的节点去做原地修改。 C++ class Solution { public: TreeNode* cur; void dfs(TreeNode* node) { if (node == nullptr) { return; } dfs(node->left); node->left = nullptr; cur->right = node; cur = cur->right; dfs(node->right); } TreeNode* increasingBST(TreeNode* root) { TreeNode* res = new TreeNode(); cur = res; dfs(root); return res->right; } }; Javascript var increasingBST = function(root) { let res = new TreeNode(); let cur = res; let dfs = (node)=>{ if(!node) { return; } dfs(node.left); node.left = null; cur.right = node; cur = cur.right; dfs(node.right); } dfs(root); return res.right; }; "},"easy/905.html":{"url":"easy/905.html","title":"905. Sort Array By Parity(easy)","keywords":"","body":"905. Sort Array By Parity Leetcode link 解题思路 简单题，说白了就是把偶数往前丢，然后剩下的奇数往后放就好，直接看代码 C++ class Solution { public: vector sortArrayByParity(vector& nums) { int left = 0, right = nums.size() - 1; while (left Javascript var sortArrayByParity = function(nums) { let left = 0, right = nums.length-1; while(left "},"easy/933.html":{"url":"easy/933.html","title":"933. Number of Recent Calls(easy)","keywords":"","body":"933. Number of Recent Calls Leetcode link 题目简介 var RecentCounter = function() {}; /** * @param {number} t * @return {number} */ RecentCounter.prototype.ping = function(t) {}; 题目让我们实现一个 RecentCounter 系统，其中包含： 构造函数 RecentCounter 方法 ping 其中 ping 方法接收一个参数 t 代表时间，表示在时间 t 添加了一个请求，并且需要返回在 t 时间的 3000 毫秒内的所有请求数量 解题思路 这题需要选用先进先出的数据结构，所以我们选用队列 在构造函数中，我们创建一个队列 queue；在 ping 方法被调用时，我们除了把新的时间 push 进 queue，还要把 t-3000 之前的请求 shift 出队列 最后在 ping 中返回队列长度即可 Javascript var RecentCounter = function () { this.queue = [] }; /** * @param {number} t * @return {number} */ RecentCounter.prototype.ping = function (t) { this.queue.push(t) while(this.queue[0] "},"easy/976.html":{"url":"easy/976.html","title":"976. Largest Perimeter Triangle(easy)","keywords":"","body":"976. Largest Perimeter Triangle Leetcode link 题目简介 这是道简单，题目给我们一个数组 nums，数组元素代表线段的长度，题目要求我们从中找出三条边组成三角形，并且要求返回组成三角形中边长最长的三角形的边长，如果不能组成三角形则返回 0 解题思路 三角形能组成的条件是两边之和要大于第三边 为了减少计算量，我们可以先对数组 nums 进行降序排序 接下来，我们只需要找连续的三个长度是否符合三角形组成条件即可 Javascript /** * @param {number[]} nums * @return {number} */ var largestPerimeter = function (nums) { const sortedNums = nums.toSorted((a, b) => b - a) for (let i = 0; i "},"easy/1018.html":{"url":"easy/1018.html","title":"1018. Binary Prefix Divisible By 5(easy)","keywords":"","body":"1018. Binary Prefix Divisible By 5 Leetcode link 题目简介 /** * @param {number[]} nums * @return {boolean[]} */ 题目给我们一个数字数组 nums，其元素只有 0 与 1 我们通过遍历 nums 下标 0～i 可以得到 nums.length 个二进制数组 举个例子：nums = [1,0,1] 当 i = 0 时二进制表示为 1b 可得 x0 = 1 当 i = 1 时二进制表示为 10b 可得 x1 = 2 当 i = 2 时二进制表示为 101b 可得 x2 = 5 题目要求我们返回一个数组 ans，ans 的每一个元素值是对应该下标得到的数字是否可以被 5 整除（true/false） 解题思路 当我们把下标加一时，有可能是 0 或者 1 0 代表把当前数字乘二 1 代表把当前数字乘二加一 我们可以通过上述规则计算出当前数字，但是我们只关心当前数字是否可以被 5 整除，所以我们可以每次操作后用当前数字对 5 取模 取模后如果为 0，则表示当前数字可以被 5 整除，则结果为 true，否则为 false Javascript /** * @param {number[]} nums * @return {boolean[]} */ var prefixesDivBy5 = function (nums) { let remainder = 0 return nums.map(num => { remainder = (remainder * 2 + num) % 5 return remainder % 5 === 0 }) }; "},"easy/1046.html":{"url":"easy/1046.html","title":"1046. Last Stone Weight(easy)","keywords":"","body":"1046. Last Stone Weight Leetcode link 解题思路 本题一直要求我们重复取最大的两个石头，所以第一个想到的就是优先队列了。 我们只需要在石头数量大于 1 颗的时候，重复 “取两个石头，相撞，把剩下的放进优先队列” 这几个步骤就好。 最后判断一下如果还有石头就输出石头的重量，如果没有就输出 0。 C++ class Solution { public: int lastStoneWeight(vector& stones) { priority_queue pq(stones.begin(), stones.end()); while (pq.size() > 1) { int y = pq.top(); pq.pop(); int x = pq.top(); pq.pop(); if (x != y) { pq.push(y - x); } } return pq.empty() ? 0 : pq.top(); } }; Javascript /** * @param {number[]} stones * @return {number} */ var lastStoneWeight = function (stones) { let pq = new PriorityQueue(stones); while (pq.size() > 1) { let y = pq.top(); pq.pop(); let x = pq.top(); pq.pop(); if (x !== y) { pq.push(y - x); } } return pq.size() > 0 ? pq.top() : 0; }; // 简单的优先队列类 class PriorityQueue { constructor(arr) { if (Array.isArray(arr) && arr.length > 0) { this.queue = arr.sort((a, b) => b - a); return; } this.queue = []; } top() { return this.queue[0]; } pop() { this.queue.shift(); } push(num) { if (this.queue.length === 0 || num > this.queue[0]) { this.queue.unshift(num); return; } else if (num = num && this.queue[i + 1] "},"easy/1071.html":{"url":"easy/1071.html","title":"1071. Greatest Common Divisor of Strings(easy)","keywords":"","body":"1071. Greatest Common Divisor of Strings Leetcode link 题目简介 /** * @param {string} str1 * @param {string} str2 * @return {string} */ 题目给我们两个字符串 str1 与 str2 要求我们找出能同时除尽两个字符串的最长字符串 除尽指的是该字符串经过自身连接一次或多次可以组成另一个字符串 解题思路 这题要分为两步来求解： 判断是否存在可同时除尽两个字符串的字符串 求出可除尽的最长的字符串是什么 第一个部分，我们可以通过 str1 + str2 === str2 + str1 来判断，如果成立，则表示存在目标字符串 第二个部分，我们需要找到两个字符串长度的最大公因数 GCD，求出来的 GCD 就是目标字符串的长度 Javascript /** * @param {string} str1 * @param {string} str2 * @return {string} */ var gcdOfStrings = function(str1, str2) { if(str1 + str2 !== str2 + str1) { return '' } const gcd = (len1, len2) => { while(len2 !== 0) { ;[len1, len2] = [len2, len1 % len2] } return len1 } return str1.slice(0, gcd(str1.length, str2.length)) }; "},"easy/1207.html":{"url":"easy/1207.html","title":"1207. Unique Number of Occurrences(easy)","keywords":"","body":"1207. Unique Number of Occurrences Leetcode link 题目简介 /** * @param {number[]} arr * @return {boolean} */ 题目给我们一个数字数组 arr 要求我们判断数组中不同数字的出现次数是否唯一 解题思路 我们可以先用一个 map 来记录每个数字的出现次数 然后使用 Set 来对出现次数去重 最后对比 set 与 map 的大小，如果相等则返回 true；否则返回 false Javascript /** * @param {number[]} arr * @return {boolean} */ var uniqueOccurrences = function (arr) { const map = new Map() for (const num of arr) { map.set(num, (map.get(num) || 0) + 1) } const set = new Set(map.values()) return set.size === map.size }; "},"easy/1260.html":{"url":"easy/1260.html","title":"1260. Shift 2D Grid(easy)","keywords":"","body":"1260. Shift 2D Grid Leetcode link 解题思路 本题要求我们移动二维数组，有两种方法可以简单实现： 构建一个新的数组，把旧数组的元素位置根据 k 重新计算之后放到新数组中 把数组摊平之后平移，之后再重新构建成二维数组 C++ // 第一种方法 class Solution { public: vector> shiftGrid(vector>& grid, int k) { int col = grid.size(); int row = grid[0].size(); vector> res(col, vector(row, 0)); for (int i = 0; i Javascript /** * @desc 第二种方法 * @param {number[][]} grid * @param {number} k * @return {number[][]} */ var shiftGrid = function(grid, k) { const row = grid[0].length; // 摊平数组 const arr = grid.flat(); // 减少计算量，且保证 splice 可以正常运作 k = k % arr.length; // 把后 k 个元素移到前面 arr.unshift(...arr.splice(arr.length-k, k)); const res = []; while(arr.length) { // 数组升维 res.push(arr.splice(0,row)); } return res; }; "},"easy/1304.html":{"url":"easy/1304.html","title":"1304. Find N Unique Integers Sum up to Zero(easy)","keywords":"","body":"1304. Find N Unique Integers Sum up to Zero Leetcode link 题目简介 这是一道简单，题目给一个正整数参数 n，并要求我们返回一个长度为 n 的数组，使其所有元素之和为 0，并且元素不能重复 解题思路 将所有数字之和置为 0 最简单的方法就是用绝对值相同的一正一负两个数相加 但是我们需要分成两种情况： n 是奇数：这种情况我们需要插入一个 0 n 是偶数：这种情况我们只需要正常插入指定数量的正负数就好 Javascript /** * @param {number} n * @return {number[]} */ var sumZero = function (n) { let i = 1 const res = [] if (n % 2 !== 0) { res.push(0) n-- } while (n > 0) { res.push(i, -i) i++ n -= 2 } return res }; "},"easy/1317.html":{"url":"easy/1317.html","title":"1317. Convert Integer to the Sum of Two No-Zero Integers(easy)","keywords":"","body":"1317. Convert Integer to the Sum of Two No-Zero Integers Leetcode link 题目简介 这是道简单 题目给我们一个正整数 n，要求我们返回两个正整数组成的数组，这两个正整数之和等于 n，并且数组内的两个整数中都不能有 0 解题思路 直接一个循环判断就好 Javascript /** * @param {number} n * @return {number[]} */ var getNoZeroIntegers = function(n) { const isZeroInside = num => num.toString().includes('0') for(let i=1;i "},"easy/1332.html":{"url":"easy/1332.html","title":"1332. Remove Palindromic Subsequences(easy)","keywords":"","body":"1332. Remove Palindromic Subsequences Leetcode link 解题思路 本题要求我们给出删除一个由 a 与 b 构成的字符串的步骤，其中每一步只能删除一个回文子序列 这道题是简单题，所以题目给出了字符串只有 a 跟 b 的限制 由于字符串只有 a 跟 b，而每次只能删除回文子序列（注意不是子串，这里是可以是不连续的） 而相同的字符组成的子序列一定是回文子序列，所以最多只要删除 2 次就能删除所有的字符串 我们可以根据字符串是否为回文判断：如果是，则只需要删除一次；如果不是，则需要删除两次 C++ class Solution { public: int removePalindromeSub(string s) { int len = s.size(); for(int i = 0;i Javascript var removePalindromeSub = function(s) { let len = s.length; for(let i = 0;i "},"easy/1337.html":{"url":"easy/1337.html","title":"1337. The K Weakest Rows in a Matrix(easy)","keywords":"","body":"1337. The K Weakest Rows in a Matrix Leetcode link 解题思路 本题给了我们一个二维数组，要求我们返回前 k 弱的数组下标，对于 “弱” 题目的定义是： 数组中 “1” 的个数越少越弱 如果 “1” 的个数相同，那么下标越小的越弱 明白了题目之后，我们只需要做两件事就可以了： 计算每个数组的 “1” 的个数，然后将他们依据上述规则排序 按照排序结果，输出头 k 个的下标 C++ class Solution { public: // 排序规则 struct cmp { bool operator()(pair& a, pair& b) { if (a.second == b.second) { return a.first > b.first; } else { return a.second > b.second; } } }; vector kWeakestRows(vector>& mat, int k) { priority_queue, vector>, cmp> pq; for (int i = 0; i result; // 看题目要几个就给他几个 for (int i = 0; i Javascript var kWeakestRows = function(mat, k) { const arr = []; for(let i=0;ia+b)]) } // 先按照规则排序，之后取得前 k 个之后把他们的下标组合为一个数组 return arr.sort((a,b)=>a[1] === b[1] ? a[0] - b[0] : a[1] - b[1] ).slice(0,k).map(row=>row[0]) }; "},"easy/1342.html":{"url":"easy/1342.html","title":"1342. Number of Steps to Reduce a Number to Zero(easy)","keywords":"","body":"1342. Number of Steps to Reduce a Number to Zero Leetcode link 解题思路 题目要求我们计算将一个数减少到 0 的步骤，减少的规则为：如果二进制末位为 0 就除 2；如果为 1 就减 1。 C++ class Solution { public: int numberOfSteps(int num) { int res = 0; while(num !=0) { if(num & 1 == 1) { num -= 1; } else { num >>= 1; } res++; } return res; } }; "},"easy/1380.html":{"url":"easy/1380.html","title":"1380. Lucky Numbers in a Matrix(easy)","keywords":"","body":"1380. Lucky Numbers in a Matrix Leetcode link 题目简介 本题是一道简单题，但是其中还是有比较有趣的点值得思考的 题目给了我们一个二维数组，要求我们找到数组中的 Lucky number（定义为当前行最小且当前列最大） 解题思路1——模拟 第一种解法非常简单粗暴，我们遍历数组两次，第一次找出每一行的最小值，并且将其值记录下来 第二次找出每一列的最大值，如果在记录的最小值中有这个数，把它放进数组 res 保存起来 最后返回数组 res 复杂度分析： 时间复杂度是 $O(n^2)$ 空间复杂度是 $O(n)$ Javascript /** * @param {number[][]} matrix * @return {number[]} */ var luckyNumbers = function(matrix) { const minIndex = []; const res = []; // find minimum number in each row for(let i=0;i 解题思路2——进一步分析 这道题最鸡贼的点在于，它要求我们返回一个数组，且题目跟我们说的是找到 lucky numbers 这两点疯狂暗示我们 lucky number 有多个，但是实际上是如此吗？ 我们来简单分析一下： 首先我们假设有多个 lucky numbers，那么这些 lucky numbers 一定是在斜对角上，举个例子： [[x, A], [B, y]] 我们有一个包含有 4 个元素的二维数组，我们假设其中的 A 跟 B 都是 lucky number，根据题目定义得知： A = y B = x 我们把上述两个条件联立起来，可以得到下面的结论： B >= x >= A A >= y >= B 我们再把这两个式子简化一下可得： B >= A A >= B 至此，可以得到：A === B 由此可知，如果二维数组要存在多个 lucky numbers，多个 lucky numbers 必须相等 题目给出了另外一点要求：Given an m x n matrix of distinct numbers 由此可知，本题的答案是唯一的 废了这么大劲得到了这个结论，可以做什么呢？ 我们可以借由这个结论去减少空间复杂度 具体思路：既然只有一个答案，我们可以在遍历找到当前行的最小值的当下，遍历一下最小值的列，如果这个行最小值同时是列最大值，直接返回就好，如果不是继续遍历，知道最后如果都没有找到这个值，返回空数组 [] Javascript /** * @param {number[][]} matrix * @return {number[]} */ var luckyNumbers = function(matrix) { for(let i = 0;i row[colIndex] "},"easy/1431.html":{"url":"easy/1431.html","title":"1431. Kids With the Greatest Number of Candies(easy)","keywords":"","body":"1431. Kids With the Greatest Number of Candies Leetcode link 题目简介 /** * @param {number[]} candies * @param {number} extraCandies * @return {boolean[]} */ 题目给我们一个数字数组 candies 代表每个小孩当前拥有的糖果数量；一个数字 extraCandies 代表待分配的糖果数量 待分配的糖果只能给一个小孩 题目要求我们返回一个布尔值数组，为 true 表示如果把糖果给当前小孩他能够拥有最多的糖果；为 false 则表示不能 解题思路 分两步： 计算当前 candies 的最大值 max 遍历 candies 判断 candies[i] + extraCandies >= max 是否成立，成立则为 true，否则为 false Javascript /** * @param {number[]} candies * @param {number} extraCandies * @return {boolean[]} */ var kidsWithCandies = function (candies, extraCandies) { const max = Math.max(...candies) const res = [] for (const candy of candies) { res.push(candy + extraCandies >= max) } return res }; "},"easy/1437.html":{"url":"easy/1437.html","title":"1437. Check If All 1's Are at Least Length K Places Away(easy)","keywords":"","body":"1437. Check If All 1's Are at Least Length K Places Away Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {boolean} */ 题目给我们一个数组 nums 以及一个数字 k 要求我们遍历数组求出数组是否所有的 1 中间都间隔至少 k 个 0，如果是返回 true，否则返回 false 解题思路 用一个变量记录上一次 1 出现的下标，之后每次出现 1 时只需要判断两个下标的距离就好 Javascript /** * @param {number[]} nums * @param {number} k * @return {boolean} */ var kLengthApart = function (nums, k) { let lastIdxOf1 = -1 let cur = 0 while (cur = 0 && cur - lastIdxOf1 - 1 "},"easy/1475.html":{"url":"easy/1475.html","title":"1475. Final Prices With a Special Discount in a Shop(easy)","keywords":"","body":"1475. Final Prices With a Special Discount in a Shop Leetcode link 解题思路 这是一道简单题 我们只需要简单用两层遍历，在内层遍历找到第一个比外层遍历元素小的价格并将其相减就行，详见代码 Javascript /** * @param {number[]} prices * @return {number[]} */ var finalPrices = function (prices) { const res = [...prices] for (let i = 0; i "},"easy/1518.html":{"url":"easy/1518.html","title":"1518. Water Bottles(easy)","keywords":"","body":"1518. Water Bottles Leetcode link 题目简介 题目给我们两个参数： numBottles：代表初始状态下有几瓶装满水的瓶子 numExchange：代表几个空瓶子可以换一个装满水的瓶子 题目要求我们在给定的参数下，求得我们最后最多能喝几瓶水 解题思路 题目要求我们能喝几瓶水，所以我们只需要关注我们一开始有几瓶水 + 我们能换几瓶水就好 在每一轮喝完水之后，我们最多能换：拥有空瓶子的数量 / numExchange 取整数部份的瓶子 其中拥有空瓶子的数量 = 上一轮 numBottles / numExchange 取整数部份 + 上一轮 numBottles % numExchange 我们就这样一轮一轮的喝下去，直到拥有空瓶子的数量 numExchange 为止 Javascript /** * @param {number} numBottles * @param {number} numExchange * @return {number} */ var numWaterBottles = function (numBottles, numExchange) { let res = numBottles while (numBottles >= numExchange) { const remains = numBottles % numExchange const newBottle = Math.floor(numBottles / numExchange) res += newBottle numBottles = newBottle + remains } return res }; "},"easy/1598.html":{"url":"easy/1598.html","title":"1598. Crawler Log Folder(easy)","keywords":"","body":"1598. Crawler Log Folder Leetcode link 题目简介 题目给了一连串的文件操作，最后要求我们从 main 文件出发，经过题目的文件操作后，从最后的文件返回到 main 文件需要几步 文件操作有三种类型： ./：呆在原地 ../：返回上级文件 x/：进入特定下级文件 解题思路 这是一个简单题，我们只要顺着他们给的三种方式分别判断就好 我们使用 result 来记录当前文件距离 main 有多远，然后我们分别处理三种情况： ./：什么都不做 ../：距离减一（注意最小为 0，不能为负） x/：距离加一 Javascript /** * @param {string[]} logs * @return {number} */ var minOperations = function(logs) { let result = 0; logs.forEach(item => { if(item === \"../\") { result = --result "},"easy/1636.html":{"url":"easy/1636.html","title":"1636. Sort Array by Increasing Frequency(easy)","keywords":"","body":"1636. Sort Array by Increasing Frequency Leetcode link 题目简介 本题要求我们对数组排序，但是排序的规则有两个： 数组中出现次数少的数要排在出现次数多的数后面 如果两数出现次数相同，则按照降序排序 解题思路 为了记录每个数字的出现次数，我们需要建立一个数字与出现次数的映射 在 js 中，我们选用 Map 这个数据结构 统计完了出现次数之后，我们只需要按照题目的要求自定义排序方法就好，详见代码 Javascript /** * @param {number[]} nums * @return {number[]} */ var frequencySort = function(nums) { const map = new Map(); // 建立映射 for(const num of nums) { if(map.has(num)) { map.set(num, map.get(num) + 1) } else { map.set(num, 1) } } // 自定义排序规则：先按照出现次数升序；如果出现次数相同则降序排列 return nums.sort((a, b) => map.get(a) - map.get(b) || b-a) }; "},"easy/1710.html":{"url":"easy/1710.html","title":"1710. Maximum Units on a Truck(easy)","keywords":"","body":"1710. Maximum Units on a Truck Leetcode link 解题思路 本题要求我们放入最大单元的箱子进去卡车 这一题完全可以用贪心的思路去做，主要思路就是先放大的再放小的： 首先先针对箱子的大小排序，箱子大的放前面 再来遍历排序好的数组，一次放入卡车中直到再也放不下为止 Javascript /** * @param {number[][]} boxTypes * @param {number} truckSize * @return {number} */ var maximumUnits = function(boxTypes, truckSize) { boxTypes.sort((a, b) => b[1] - a[1]); let res = 0; for(let i=0;i 0;i++) { let num = Math.min(truckSize, boxTypes[i][0]); truckSize -= num; res += boxTypes[i][1] * num; } return res; }; "},"easy/1716.html":{"url":"easy/1716.html","title":"1716. Calculate Money in Leetcode Bank(easy)","keywords":"","body":"1716. Calculate Money in Leetcode Bank Leetcode link 题目简介 /** * @param {number} n * @return {number} */ 题目给我们一个参数 n，代表存了多少天的钱 题目要求我门根据 n 求出当前银行存款有多少了 存钱的规则如下： 在每个星期中，下一天的存款金额比上一天+1 如果当前是第 n 周，则当周星期一的存款金额是 n 块钱 第一个星期星期一存入 1 块钱 解题思路 这题比较简单，我们只需要判断当前的 n 是在第几周的第几天就可以了 根据题目描述，每一周都会比上一周多存 5 块钱 而每一天会比前一天多存 1 块钱 计算出结果即可 Javascript /** * @param {number} n * @return {number} */ var totalMoney = function (n) { let res = 0 const FIRST_WEEK_SAVING = (1 + 7) * 7 / 2 const weeks = Math.floor(n / 7) const restDays = n % 7 for (let i = 0; i "},"easy/1732.html":{"url":"easy/1732.html","title":"1732. Find the Highest Altitude(easy)","keywords":"","body":"1732. Find the Highest Altitude Leetcode link 题目简介 /** * @param {number[]} gain * @return {number} */ 题目给我们一个数字数组 gain 表示高度的变化（高度从 0 开始） 要求我们计算出高度最高的点有多高 返回最高的高度 解题思路 我们只需要用变量 altitude 来记录当前高度、res 来记录最高的高度 然后遍历 gain 数组即可，遍历时每次用 altitude+gain[i]，然后更新 res 即可 最后返回 res Javascript /** * @param {number[]} gain * @return {number} */ var largestAltitude = function(gain) { let res = 0 let altitude = 0 for(const g of gain) { altitude += g res = Math.max(res, altitude) } return res }; "},"easy/1768.html":{"url":"easy/1768.html","title":"1768. Merge Strings Alternately(easy)","keywords":"","body":"1768. Merge Strings Alternately Leetcode link 题目简介 /** * @param {string} word1 * @param {string} word2 * @return {string} */ 题目给我们两个字符串，要求我们返回一个新的字符串，字符串的字符由两个旧字符串字符交替排列（word1 先） 解题思路 使用两个指针分别指向两个旧字符串，然后依序取字符放入新字符串即可 Javascript /** * @param {string} word1 * @param {string} word2 * @return {string} */ var mergeAlternately = function (word1, word2) { let res = '' let idx1 = 0 let idx2 = 0 const len1 = word1.length const len2 = word2.length while (idx1 "},"easy/1935.html":{"url":"easy/1935.html","title":"1935. Maximum Number of Words You Can Type(easy)","keywords":"","body":"1935. Maximum Number of Words You Can Type Leetcode link 题目简介 这是一道简单，题目给了我们一个 text 参数代表一个句子一个句子由空格与多个单词组成；一个 brokenLetters 代表打字机损坏的字母 题目要求我们求出这个打字机能够打出 text 这个句子中的几个单词 解题思路 要解题的话，我们只需要用到两个循环，在每一个单词中间寻找是否有损坏的单词就可以 Javascript /** * @param {string} text * @param {string} brokenLetters * @return {number} */ var canBeTypedWords = function (text, brokenLetters) { const words = text.split(' ') const letters = brokenLetters.split('') let res = 0 for (const word of words) { let hasBrokenLetter = false for (const letter of letters) { if (word.indexOf(letter) > -1) { hasBrokenLetter = true break; } } if (!hasBrokenLetter) { res++ } } return res }; "},"easy/2011.html":{"url":"easy/2011.html","title":"2011. Final Value of Variable After Performing Operations(easy)","keywords":"","body":"2011. Final Value of Variable After Performing Operations Leetcode link 题目简介 /** * @param {string[]} operations * @return {number} */ 本题参数 operations 包含四种操作：\"++X\", \"X++\", \"--X\", \"X--\" X 的初始值为 0，要求我们求出在经过所有 operations 之后 X 的值 解题思路 直接一个循环解了 Javascript /** * @param {string[]} operations * @return {number} */ var finalValueAfterOperations = function(operations) { let res = 0 for(const op of operations) { if(op[1] === '+') { res++ } else { res-- } } return res }; "},"easy/2154.html":{"url":"easy/2154.html","title":"2154. Keep Multiplying Found Values by Two(easy)","keywords":"","body":"2154. Keep Multiplying Found Values by Two Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} original * @return {number} */ 题目给我们一个数字数组 nums 以及一个数字 original 我们需要在 nums 中出现 original 的时候将 original *= 2 直到数组中不再出现 original 题目要求我们返回此时的 original 解题思路 我们可以用一个 set 来保存 nums 的所有数字，这样一来每次查询的复杂度是 O(1) Javascript /** * @param {number[]} nums * @param {number} original * @return {number} */ var findFinalValue = function (nums, original) { const set = new Set(nums) while (set.has(original)) { original *= 2 } return original }; "},"easy/2169.html":{"url":"easy/2169.html","title":"2169. Count Operations to Obtain Zero(easy)","keywords":"","body":"2169. Count Operations to Obtain Zero Leetcode link 题目简介 /** * @param {number} num1 * @param {number} num2 * @return {number} */ 题目给我们两个数字 num1，num2 要求我们进行操作： 如果 num1 > num2，则 num1 -= num2；反之亦然 题目要求我们求最少需要多少次操作才能使得其中一个数字为 0 解题思路 这种需要连续做减法的题目我们可以用除法来进行简化 Javascript /** * @param {number} num1 * @param {number} num2 * @return {number} */ var countOperations = function(num1, num2) { let res = 0 while(num1 && num2) { res += Math.floor(num1 / num2) // use semicolon to prevent js ASI bug for next sentence num1 %= num2; [num1, num2] = [num2, num1] } return res }; "},"easy/2215.html":{"url":"easy/2215.html","title":"2215. Find the Difference of Two Arrays(easy)","keywords":"","body":"2215. Find the Difference of Two Arrays Leetcode link 题目简介 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[][]} */ 题目给我们两个数字数组 nums1 与 nums2 要求我们返回长度为 2 的数组 answer，其中： answer[0] 中存放在 nums1 出现但是没在 nums2 中出现的数字（不重复） answer[1] 中存放在 nums2 出现但是没在 nums1 中出现的数字（不重复） 解题思路 为了不重复，我们选择使用 set 来保存两个数组 nums1 与 nums2 然后我们用数组的 filter 过滤要求的元素即可 Javascript /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[][]} */ var findDifference = function(nums1, nums2) { const set1 = new Set(nums1) const set2 = new Set(nums2) const ans1 = [...set1].filter(num => !set2.has(num)) const ans2 = [...set2].filter(num => !set1.has(num)) return [ans1, ans2] }; "},"easy/2273.html":{"url":"easy/2273.html","title":"2273. Find Resultant Array After Removing Anagrams(easy)","keywords":"","body":"2273. Find Resultant Array After Removing Anagrams Leetcode link 题目简介 题目给我们一个参数 words，代表一个由字符串组成的数组 题目要求我们进行筛选：如果相邻的字符串的字符是回文（由相同字母不同顺序）组成的话，则只保留下标小的那个字符 解题思路 检测回文我们可以用数组的 sort 来进行检测，剩下的只需要模拟题意从下标 1 开始遍历即可 Javascript /** * @param {string[]} words * @return {string[]} */ var removeAnagrams = function (words) { const ans = [words[0]] let lastSortedWord = words[0].split('').sort().join('') for (let i = 1; i "},"easy/2418.html":{"url":"easy/2418.html","title":"2418. Sort the People(easy)","keywords":"","body":"2418. Sort the People Leetcode link 题目简介 题目给了我们两个数组 names, heights 要求我们把人物的名字根据身高排序 解题思路 这是一个简单题，关键的卡点在于我们要怎么在排序的时候维持两个数组元素的一致性 在 js 中，我们可以简单的用一个 map 来保存两者的映射关系，这样只要我们把 heights 排序好之后根据映射关系以此找回 names 就好 Javascript /** * @param {string[]} names * @param {number[]} heights * @return {string[]} */ var sortPeople = function(names, heights) { const map = {}; // 建立映射关系 names.forEach((item, index) => { map[heights[index]] = item; }) // 排序 heights.sort((a, b) => b-a); // 根据映射关系取回名字 heights.forEach((item, index) => { names[index] = map[item]; }) return names; }; "},"easy/3005.html":{"url":"easy/3005.html","title":"3005. Count Elements With Maximum Frequency(easy)","keywords":"","body":"3005. Count Elements With Maximum Frequency Leetcode link 题目简介 这是道简单，题目给我们一个数组 nums 要求我们返回数组中出现频率最高的所有数字的个数 解题思路 这题的限制 1 让我们可以使用一个长度为 101 的数组 frequency 来保存所有可能出现数字的频率 然后我们遍历这个 frequency 找出出现频率最高的所有数字，将其出现的频率与个数相乘就是答案了 Javascript /** * @param {number[]} nums * @return {number} */ var maxFrequencyElements = function(nums) { const frequency = new Array(101).fill(0) nums.forEach(num => { frequency[num]++ }) // highest frequency let max = -1 let count = 0 frequency.forEach(f => { if(f > max) { max = f count = 1 } else if(f === max) { count++ } }) return count * max }; "},"easy/3190.html":{"url":"easy/3190.html","title":"3190. Find Minimum Operations to Make All Elements Divisible by Three(easy)","keywords":"","body":"3190. Find Minimum Operations to Make All Elements Divisible by Three Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums，要求我们对数组元素进行 操作 使得数组每个元素都能被 3 整除 操作：对任意一个数组元素加一或者减一 题目要求我们返回最少的操作次数 解题思路 任何整数除以 3 的余数只可能是 0，1，2 其中余数为 0 代表能被三整除 余数为 1 或 2 都只需要一次操作即可满足需求 所以我们只需要遍历数组求数组元素与 3 的余数，如果不为 0 则把操作步骤加一即可 Javascript /** * @param {number[]} nums * @return {number} */ var minimumOperations = function (nums) { const TARGET = 3 let res = 0 for (const num of nums) { if (num % TARGET !== 0) { res++ } } return res }; "},"easy/3289.html":{"url":"easy/3289.html","title":"3289. The Two Sneaky Numbers of Digitville(easy)","keywords":"","body":"3289. The Two Sneaky Numbers of Digitville Leetcode link 题目简介 /** * @param {number[]} nums * @return {number[]} */ 题目给我们一个数组 nums，并且知道其中有两个重复元素，要求我们返回两个重复元素组成的数组 解题思路 用一个 set 保存遍历过的元素，如果后续遍历中遇到了已经存在 set 的元素则将其放入需返回的数组中 Javascript /** * @param {number[]} nums * @return {number[]} */ var getSneakyNumbers = function(nums) { const set = new Set() const res = [] nums.forEach(num => { if(set.has(num)) { res.push(num) } else { set.add(num) } }) return res }; "},"easy/3318.html":{"url":"easy/3318.html","title":"3318. Find X-Sum of All K-Long Subarrays I(easy)","keywords":"","body":"3318. Find X-Sum of All K-Long Subarrays I Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @param {number} x * @return {number[]} */ 这是一道上限极高的简单题，题目给我们一个数字数组 nums，要求我们求出对该数组一系列操作之后的结果 一系列操作说明如下： 将该数组划分为多个下标范围为 [i, ..., i+k] 的子数组 计算该子数组每个元素出现的频率 将出现个数排序，取最高的 x 个元素求和（如果有相同出现频率的元素则取元素值大的） 将求和结果放入一个结果数组中，最后遍历完所有子数组后返回该结果数组 这题有一个极为关键的约束条件：1 这使得我们可以尝试一些暴力的解法 解题思路 简单题简单做，直接暴力梭哈，困难的优化方案留到后面 3321 题再做～ 这题的关键无非就两个： 如何管理好窗口 如何计算窗口内题目所求的结果 由于我们需要的是一个固定的窗口大小，而且重点在于计算窗口内元素的出现次数 所以我们可以简单的用一次遍历来做这件事情，然后用一个对象 map 来计算在窗口内各个元素的出现频率 具体来说，遍历过程有三种情况需要处理： 遍历一个新元素时：map[nums[i]]++ 将该元素出现频率加一 如果当前指针 i >= k：map[nums[i-k]]-- 我们需要把脱离我们当前窗口范围的元素频率减回来 如果当前指针 i >= k-1：此时需要根据窗口内元素计算出题目所需的结果（排序、加总） Javascript /** * @param {number[]} nums * @param {number} k * @param {number} x * @return {number[]} */ var findXSum = function (nums, k, x) { // {value: occurrence} const map = {} const res = [] for (let i = 0; i = k) { // remove the previous data since it is no longer in the subArr map[nums[i - k]]-- } if (i >= k - 1) { // [[value, occurrence]] const dataArr = Object.entries(map).sort((a, b) => { if (a[1] === b[1]) { return b[0] - a[0] } return b[1] - a[1] }) let sum = 0 for (j = 0; j "},"easy/3349.html":{"url":"easy/3349.html","title":"3349. Adjacent Increasing Subarrays Detection I(easy)","keywords":"","body":"3349. Adjacent Increasing Subarrays Detection I Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {boolean} */ 本题给我们一个数组 nums 以及一个数字 k，要求我们在 nums 中找出两个长度为 k 的递增数组（不能有相同数字的递增） 如果能找到就返回 true，否则返回 false 解题思路 既然题目要求是找出两个，那么我们可以用两个变量 prevSubStrLen，curSubStrLen 来分别代表上一个递增数组的长度，以及当前递增数组的长度 如果当前递增数组的长度到达 k，并且上一个递增数组的长度大于等于 k，我们就可以认为找到了符合条件的两个递增数组 计算子数组的长度我们可以从下标 1 遍历数组 nums，如果当前下标元素比上一个下标元素大，我们就把 curSubStrLen++ 反之，如果比上一个下标元素小或者相等，则 prevSubStrLen = curSubStrLen，然后 curSubStrLen = 1 此外还需要注意一种情况就是单调递增子数组的长度大于 k*2，这种情况子数组本身可以被拆成两个长度为 k 的子数组，所以也是符合要求的 Javascript /** * @param {number[]} nums * @param {number} k * @return {boolean} */ var hasIncreasingSubarrays = function (nums, k) { if(k === 1) { return true } let prevSubStrLen = 1 let curSubStrLen = 1 for (let i = 1; i nums[i - 1]) { curSubStrLen++ } else { prevSubStrLen = curSubStrLen curSubStrLen = 1 } if(curSubStrLen === k && prevSubStrLen >= k || curSubStrLen >= k*2) { return true } } return false }; "},"easy/3354.html":{"url":"easy/3354.html","title":"3354. Make Array Elements Equal to Zero(easy)","keywords":"","body":"3354. Make Array Elements Equal to Zero Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums，并且要求我们做一系列的操作： 我们在 nums 中选择一个值为 0 的元素下标，然后选择一个方向（右移下标或者左移下标） 如果该下标移动超出数组边界，则该操作结束 如果移动过程中遇到 nums[i] === 0，则继续同方向移动 如果移动过程遇到 nums[i] > 0，则将该元素减一并反方向移动 我们最后的目标是找到合适的 [下标, 方向] 组合使得整个 nums 元素在操作后均为 0 题目要求我们判断当前 nums 数组中有多少个合适的 [下标, 方向] 组合 解题思路 根据题目我们不难看出想要使数组为 0 的关键在于我们选中的下标左右两边元素和的关系 有两种可能： 选中下标左右的元素之和相等：有两个可能的组合（因为此时一开始往左或者往右都可以） 选中下标左右元素之和差一：只有一个可能的组合（因为此时一开始只能往比较大的那边走） Javascript /** * @param {number[]} nums * @return {number} */ var countValidSelections = function (nums) { let res = 0 const sum = nums.reduce((acc, cur) => acc + cur, 0) let left = 0 let right = sum for (let i = 0; i "},"easy/3370.html":{"url":"easy/3370.html","title":"3370. Smallest Number With All Set Bits(easy)","keywords":"","body":"3370. Smallest Number With All Set Bits Leetcode link 题目简介 /** * @param {number} n * @return {number} */ 题目给我们一个数字 n，要求我们求出一个大于等于 n 的数，使其所有置位都是 1（也就是该数字二进制的表示都是 1） 解题思路 由于题目要我们求大于等于 n 且二进制表示全为 1 的数 那我们只需要先知道 n 的二进制表示的长度，然后把 1 左移该长度之后减一即可 Javascript /** * @param {number} n * @return {number} */ var smallestNumber = function(n) { return (1 "},"easy/3461.html":{"url":"easy/3461.html","title":"3461. Check If Digits Are Equal in String After Operations I(easy)","keywords":"","body":"3461. Check If Digits Are Equal in String After Operations I Leetcode link 题目简介 /** * @param {string} s * @return {boolean} */ 题目给了一个字符串 s，要求我们对字符串进行一系列操作，直到字符串剩下两个字符，最后返回这两个字符是否相等 一系列操作： 遍历字符串，取出下标为 i 与 i+1 的字符 将两者以数字形式相加之后 mod 10 将结果放到下标 i 的位置 遍历结束后丢弃 s.length - 1 下标的字符 解题思路 按照题目意思模拟即可 Javascript /** * @param {string} s * @return {boolean} */ var hasSameDigits = function (s) { let str = s let nextStr while (str.length > 2) { nextStr = '' for (let i = 1; i "},"easy/3512.html":{"url":"easy/3512.html","title":"3512. Minimum Operations to Make Array Sum Divisible by K(easy)","keywords":"","body":"3512. Minimum Operations to Make Array Sum Divisible by K Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {number} */ 题目给我们一个数组 nums 以及一个整数 k 要求我们经过操作后，使得 nums 数组所有数字之和能够被 k 整除 操作： 任意选取数组中的一个数字 nums[i] 使得 nums[i] - 1 题目要求我们返回最少需要的操作数 解题思路 简单理解：题目需要求 nums 数字之和对 k 的余数 Javascript /** * @param {number[]} nums * @param {number} k * @return {number} */ var minOperations = function(nums, k) { const sum = nums.reduce((acc, cur) => cur + acc, 0) const remainder = sum % k return remainder }; "},"easy/3516.html":{"url":"easy/3516.html","title":"3516. Find Closest Person(easy)","keywords":"","body":"3516. Find Closest Person Leetcode link 题目简介 本题是一道简单题，题目给了我们三个参数，分别代表三个人所在的位置，题目要求计算在前两个人匀速前进的情况下，谁能先到第三个人的位置 解题思路 匀速情况下，到达的时间只跟距离有关，所以我们分别计算两人与第三个人的距离，距离最短的就是最先到达的 Javascript /** * @param {number} x * @param {number} y * @param {number} z * @return {number} */ var findClosest = function (x, y, z) { const distanceXZ = Math.abs(x - z) const distanceYZ = Math.abs(y - z) if (distanceXZ === distanceYZ) { return 0 } else if (distanceXZ > distanceYZ) { return 2 } else { return 1 } }; "},"easy/3541.html":{"url":"easy/3541.html","title":"3541. Find Most Frequent Vowel and Consonant(easy)","keywords":"","body":"3541. Find Most Frequent Vowel and Consonant Leetcode link 题目简介 题目要求我们分别计算一个字符串 s 中母音字符与辅音字符出现最多的次数，并返回两者的次数之和 解题思路 我们用一个数组来保存 26 个字母，然后遍历一次 s 统计所有字母出现频率，最后再分别计算母音与字音出现频率最高的次数之和返回就好 Javascript /** * @param {string} s * @return {number} */ var maxFreqSum = function(s) { const countArr = new Array(26).fill(0) const charCodeOfA = 'a'.charCodeAt() const vowels = ['a', 'e', 'i', 'o', 'u'] let frequencyOfVowels = 0 let frequencyOfConsonant = 0 for(const c of s) { countArr[c.charCodeAt() - charCodeOfA]++ } vowels.forEach(v => { const idx = v.charCodeAt() - charCodeOfA frequencyOfVowels = Math.max(frequencyOfVowels, countArr[idx]) countArr[idx] = 0 }) frequencyOfConsonant = Math.max(...countArr) return frequencyOfVowels + frequencyOfConsonant }; "},"medium/":{"url":"medium/","title":"Medium","keywords":"","body":"Meduim "},"medium/2.html":{"url":"medium/2.html","title":"2. Add Two Numbers","keywords":"","body":"2.Add Two Numbers Leetcode link 解题思路 题目告诉我们每一个节点范围在 0 到 9 之间，并且贴心的帮我们倒序了（个位数在链表头，依次是十位，百位，千位。。。），那我们只需要另外创建一个链表，通过一次遍历加总之后返回链表头就可以了。这其中需要注意的就是加法会有进位，所以可以用一个 int 来存储进位值。 C++ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* result = new ListNode(0); ListNode* cur = result; int carry = 0; while (l1 || l2 || carry) { int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry; carry = sum / 10; cur->next = new ListNode(sum % 10); cur = cur->next; l1 = l1 ? l1->next : l1; l2 = l2 ? l2->next : l2; } return result->next; } }; Javascript var addTwoNumbers = function (l1, l2) { const result = new ListNode(0); let cur = result; let carry = 0; while (l1 || l2 || carry) { let sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry; carry = Math.floor(sum / 10); cur.next = new ListNode(sum % 10); cur = cur.next; l1 = l1 ? l1.next : l1; l2 = l2 ? l2.next : l2; } return result.next; }; "},"medium/3.html":{"url":"medium/3.html","title":"3. Longest Substring Without Repeating Characters(medium)","keywords":"","body":"3. Longest Substring Without Repeating Characters Leetcode link 解题思路 本题要求我们找到一个字符串的最长不重复子串的长度 因为子串的连续性，我们可以考虑滑动窗口的方式 具体而言，我们创建两个指针 left 和 right，分别作为窗口的两个边界 一开始，left 指向第一个元素，right 负责向右遍历，直到遇到了与窗口中重复的字符 记录下当前长度之后，我们就可以把 left 往右一个元素，然后继续遍历 right 了 最后，当 left 移到最后一个元素之后，我们比较一下记录下来的长度，取出最大值就好 查找字符是否重复我们可以用哈希集合的数据结构 C++ class Solution { public: int lengthOfLongestSubstring(string s) { int len = s.size(); int right = -1; int res = 0; unordered_set occ; for(int left = 0;left Javascript /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { const set = new Set() let left = 0 let right = 0 let res = 0 while(right "},"medium/5.html":{"url":"medium/5.html","title":"5. Longest Palindromic Substring(medium)","keywords":"","body":"5. Longest Palindromic Substring Leetcode link 解题思路 本题要求我们找出一个字符串的最长回文子串 一个简单的思路就是遍历字符串，把每一个字符当成回文的中心，求出对应的回文子串的起始下标与结束下标 最后选取最长的一段回文子串返回 C++ class Solution { public: string longestPalindrome(string s) { int start = 0, end = 0; for(int i = 0;i end - start) { end = oddRight; start = oddLeft; } if(evenRight - evenLeft > end - start) { end = evenRight; start = evenLeft; } } return s.substr(start, end - start + 1); } pair expandAroundCenter(string& s, int left, int right) { while(left >=0 && right Javascript /** * @param {string} s * @return {string} */ var longestPalindrome = function(s) { let start = 0, end = 0; for(let i = 0;i end - start) { start = oddLeft; end = oddRight; } if(evenRight - evenLeft > end - start) { start = evenLeft; end = evenRight; } } return s.slice(start, end+1); }; // 计算由回文中心出发的最长回文子串起始与结束下标 var expandAroundCenter = function(s, left, right) { while(left >= 0 && right "},"medium/6.html":{"url":"medium/6.html","title":"6. Zigzag Conversion(medium)","keywords":"","body":"6. Zigzag Conversion Leetcode link 题目简介 题目给我们两个参数： s：代表一个字符串 numRows：代表所需行数 题目要求我们使用字符串 s 画一个有 numRows 行的 Z 字形（镜像之后旋转 90 度） 1 7 2 6 8 3 5 9 4 10 （大概长这样） 最后在按照从左到右，从上到下返回，也就是：17268359410 解题思路 这题的难点在于如何构建后将字符按照题目要求顺序提取出来 一开始我想的是用一个二维数组来保存，后来发现用一维字符串数组就可以搞定了 具体来说，上面这个数字的例子可以被压缩成： 1 7 2 6 8 3 5 9 4 10 这样一来，我们就可以把题目简化成： 首先由上到下把字符塞进不同行的字符串里 一旦碰到了行的底部，由下往上把字符塞进不同行的字符串里 循环 1、2 直到字符串被遍历完成 把数组所有的字符串按顺序拼起来就好 Javascript /** * @param {string} s * @param {number} numRows * @return {string} */ var convert = function(s, numRows) { if(numRows === 1) return s const rows = new Array(Math.min(s.length, numRows)).fill('') let direction = 1 let curRow =0 for(const char of s) { rows[curRow] += char curRow += direction if(curRow === 0 || curRow === numRows-1) { direction = -direction } } return rows.join('') }; "},"medium/7.html":{"url":"medium/7.html","title":"7. Reverse Integer(medium)","keywords":"","body":"7. Reverse Integer Leetcode link 题目简介 本题给我们一个参数 x，代表一个 32 位的整数，题目要求我们把整数反转 如果反转后的整数超过了 32 位的限制，则返回 0 Javascript /** * @param {number} x * @return {number} */ var reverse = function (x) { const sign = x >= 0 ? 1 : -1 let posX = Math.abs(x) let res = 0 const LIMIT = 2 ** 31 - 1 while (posX !== 0) { const digit = posX % 10 posX = Math.floor(posX / 10) // check the overflow before adding the digit if (res > LIMIT / 10) { return 0 } res = digit + res * 10 } return res * sign }; "},"medium/8.html":{"url":"medium/8.html","title":"8. String to Integer (atoi)(medium)","keywords":"","body":"8. String to Integer (atoi) Leetcode link 题目简介 本题给了一个参数 s，要求我们将字符串 s 转成 32 位的整数 此外，题目要求： 忽略最前面的空白字符 需要考虑正负符号 -, + 忽略数字前面的 0，并且如果转换过程中遇到了数字以外的字符就要停止，返回当前转换的数字 如果转换的数字超过了 32 位，只需返回 32 位的最大值/最小值 Javascript /** * @param {string} s * @return {number} */ var myAtoi = function (s) { const ZERO = '0'.charCodeAt(0) const POS_LIMIT = 2 ** 31 - 1 const NEG_LIMIT = -(2 ** 31) const len = s.length let res = 0 let i = 0 let sign = 1 // skip the leading space while (i = '0' && s[i] POS_LIMIT) { return POS_LIMIT } if (sign * res "},"medium/11.html":{"url":"medium/11.html","title":"11. Container With Most Water(medium)","keywords":"","body":"11. Container With Most Water Leetcode link 解题思路 本题要求我们选中任意两个高度当成容器求水的最大体积。由题目可知，水的体积 S 的公式如下： S = (right - left) * min(height[left], height[right])，其中 left 与 right 分别是选中的两个高度的下标。 如果把所有的情况遍历一次，总共需要 n * (n - 1) / 2 次，肯定不符合预期，所以我们必须想办法减少复杂度。 考虑到如下两种情况： height[left] ：我们接下来只需要检查 (left + 1, right) 这个区间就好 height[right] ：我们接下来只需要检查 (left, right - 1) 这个区间就好 证明：假设 height[left] ，我们来证明 (left, right - X) 区间已经没有任何能增加水体积的可能了。 当X = 1 时，在区间 (left, right - 1) 我们有水体积 S' = (right - 1 - left) * min(height[left], height[right - 1])。 从 S' 可以推导出 S' ，可想而知，就算 X 再大，只会让水体积更小 在上述结论的情况下，我们再进一步思考，在 height[left] 的时候，如果 height[left + 1] 还是小于 height[left] 那就可以直接略过这个直接检查 left + 2、 left + 3…… 直到找到第一个 height[left + X] > height[left] 之后再计算水体积进行比较。 C++ class Solution { public: int maxArea(vector& height) { int result = 0, left = 0, right = height.size() - 1; while (left Javascript var maxArea = function(height) { let result = 0, left = 0, right = height.length - 1; while (left "},"medium/12.html":{"url":"medium/12.html","title":"12. Integer to Roman(medium)","keywords":"","body":"12. Integer to Roman Leetcode link 题目简介 本题给我们一个参数 num，表示一个 0～3999 的数字 题目要求我们将 num 转换成罗马数字 解题思路 我们只要从大到小遍历罗马数字的值然后将对应的符号放入我们的答案中就可以了 Javascript /** * @param {number} num * @return {string} */ var intToRoman = function (num) { let res = '' while (num > 0) { switch (true) { case num >= 1000: res += 'M' num -= 1000 break; case num >= 900: res += 'CM' num -= 900 break; case num >= 500: res += 'D' num -= 500 break; case num >= 400: res += 'CD' num -= 400 break; case num >= 100: res += 'C' num -= 100 break; case num >= 90: res += 'XC' num -= 90 break; case num >= 50: res += 'L' num -= 50 break; case num >= 40: res += 'XL' num -= 40 break; case num >= 10: res += 'X' num -= 10 break; case num === 9: res += 'IX' num -= 9 break; case num >= 5: res += 'V' num -= 5 break; case num === 4: res += 'IV' num -= 4 break; case num >= 1: res += 'I' num -= 1 break; } } return res }; 或者： /** * @param {number} num * @return {string} */ var intToRoman = function(num) { const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; const symbols = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']; let res = '' for(let i=0;i= values[i]) { res += symbols[i] num -= values[i] } } return res }; "},"medium/15.html":{"url":"medium/15.html","title":"15. 3Sum(medium)","keywords":"","body":"15. 3Sum Leetcode link 题目简介 /** * @param {number[]} nums * @return {number[][]} */ 题目给我们一个数字数组 nums，要求在数组中找出三个数字之和为 0 的所有不重复的三元组 解题思路 这一题是 two sum 的加强版 我们只需要先锁定一个元素（假设是 nums[0]）后，其他的部份也可以用 two sum 的双指针来处理 这题还有一个难点就是要去除重复的三元组，这个需要三个步骤来处理： 首先我们需要对数组 nums 升序排序 对于 i>0，如果出现 nums[i] === nums[i-1]，则直接跳过当前的 i（i 是第一个元素的遍历下标） 当找到三元组 nums[i] + nums[left] + nums[right] === 0 时，我们需要更新 left 以及 right 两个指针，此时如果 nums[left] === nums[left - 1] 或者 nums[right] === nums[right + 1] 时，也需要跳过当前的 left 与 right Javascript /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function (nums) { const res = [] const len = nums.length nums.sort((a, b) => a - b) for (let i = 0; i 0) { break; } // prevent duplicate answers if (i > 0 && nums[i] === nums[i - 1]) { continue } const rest = -nums[i] let left = i + 1 let right = len - 1 while (left rest) { right-- } else if (twoSum left) { right-- } } } } return res }; "},"medium/16.html":{"url":"medium/16.html","title":"16. 3Sum Closest(medium)","keywords":"","body":"16. 3Sum Closest Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} target * @return {number} */ 本题是 3 sum 的变体，要求我们从 nums 中找出三个数字之和与 target 差距最小，并最后返回三数之和 解题思路 这题我们还是用一层遍历 + 双指针的方式来做 区别在于我们需要每次多关注一个 minDiff 的参数更新，这个参数表示当前遍历过的所有三元组中，和与 target 差距最小的差距 如果差距为 0，则返回当前之和，否则要更新 minDiff 并记录当前之和 Javascript /** * @param {number[]} nums * @param {number} target * @return {number} */ var threeSumClosest = function (nums, target) { nums.sort((a, b) => a - b) let minDiff = Infinity let res = Infinity const len = nums.length for (let i = 0; i 0 && nums[i] === nums[i - 1]) { continue } let left = i + 1 let right = len - 1 while (left "},"medium/17.html":{"url":"medium/17.html","title":"17. Letter Combinations of a Phone Number(medium)","keywords":"","body":"17. Letter Combinations of a Phone Number Leetcode link 解题思路 本题要我们求出指定的拨号能够组合出的所有字母排列 要处理这个题目首先需要建立一组拨号数字到字母的映射表 dialMap = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' } 然后我们可以抽象一下：所有拨号字母的组合 = 前面 n 个拨号字母的组合 分别加上 后面一个拨号的字母映射 举个例子，假设现在要求 \"23\"，那么： 2 的组合有：[\"a\", \"b\", \"c\"] 将 3 的字母映射分别加到 2 的组合中：[\"ad\", \"bd\", \"cd\", \"ae\", \"be\", \"ce\", \"af\", \"bf\", \"cf\"] 如此一来，我们只需要遍历 digits，然后每次都将新的数字的映射分别加到旧的组合后面就好了 C++ class Solution { public: vector combineString(vector & prev, string cur) { vector res; for(string comb : prev) { for(char ch: cur) { res.push_back(comb + ch); } } return res; } vector letterCombinations(string digits) { if(digits.size() == 0) { return {}; } unordered_map dialMap { {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; vector res {\"\"}; for(char digit: digits) { res = combineString(res, dialMap[digit]); } return res; } }; Javascript var letterCombinations = function(digits) { const dialMap = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' } return digits.split('').reduce((prev, cur)=> { if(prev.length === 0) { return dialMap[cur].split(''); } let res = []; for(let oldChar of prev) { for(let newChar of dialMap[cur].split('')) { res.push(`${oldChar}${newChar}`); } } return res; },[]) }; "},"medium/18.html":{"url":"medium/18.html","title":"18. 4Sum(medium)","keywords":"","body":"18. 4Sum Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} target * @return {number[][]} */ 这题就是 3 sum 的再进阶版 本题给了一个数字数组 nums 以及一个 target 要求我们在 nums 中找到任意四个元素，使得其和为 target 要求返回所有不重复的四元组 解题思路 3 sum = 一个循环+双指针 4 sum = 两个循环+双指针 记得去除重复的元组就好 Javascript /** * @param {number[]} nums * @param {number} target * @return {number[][]} */ var fourSum = function (nums, target) { const len = nums.length const res = [] if (len a - b) for (let i = 0; i 0 && nums[i] === nums[i - 1]) { continue; } for (let j = i + 1; j i + 1 && nums[j] === nums[j - 1]) { continue } let left = j + 1 let right = len - 1 const sum = nums[i] + nums[j] while (left target) { right-- } else { res.push([nums[i], nums[j], nums[left], nums[right]]) left++ right-- // skip duplicate while (nums[left] === nums[left - 1] && left left) { right-- } } } } } return res }; "},"medium/19.html":{"url":"medium/19.html","title":"19. Remove Nth Node From End of List(medium)","keywords":"","body":"19. Remove Nth Node From End of List Leetcode link 题目简介 /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ 题目要求我们将链表 head 的后面第 n 项删除 解题思路 这种查找链表最后 n 项的题目，我们优先考虑双指针来解决 具体而言，如果题目要求我们删除最后第三项，我们用两个指针来模拟： 1 -> 2 -> 3 -> 4 -> 5 ^ ^ left 指针指向当前链表头，right 指针指向链表头后 3 项的元素（也就是上面代码中的 4） 接下来，我们让两个指针同步往前进，直到 right 指针指向链表最后一个元素： 1 -> 2 -> 3 -> 4 -> 5 ^ ^ 此时指针 left 应该要指向要删除元素的前一个元素 此时我们只需要将 left.next = left.next.next 就可以完成元素删除了 当然我们还需要考虑一种边界情况，那就是要删除的是该链表的链表头 在这种情况下，n 等于链表的长度，此时当我们移动 right 指针的时候，会得到 right === null： // 假设此时 n === 5 1 -> 2 -> 3 -> 4 -> 5 -> null ^ ^ 此时我们需要返回 head.next Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ var removeNthFromEnd = function(head, n) { let left = head let right = head let count = n while(count>0) { right = right.next count-- } if(!right) { return head.next } while(right.next) { right = right.next left = left.next } left.next = left.next.next return head }; "},"medium/22.html":{"url":"medium/22.html","title":"22. Generate Parentheses(medium)","keywords":"","body":"22. Generate Parentheses Leetcode link 题目简介 /** * @param {number} n * @return {string[]} */ 题目给了一个数字 n，要求我们求出 n 对括号的所有合法的排列组合 解题思路 这题需要用递归的思路来做，递归函数接收三个参数： 左括号数量 右括号数量 当前的组合字符串 递归的终止条件是：左右括号数量相同且等于 n 在递归中，如果左括号数量小于 n，我们可以插入一个左括号；如果右括号数量小于左括号，我们可以插入一个右括号 Javascript /** * @param {number} n * @return {string[]} */ var generateParenthesis = function(n) { const res = [] const dfs = (leftP, rightP, str) => { if(leftP === rightP && leftP === n) { res.push(str) return } if(leftP "},"medium/24.html":{"url":"medium/24.html","title":"24. Swap Nodes in Pairs(medium)","keywords":"","body":"24. Swap Nodes in Pairs Leetcode link 题目简介 /** * @param {ListNode} head * @return {ListNode} */ 题目给我们一个链表头指针 head 要求我们将链表内的元素两两交换，比如： 1->2->3->4->5 => 2->1->4->3->5 最后返回新的链表头 解题思路 这题有两个思路：递归与循环 循环的话，我们会需要用到一个 dummy head 来指向当前的 head 每次循环，我们都尝试把 dummy.next 与 dummy.next.next 交换，并更新 dummy 的指向 循环终止条件是 dummy.next 或 dummy.next.next 其中一个为空 Javascript——循环 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var swapPairs = function(head) { const dummy = new ListNode(0, head) let prev = dummy while(prev.next && prev.next.next) { let first = prev.next let second = first.next first.next = second.next second.next = first prev.next = second prev = first } return dummy.next }; Javascript——递归 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var swapPairs = function (head) { if (head === null || head.next === null) { return head; } let node1 = head,node2 = head.next; node1.next = node2.next; node2.next = node1; node1.next = swapPairs(node1.next); return node2; }; "},"medium/29.html":{"url":"medium/29.html","title":"29. Divide Two Integers(medium)","keywords":"","body":"29. Divide Two Integers Leetcode link 解题思路 本题要求我们在不用乘法、除法与取模运算符的情况下实现一个 32 位整数除法，所得的商向 0 舍入 本题的难点有两个： 边界值的判定 如何用加法模拟除法 边界值判定比较好处理，下面聊一下如何用加法模拟除法 我们直接用一个例子来说明：62 除以 8 要高效且快速逼近被除数，我们考虑 “将除数翻倍” 的方法 首先 62/8 可以看成 (62 - 8 * 2 * 2)/8 + 4 (62 - 32)/8 + 4 可以进一步拆分成 (62 - 32 - 8 * 2)/8 + 4 + 2 最后可以变成(62 - 32 - 16 - 8)/8 + 4 + 2 + 1 = 7（向 0 舍入） C++ class Solution { public: int divide(int dividend, int divisor) { // 边界值 if (dividend == 0) return 0; if (divisor == 1) return dividend; if (divisor == -1) { if (dividend > INT_MIN) return -dividend; return INT_MAX; } // 由于本解法适用两个数都为正，所以这里先保存符号 int sign = 1; if ((dividend > 0 && divisor 0)) { sign = -1; } // 取个绝对值 long a = abs(dividend); long b = abs(divisor); // 核心，本质上就是用递归跑了一次上述思路 long res = helper(a, b); // 最后再把之前保存的符号加回来，顺便处理边界值 if (sign > 0) return res > INT_MAX ? INT_MAX : res; return -res; } int helper(long a, long b) { if (a "},"medium/31.html":{"url":"medium/31.html","title":"31. Next Permutation(medium)","keywords":"","body":"31. Next Permutation Leetcode link 解题思路 本题要求我们通过排列组合得出下一个更大的排列，以 [1,2,3] 为例子，这三个数字总共有 6 种可能的排列组合，从小到大依次是 [1,2,3] 、[1,3,2] 、[2,1,3] 、[2,3,1] 、[3,1,2] 、[3,2,1]，最后一个 [3,2,1] 按照题目的要求要返回 [1,2,3] 那么要怎么找到下一个更大的排列呢？我们以 [4,5,2,6,3,1] 为例： 要找到下一个更大的，我们必须从右往左看，找到从右往左看第一个不是升序的元素，也就是 2 然后我们再重新从右往左看，找到第一个大于 2 的元素，也就是 3 我们把 2 跟 3 交换之后，得到 [4,5,3,6,2,1]，可以明显看出来现在已经比原来的大了，但是太大了 我们发现，可以对第一个交换元素的后面进行排序来缩小这个数，也就是针对 [6,2,1] 排序 最后我们得到 [4,5,3,1,2,6] 最后我们可以推断出，步骤 4 要排序的序列一定是降序的，所以我们可以通过反转来进一步降低复杂度 C++ class Solution { public: void nextPermutation(vector& nums) { int i = nums.size() - 2; while (i >= 0 && nums[i] >= nums[i + 1]) { i--; } if (i >= 0) { int j = nums.size() - 1; while (j >= 0 && nums[i] >= nums[j]) { j--; } swap(nums[i], nums[j]); } reverse(nums.begin() + i + 1, nums.end()); } }; Javascript Array.prototype.myReverse = function (start, end) { const arr = this; while (start = 0 && nums[i] >= nums[i + 1]) { i--; } if (i >= 0) { let j = nums.length - 1; while (j >= 0 && nums[i] >= nums[j]) { j--; } [nums[i], nums[j]] = [nums[j], nums[i]]; } i "},"medium/33.html":{"url":"medium/33.html","title":"33. Search in Rotated Sorted Array(medium)","keywords":"","body":"33. Search in Rotated Sorted Array Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} target * @return {number} */ 题目要求我们从一个升序排序后的数组 nums 中找出 target 的下标 有趣的是，nums 在排序后会被往左旋转任意次 举个例子：[0,1,2,4,5,6,7] 往左旋转 3 次会变成 [4,5,6,7,0,1,2] 解题思路 这题题目要求我们用 logn 的复杂度来解，所以我们优先考虑使用二分搜索来解 由于题目加了旋转的限制，所以我们需要对二分搜索进行部份改造： 二分搜索的结构还是一样的，我们先计算出中间元素的下标 mid 接下来我们需要判断 mid 的哪一边是正常的升序： 如果 nums[mid] >= nums[left] 代表 mid 的左边是升序排列 如果 nums[mid] 代表 mid 的右边是升序排列 如果 mid 的左边是升序，那么我们可以通过判断 target 在不在左边来修改二分搜索的范围；反之亦然 Javascript /** * @param {number[]} nums * @param {number} target * @return {number} */ var search = function(nums, target) { let left = 0 let right = nums.length - 1 while(left > 1 if(nums[mid] === target) { return mid } if(nums[left] = nums[left]) { // if the target is in left half right = mid - 1 } else { left = mid + 1 } } else { // the right half is sorted if(target = nums[mid]) { // if the target is in right half left = mid + 1 } else { right = mid - 1 } } } return -1 }; "},"medium/34.html":{"url":"medium/34.html","title":"34. Find First and Last Position of Element in Sorted Array(medium)","keywords":"","body":"34. Find First and Last Position of Element in Sorted Array Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ 本题给了一个有重复元素的升序排序数组 nums 以及一个 target 题目要求我们找出数组中 target 的下标范围 解题思路 题目要求我们用 logn 的复杂度来解，所以我们还是需要用到二分法来计算 问题是，一般的二分搜索只能够用来确定单个元素的位置，无法确定范围 所以我们需要进行一些改动，我们需要解决两个问题：如何确定范围、如何找到边界 确定范围的部份我们需要用到两次二分搜索来确定题目要求的左下标与右下标 寻找边界的部份我们可以用一个变量来保存最后一次找到元素的位置 Javascript /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var searchRange = function (nums, target) { let left = 0 let right = nums.length - 1 const leftBoundary = searchLeftBoundry(nums, target, left, right) const rightBoundary = searchRightBoundary(nums, target, left, right) return [leftBoundary, rightBoundary] }; const searchLeftBoundry = (nums, target, left, right) => { let res = -1 while (left > 1 if(nums[mid] === target) { res = mid } if(nums[mid] >= target) { right = mid - 1 } else { left = mid + 1 } } return res } const searchRightBoundary = (nums, target, left, right) => { let res = -1 while (left > 1 if(nums[mid] === target) { res = mid } if(nums[mid] "},"medium/36.html":{"url":"medium/36.html","title":"36. Valid Sudoku(medium)","keywords":"","body":"36. Valid Sudoku Leetcode link 题目简介 /** * @param {character[][]} board * @return {boolean} */ 题目给我们一个 9*9 的格子组成的数独棋盘 要求我们分析当前填入的数字是否符合数独规则： 当前行只包含一个 1～9 的数字 当前列只包含一个 1～9 的数字 当前 3*3 的格子只包含一个 1～9 的数字 解题思路 这题需要我们遍历所有格子然后分别对比三个规则判断 为了减少计算量，我们可以用三个 9*9 的二位数组分别来保存三个规则下，当前遍历的数字是否被用过了 如果在后续遍历过程中，发现当前遍历的数字在之前被用上了，就表示重复了，需要返回 false 如果遍历完成所有格子都没有重复的，则返回 true Javascript /** * @param {character[][]} board * @return {boolean} */ var isValidSudoku = function (board) { const len = board.length const row = Array.from({ length: len }, _ => new Array(len).fill(false)) const col = Array.from({ length: len }, _ => new Array(len).fill(false)) const box = Array.from({ length: len }, _ => new Array(len).fill(false)) for (let i = 0; i "},"medium/39.html":{"url":"medium/39.html","title":"39. Combination Sum(medium)","keywords":"","body":"39. Combination Sum Leetcode link 题目简介 /** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ 题目给我们一个数字数组 candidates 以及一个数字 target 要求我们选取 candidates 中任意数字组成数组，使得数组所有元素之和等于 target 数组中的数字可以被使用多次 题目要求我们返回所有符合条件的数组 解题思路 涉及到选择的题目，我们可以使用回溯的思路来求解 具体来说我们需要维护一个数组 arr 来保存当前符合条件的元素 每次回溯的终止条件是 sum(arr) >= target 如果两者相等，代表我们找到了一个符合条件的数组，可以把它保存起来 如果总和大于 target，我们直接终止这次回溯，继续遍历下一个元素 由于 candidates 中的每个元素都可以使用多次，所以我们每次回溯的时候，都需要遍历一次整个 candidates Javascript /** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ var combinationSum = function (candidates, target) { const len = candidates.length const res = [] const backtracking = (index, sum, arr) => { if (sum > target) { return } if (sum === target) { res.push([...arr]) return } for (; index >= 0; index--) { arr.push(candidates[index]) backtracking(index, sum + candidates[index], arr) arr.pop() } } backtracking(len - 1, 0, []) return res }; "},"medium/40.html":{"url":"medium/40.html","title":"40. Combination Sum II(medium)","keywords":"","body":"40. Combination Sum II Leetcode link 题目简介 /** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ 题目给我们一个数组 candidates 以及数字 target 要求我们找出数组 candidates 中加总为 target 的所有子数组 子数组需要升序排序 解题思路 这题我们尝试用回溯的思路来求解 首先需要给 candidates 进行排序，这样以来我们可以在回溯过程中剪枝减少计算量 在回溯的过程中我们有两个重要的判断： 如果当前元素与上一个元素重复了，我们需要跳过 如果当前子数组的综合已经超过了 target，我们也需要跳过 Javascript /** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ var combinationSum2 = function (candidates, target) { let res = [] candidates.sort((a, b) => a - b) const backtrack = (start, restTarget, curCandidates) => { if (restTarget === 0) { res.push([...curCandidates]) return } for (let i = start; i start && candidates[i] === candidates[i-1]) { continue } if(candidates[i] > restTarget) { return } curCandidates.push(candidates[i]) backtrack(i+1, restTarget - candidates[i], curCandidates) curCandidates.pop() } } backtrack(0, target, []) return res }; "},"medium/45.html":{"url":"medium/45.html","title":"45. Jump Game II(medium)","keywords":"","body":"45. Jump Game II Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums 数组中每一个元素代表如果当前站在这个格子上的话最多可以往前跳几格 初始状态下我们在下标 0 的位置 题目要求我们计算出最少需要经过几次跳跃才能到达数组末尾元素 解题思路 题目要求我们使用最少次跳跃跳到数组末尾，我们可以用贪心的思路来解决这个问题 假设我们有个数组是：[2,3,1,1,4] 我们的策略是：对每一个元素，我们都在它可以跳的范围内选择下一步可以跳的最远的元素 假设 cur 是当前我们遍历的元素的下标，以下是操作步骤： cur = 0：此时我们能跳的最远的下标是 2，我们用一个临时变量 farthest 标记 我们从可以跳到的元素中选择能跳最远的元素（也就是元素 3，下标 1），更新 cur cur = 1：此时我们能跳的最远的下标是 4，我们用 farthest 标记 farthest 命中了数组末尾元素，结束遍历 代码如下： Javascript /** * @param {number[]} nums * @return {number} */ var jump = function (nums) { const len = nums.length let cur = 0 let next = 0 let steps = 0 while (next "},"medium/46.html":{"url":"medium/46.html","title":"46. Permutations(medium)","keywords":"","body":"46. Permutations Leetcode link 解题思路 求一组元素可能的排列组合，最常用的方法就是回溯 backtracking 了 为了减少时间复杂度，我们用了一个数组 visited 来记录当前选择的元素是否已经被选过了，达到剪枝的目的 C++ class Solution { public: vector> permute(vector& nums) { vector> res; vector visited(nums.size()); getPermutations(res, nums, visited, {}); return res; } void getPermutations(vector> &res, vector& nums, vector &visited, vector array) { if(array.size() == nums.size()) { res.push_back(array); return; } for(int i=0;i Javascript var permute = function(nums) { let res = []; let visited = new Array(nums.length).fill(false); getPermutations(res, nums, visited, []); return res; }; var getPermutations = function(res, nums, visited, arr) { if(arr.length === nums.length) { res.push(arr); return; } for(let i = 0;i "},"medium/47.html":{"url":"medium/47.html","title":"47. Permutations II(medium)","keywords":"","body":"47. Permutations II Leetcode link 解题思路 本题跟 46. Permutations 思路差不多，区别在于这个题目给的数组中有重复项 我们可以在 46 题的基础上，加上两个部分： 给 nums 排序，让重复的数字比邻 在 46 题的规则上进行剪枝 第一个部分比较好理解，问题在于第二个部分剪枝的规则，我们的思路是： 首先我们假设有个重复项 [a~1~, a~2~]，那么我们规定 a~1~ 必须在 a~2~ 前面出现 如此一来，我们进行剪枝的规则就出来了： 判断当前项是否与前一项相等，如果是 判断前一项是否已经出现了，如果是 那么不进行剪枝；否则进行剪枝 C++ class Solution { public: vector> permuteUnique(vector& nums) { sort(nums.begin(), nums.end()); vector> res; vector visited(nums.size()); getPermutations(res, nums, visited, {}); return res; } void getPermutations(vector> &res, vector& nums, vector &visited, vector array) { if(array.size() == nums.size()){ res.push_back(array); return; } for(int i=0;i Javascript /** * @param {number[]} nums * @return {number[][]} */ var permuteUnique = function(nums) { // 记得先排序一下让重复项相邻 nums.sort((a, b)=>a-b); let res = []; let visited = new Array(nums.length).fill(false); getPermutations(res, nums, visited, []); return res; }; var getPermutations = function(res, nums, visited, arr) { if(arr.length === nums.length) { res.push(arr); return; } for(let i = 0;i "},"medium/48.html":{"url":"medium/48.html","title":"48. Rotate Image(medium)","keywords":"","body":"48. Rotate Image Leetcode link 题目简介 /** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */ 题目给我们一个 n*n 的矩阵，要求我们不借助别的空间将当前矩阵向右旋转 90 度 解题思路 我们需要把向右旋转 90 度拆分为两个操作： 把矩阵从左上到右下划一条线，把所有矩阵元素沿着这条线交换（术语叫转置矩阵） 把矩阵每一行的元素逆转 Javascript /** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */ var rotate = function(matrix) { const width = matrix[0].length const height = matrix.length // Step1: transpose the matrix for(let i=0;i "},"medium/49.html":{"url":"medium/49.html","title":"49. Group Anagrams(medium)","keywords":"","body":"49. Group Anagrams Leetcode link 题目简介 /** * @param {string[]} strs * @return {string[][]} */ 题目给我们一个字符串数组，要求我们在数组中找到相同字符但是不同排列顺序的字符串，并将他们放在同一个数组中返回 解题思路 相同字符但是不同排列顺序的字符串的特性：排序后字符串相等 我们可以用如上特性，构建一个 mapping： key 是排序后的字符串 value 是原始字符串组成的数组 接下来我们遍历 strs，我们把排序后相同的字符串都放到同一个 key 的 value 中 最后我们返回所有 value 组成的数组即可 Javascript /** * @param {string[]} strs * @return {string[][]} */ var groupAnagrams = function(strs) { const map = new Map() const compare = (a, b) => a.charCodeAt(0) - b.charCodeAt(0) const res = [] for(const str of strs) { const newStr = str.split('').sort(compare).join('') if(!map.has(newStr)) { map.set(newStr, []) } map.get(newStr).push(str) } return Array.from(map.values()) }; "},"medium/53.html":{"url":"medium/53.html","title":"53. Maximum Subarray(medium)","keywords":"","body":"53. Maximum Subarray Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums 要求我们在数组中找到一个和最大的子数组并返回其和 Javascript /** * @param {number[]} nums * @return {number} */ var maxSubArray = function(nums) { let sum = 0 let res = nums[0] for(const num of nums) { sum = Math.max(num, num + sum) res = Math.max(res, sum) } return res }; "},"medium/54.html":{"url":"medium/54.html","title":"54. Spiral Matrix(medium)","keywords":"","body":"54. Spiral Matrix Leetcode link 题目简介 /** * @param {number[][]} matrix * @return {number[]} */ 题目给我们一个 m*n 的矩阵，要求我们从左上角开始螺旋向内输出所有元素的值 解题思路 这题的关键是我们要如何让指针按照我们想要的顺序指向各个元素 起始的元素必定是 [0, 0] 我们需要两个变量 [dx, dy] 来决定下一步要去到哪里 dx，dy 的值应该有 4 个状态，且状态之间变化顺序如下 [1, 0] => [0, 1] => [-1, 0] => [0, -1] => [1, 0] => ... 满足状态变化的条件有两个： 当 x+dx 或 y+dy 超过了 matrix 的边界 当 [x+dx, y+dy] 碰到了原来经过的元素 最后我们需要准备一个数组 res 来保存这个遍历过程经过的元素 Javascript /** * @param {number[][]} matrix * @return {number[]} */ var spiralOrder = function (matrix) { const width = matrix[0].length const height = matrix.length const res = [] let x = 0 let y = 0 // [dx, dy]: [1, 0] => [0, 1] => [-1, 0] => [0, -1] let dx = 1 let dy = 0 for (let i = 0; i = 0 && x + dx = 0 && y + dy "},"medium/55.html":{"url":"medium/55.html","title":"55. Jump Game(medium)","keywords":"","body":"55. Jump Game Leetcode link 题目简介 /** * @param {number[]} nums * @return {boolean} */ 题目给我们一个数字数组 nums 数组元素代表如果站在这一个元素上最多可以往前跳几格 我们一开始在下标 0 的元素上，题目要求我们判断我们是否可以跳到最后的元素上 解题思路 由于题目的约束是最多可以往前跳几格，所以我们只需要尽可能的往前跳就完事了 这就需要用到贪心的思路了，我们每次都尽可能的往前跳，直到无法再往前或者超越数组末尾 Javascript /** * @param {number[]} nums * @return {boolean} */ var canJump = function (nums) { let cur = 0 let next = 0 while (next "},"medium/56.html":{"url":"medium/56.html","title":"56. Merge Intervals(medium)","keywords":"","body":"56. Merge Intervals Leetcode link 题目简介 /** * @param {number[][]} intervals * @return {number[][]} */ 题目给我们一个二维数组 intervals，数组中有多个数字组成的二元组 要求我们合并有重叠的二元组，并最终返回所有合并后的二元组 解题思路 这题最大的难点就是给的二元组顺序是乱序的，而最理想的情况是每个二元组都按照第一个元素从小到大排序 所以我们一开始要对 intervals 进行一次排序 排序后我们只需要遍历 intervals 然后把重叠的部分合并，把不重叠的部分推入新数组即可 Javascript /** * @param {number[][]} intervals * @return {number[][]} */ var merge = function (intervals) { intervals.sort((a, b) => a[0] - b[0]) const res = [] let last = intervals[0] for (let i = 1; i "},"medium/59.html":{"url":"medium/59.html","title":"59. Spiral Matrix II(medium)","keywords":"","body":"59. Spiral Matrix II Leetcode link 解题思路 题目要求我们给 n x n 的数组螺旋赋值 想要螺旋赋值首先就得规定好四面 “墙”，我们分别叫他们 left， right， top， bottom 我们可以把赋值的分成 4 个步骤，并在昨晚之后对墙做相应的调整： 从左到右，之后把上墙下移 ++top 从上到下，之后把右墙左移 --right 从右到左，之后把下墙上移 --bottom 从下到上，之后把左墙右移 ++left 以上四个动作为一个循环，然后不断循环缩小范围直到全部赋值完毕 C++ class Solution { public: vector> generateMatrix(int n) { vector> res(n, vector(n)); int left = 0, right = n - 1, top = 0, bottom = n - 1; int number = 1; // use to trace current path int i = 0; while (left = left) { res[bottom][i--] = number++; } i = --bottom; // bottom to top while (i >= top) { res[i--][left] = number++; } i = ++left; } return res; } }; Javascript /** * @param {number} n * @return {number[][]} */ var generateMatrix = function(n) { const res = Array(n); for(let i = 0;i= left) { res[bottom][i--] = number++; } i = --bottom; // bottom to top while (i >= top) { res[i--][left] = number++; } i = ++left; } return res; }; "},"medium/61.html":{"url":"medium/61.html","title":"61. Rotate List(medium)","keywords":"","body":"61. Rotate List Leetcode link 解题思路 题目要求我们给一个链表旋转 k 个位置，而且把 k 的范围给了一个 ，所以考虑优化肯定需要取余。 回到解题思路本身，链表旋转本质上就是三个步骤： 把原来链表的 “尾巴” 接到 “ 头” 上 确定新的链表头 把新链表头的前一个链表的 next指定为NULL 具体落实到代码里，考虑细节的话需要做到如下几步： 计算链表长度，并把链表尾接到链表头上 计算新的链表头的位置 留一个指针指向新链表的尾巴，并将其next置为NULL C++ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if (head == NULL || k == 0) return head; int len = 1; ListNode* cur = head; // 计算链表长度，并把链表尾接到链表头上 while (cur->next) { len++; cur = cur->next; } cur->next = head; cur = head; // 计算新的链表头的位置 int step = len - (k % len); while (--step > 0) { cur = cur->next; } head = cur->next; // 将新链表尾置为NULL cur->next = NULL; return head; } }; Javascript var rotateRight = function (head, k) { if (!head || k === 0) return head; let len = 1; let cur = head; // 计算链表长度，并把链表尾接到链表头上 while (cur.next) { len++; cur = cur.next; } cur.next = head; cur = head; // 计算新的链表头的位置 let step = len - (k % len); while (--step > 0) { cur = cur.next; } head = cur.next; // 将新链表尾置为NULL cur.next = null; return head; }; "},"medium/62.html":{"url":"medium/62.html","title":"62. Unique Paths(medium)","keywords":"","body":"62. Unique Paths Leetcode link 题目简介 /** * @param {number} m * @param {number} n * @return {number} */ 题目给我们一个 m 行 n 列的棋盘 要求我们计算出从左上角走到右下角总共有多少种可能的不重复路线 解题思路 假设 m=2, n=2 我们可以得到如下状态图 1 1 1 2 首先我们到达左上角的路径只有一条（因为是初始状态） 在左上角的时候我们可以选择向右走或者向下走，所以两个对应格子各自是 1 有趣的是右下角格子的路径数量，是等于它上面格子的路线数量 + 左边格子路线数量 所以我们可以得到一个状态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1] 有了状态转移方程后，我们只需要从 dp[0][0]（也就是左上角）开始依次更新 dp 数组直到求出 dp[m-1][n-1] 的值即是答案 为了方便计算，我们可以声明一个 m+1 * n+1 的 dp 棋盘，并把第一行跟第一列设置为 0 以上，就是动态规划的思路 Javascript /** * @param {number} m * @param {number} n * @return {number} */ var uniquePaths = function (m, n) { const dp = Array.from({ length: m + 1 }, _ => new Array(n + 1).fill(0)) dp[1][1] = 1 for (let row = 1; row "},"medium/63.html":{"url":"medium/63.html","title":"63. Unique Paths II(medium)","keywords":"","body":"63. Unique Paths II Leetcode link 解题思路 本题要求我们在一个 m * n 的矩阵中，计算从左上角走到右下角不碰到障碍物的所有路径 本题解法有两种思路：dfs 以及动态规划 首先来看一下 dfs，dfs 的方法会要求我们遍历所有可能的路径，我们来看一下它的时间复杂度： 因为每一个节点有两种可能的走法：向下跟向右，而所有的节点总共有 m n 个，所以总共要做 m n 次抉择 因此时间复杂度为 O(2 ^ (m * n)) 接下来，我们来看看动态规划 首先，我们用一个二维数组 dp，其中 dp[i][j] 表示矩阵中下标为 (i, j) 的位置能够到达的路径数量 根据题目中只能向下走跟向右走的限制，我们可以轻易得出如下等式： dp[i][j] = dp[i-1][j] + dp[i][j-1] 如果没有障碍物的话，到这里已经结束了，但是题目的另一个约束条件就是路径上可能有障碍物，所以，我们格局需要再打开一点 具体而言，我们可以把目前 m n 的 dp 数组分别在左边跟上面加上一列以及一行，使其大小为 `(m + 1) (n + 1)` 然后我们可以把 dp 数组初始化为 0，然后在 (1, 0) 或者 (0, 1) 的位置初始化为 1 就好了 详情看代码 C++ class Solution { public: int uniquePathsWithObstacles(vector>& obstacleGrid) { int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector> dp(m+1, vector(n+1, 0)); dp[0][1] = 1; for(int i = 1;i Javascript var uniquePathsWithObstacles = function(obstacleGrid) { let m = obstacleGrid.length, n = obstacleGrid[0].length; // dp[m+1][n+1] let dp = new Array(m+1); for(let i=0;i "},"medium/64.html":{"url":"medium/64.html","title":"64. Minimum Path Sum(medium)","keywords":"","body":"64. Minimum Path Sum Leetcode link 题目简介 /** * @param {number[][]} grid * @return {number} */ 题目给我们一个全是数字的表格 grid 要求我们选中一条途径数字之和最小的路径从表格的左上走到右下 并返回该路径途径数字之和 解题思路 我们先讨论只有一个格子的情况，此时答案就是 grid[0][0] 的值 如果有两个格子呢？假设是左右相邻，此时答案是 grid[0][0] + grid[0][1] 再次拓展到 4 个格子的情况：右下角的格子有两条路径，我们需要选择其中和比较小的作为路径，此时答案为 min(grid[0][1], grid[1][0]) + grid[1][1] 假设我们使用数组 dp 来表示到达当前格子的最少路径之和 根据上面的讨论，我们得到了状态转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] 为了方便计算，我们可以声明一个长宽都比 grid 多 1 的数组，并且将其中元素全部初始化为正无穷 dp 数组的初始状态为 dp[1][1] = grid[0][0] Javascript /** * @param {number[][]} grid * @return {number} */ var minPathSum = function (grid) { const width = grid[0].length const height = grid.length const dp = Array.from({ length: height + 1 }, _ => new Array(width + 1).fill(Number.MAX_SAFE_INTEGER)) for (let row = 1; row "},"medium/72.html":{"url":"medium/72.html","title":"72. Edit Distance(medium)","keywords":"","body":"72. Edit Distance Leetcode link 题目简介 /** * @param {string} word1 * @param {string} word2 * @return {number} */ 题目给我们两个字符串 word1 与 word2，要求我们判断从 word1 变成 word2 最少需要多少次操作 操作的种类： 替换字符 replace 新增字符 insert 删除字符 delete 解题思路 我们先尝试简化这个问题：假设 word1 与 word2 都只有一个字符 此时有两种情况： word1 === word2：此时不需要任何操作即符合要求 word1 !== word2：此时我们需要一个 replace 操作 如果扩展成各有两个字符呢？假设 word1 = 'ab' ，word2 = 'cd' 我们可以画出如下表格： c d a a->c: 1(replace) a->cd: 2(replace+insert) b ab->c: 2(replace+delete) ab->cd: 2(replace+replace) 我们重点看右下角的四个格子，其中： a->c 符合我们上述第二种情况，需要一个 replace 操作 a->cd 在 a->c 的基础上我们需要额外的 insert 操作 ab->c 在 a->c 的基础上我们需要额外的 delete 操作 ab->cd 这种情况我们需要判断要基于哪一个状态进行操作，有三种选项： 选择 a->c 此时我们需要一个额外的 replace（replace b with d） 选择 a->cd 此时我们需要一个额外的 delete 操作（delete b） 选择 ab->c 此时我们需要一个额外的 insert 操作（insert c） 要使得操作数最少，我们需要找出原来操作最少的操作，于是我们选中 a->c 综上，我们得到了状态转移方程（我们假设 dp[i][j] 代表 word1[0...i-1] 转变为 word2[0...j-1] 需要的最少操作数） 如果 word[i-1] === word2[j-1] ：dp[i][j] = dp[i-1][j-1] 否则：dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1 边界情况发生在第一行与第一列，所以我们给 dp 多一行一列给默认值 Javascript /** * @param {string} word1 * @param {string} word2 * @return {number} */ var minDistance = function (word1, word2) { const len1 = word1.length const len2 = word2.length const dp = Array.from({ length: len1 + 1 }, _ => new Array(len2 + 1).fill(0)) for (let row = 0; row "},"medium/73.html":{"url":"medium/73.html","title":"73. Set Matrix Zeroes(medium)","keywords":"","body":"73. Set Matrix Zeroes Leetcode link 题目简介 /** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */ 题目给我们一个 m*n 的矩阵 matrix 要求我们把矩阵内元素值为 0 的行与列全部置 0 并且只能在原地操作 matrix 解题思路 我们首先遍历整个 matrix，找出需要置 0 的行与列 然后我们分别把对应的行与列置 0 即可 Javascript /** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */ var setZeroes = function (matrix) { const height = matrix.length const width = matrix[0].length const zeroRows = [] const zeroCols = [] for (let i = 0; i { matrix[row].fill(0) }) zeroCols.forEach(col => { for (let row = 0; row "},"medium/74.html":{"url":"medium/74.html","title":"74. Search a 2D Matrix(medium)","keywords":"","body":"74. Search a 2D Matrix Leetcode link 解题思路 本题给了我们一个二维数组，又告诉我们保证每一行都是升序的，而且下一行的数一定比较大。简单来说，这个就是一个升了一个纬度的升序数组。于是乎，二分法再次成为我们的得力助手。 本题的思路核心在于，如何将二分法计算出来的中间值 mid 对二维数组取值，解决了这一点这题就没什么难度了。 C++ class Solution { public: bool searchMatrix(vector>& matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int left = 0, right = n * m - 1; while (left value) left = mid + 1; } return false; } }; Javascript var searchMatrix = function(matrix, target) { let m = matrix.length, n = matrix[0].length; let left = 0, right = n * m - 1; while (left value) left = mid + 1; } return false; }; "},"medium/75.html":{"url":"medium/75.html","title":"75. Sort Colors(medium)","keywords":"","body":"75. Sort Colors Leetcode link 题目简介 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ 题目给我们一个数字数组 nums，其中只包含三种数字：0、1、2， 分别代表红白蓝三种颜色 题目要求我们按照 012 的顺序把 nums 所有元素重新排列，让相同的颜色相邻 解题思路 这题看起来就是一个简单的手撕排序题，但是由于 nums 只包含三种数字，所以我们可以用三指针的方式将其优化到 O(n) 的复杂度 Javascript /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var sortColors = function (nums) { let left = 0 let mid = 0 let right = nums.length - 1 while (mid "},"medium/78.html":{"url":"medium/78.html","title":"78. Subsets(medium)","keywords":"","body":"78. Subsets Leetcode link 题目简介 /** * @param {number[]} nums * @return {number[][]} */ 题目给我们一个数组 nums，要求我们返回所有 nums 可能的子数组（不能重复） 解题思路 要求把元素中的子数组，我们一般使用回溯的框架加上不同条件判断处理 这一题最大的难点就是如何让子数组们不重复 要解决这一点，我们先来看看什么情况会重复，假设 nums 是 [1, 2, 3] 包含 1 的子数组有：[1], [1, 2], [1, 2, 3], [1, 3] 包含 2 的子数组有：[2], [2, 1], [2, 1, 3], [2, 3] 可以看到其中 [2, 1], [2, 1, 3] 重复了，因为它取到了下标比它小的数字 1 所以我们得到结论：在回溯时，我们只需要考虑取比当前下标大的元素即可 Javascript /** * @param {number[]} nums * @return {number[][]} */ var subsets = function (nums) { const res = [] const backtracking = (arr, start) => { res.push([...arr]) for (; start "},"medium/81.html":{"url":"medium/81.html","title":"81. Search in Rotated Sorted Array II(medium)","keywords":"","body":"81. Search in Rotated Sorted Array II Leetcode link 解题思路 本题与 704 的 binary search其实本质上是相同的问题，只是这题在原来的基础上加了一个随机旋转数组的操作。但是我们仍然可以用二分的思想来做查找的动作，只是需要多判断一些条件 首先我们假设有这么一个数组 [1, 2, 3, 4, 5, 6, 7]，它经过旋转之后以最中间的数为观察点有 2 种情况： 左边升序、右边不一定升序，比如：[3, 4, 5, 6, 7， 1， 2]（以中间的数 6 来看，3～6 明显是升序的，6～2 明显不升序） 右边升序、左边不一定升序，比如：[6, 7, 1, 2, 3, 4, 5]（以中间的数 2 来看，6～2 明显不升序，2～5 明显升序） 但是题目说到数组允许重复数字，我们考虑到一种特殊的数组 [1, 1, 1, 1, 1, 2]，这种数组为我们的情况增加了一种： 左右两边都一定升序（只要数字 2 不刚好是中间数就会出现这种情况） 要使用二分法，需要确定三个点：left, right, mid left 用来确定二分范围的左边界 right 用来确定二分范围的右边界 mid 是本次二分范围的中心，用来确定下一次二分的区域 本题我们只需要再针对上述三种状况分别判断一下就可以了： 第一种情况，我们可以用 nums[mid] > nums[right] 为真来确定 第二种情况，我们可以用 nums[mid] 为真来确定 第三种情况，我们可以用 nums[mid] == nums[right] 为真来确定 用代码区分开了三种情况之后，我们只需要分别处理就好了，这里我们的思路可以概括为：柿子挑软的捏 针对第一、第二种情况，我们只需要判断 target 是否在他们升序部分就好了，如果是就把范围定到升序部分之后处理就好（情况二刚好也可以处理升序）；如果不是就说明 target 要不在另一部分，要不不在数组中，我们把范围缩小到另一部分重新判断一次情况。 针对第三种情况，我们只需要把 right - 1 就好了，也就是把右边范围缩小慢慢排除重复的数字 C++ class Solution { public: bool search(vector& nums, int target) { int left = 0, right = nums.size() - 1; while (left nums[right]) { // 如果它在升序的部分 if (nums[mid] > target && nums[left] = target) { left = mid + 1; } else { right = mid - 1; } // 确定是第三种情况 } else { right--; } } // 找完之后没找到 return false; } }; Javascript var search = function(nums, target) { let left = 0, right = nums.length - 1; while (left nums[right]) { // 如果它在升序的部分 if (nums[mid] > target && nums[left] = target) { left = mid + 1; } else { right = mid - 1; } // 确定是第三种情况 } else { right--; } } return false; }; "},"medium/98.html":{"url":"medium/98.html","title":"98. Validate Binary Search Tree(medium)","keywords":"","body":"98. Validate Binary Search Tree Leetcode link 题目简介 /** * @param {TreeNode} root * @return {boolean} */ 题目给我们一个二叉树的根节点 root，要求我们判断这棵树是不是一个二叉搜索树 Binary Search Tree（BST） BST 的条件是： 空树是二叉搜索树。 若二叉搜索树的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值。 若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。 二叉搜索树的左右子树均为二叉搜索树。 解题思路 我们依然使用 dfs 来遍历当前的树 对于树的每一个节点都有一个最大值与最小值的范围，如果当前遍历节点超过范围，则该树不是 BST 否则遍历该树的左右子树，并且更新最大值与最小值 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isValidBST = function(root) { const dfs = (node, min, max) => { if(!node) { return true } if(node.val = max) { return false } return dfs(node.left, min, node.val) && dfs(node.right, node.val, max) } return dfs(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER) }; "},"medium/99.html":{"url":"medium/99.html","title":"99. Recover Binary Search Tree(medium)","keywords":"","body":"99. Recover Binary Search Tree Leetcode link 解题思路 本题随意调换了 BST 的两个元素。 我们知道，当对 BST 进行先序遍历的时候，得到的是一个递增序列，在递增序列任意交换两个数有两种可能： 两个交换的数是相邻的 两个交换的数不相邻 那么我们可以用一个指针 prev 记录上一个中序遍历的节点，然后跟当前节点对比，如果 prev 比较大，则把 prev 跟当前节点一起存放到一个数组 target 中。 这样子一次遍历之后，有两种可能： target 中有一个元素（因为两个交换的数比邻），那么只需要交换元素中两个指针的 val 就好。 target 中有两个元素（因为两个交换的数不相邻），那么只需要交换 第一个元素的第一个指针的 val 与 第二个元素的第二个指针的 val 就好。 C++ class Solution { public: vector> target; TreeNode* prev = nullptr; void dfs(TreeNode* node) { if (node == nullptr) { return; } dfs(node->left); if (prev && (prev->val > node->val)) { target.push_back({prev, node}); } prev = node; dfs(node->right); } void recoverTree(TreeNode* root) { dfs(root); if (target.size() == 1) { // 相邻情况 swap(target[0].first->val, target[0].second->val); } else if (target.size() == 2) { // 不相邻情况 swap(target[0].first->val, target[1].second->val); } } }; Javascript var recoverTree = function(root) { let target = []; let prev = null; const dfs = (node)=>{ if(!node){ return; } dfs(node.left); if(prev && prev.val > node.val) { target.push([prev, node]); } prev = node; dfs(node.right); } dfs(root); if(target.length === 1) { // 相邻情况 [target[0][0].val, target[0][1].val] = [target[0][1].val, target[0][0].val]; } else if(target.length === 2) { // 不相邻情况 [target[0][0].val, target[1][1].val] = [target[1][1].val, target[0][0].val]; } }; "},"medium/102.html":{"url":"medium/102.html","title":"102. Binary Tree Level Order Traversal(medium)","keywords":"","body":"102. Binary Tree Level Order Traversal Leetcode link 题目简介 /** * @param {TreeNode} root * @return {number[][]} */ 题目给我们一个二叉树的根 root，要求我们输出其层序遍历的节点值 每一层的节点都要包裹在一个数组中 解题思路 层序遍历我们一般使用 bfs 的思路 我们维护一个数组 queue 存放每一层的元素 当 queue 长度不为 0 的时候我们可以取出当前所有元素放进数组 layer 中 当 queue 当前所有元素取完之后，我们需要把下一层的元素一次 push 近 queue 中方便下次遍历 针对 root 为 null 的情况我们可以在一开始特殊处理 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function(root) { if(!root) { return [] } const queue = [root] const res = [] while(queue.length > 0) { let len = queue.length const layer = [] while(len-- > 0) { const node = queue.shift() layer.push(node.val) if(node.left) { queue.push(node.left) } if(node.right) { queue.push(node.right) } } res.push(layer) } return res }; "},"medium/105.html":{"url":"medium/105.html","title":"105. Construct Binary Tree from Preorder and Inorder Traversal(medium)","keywords":"","body":"105. Construct Binary Tree from Preorder and Inorder Traversal Leetcode link 题目简介 /** * @param {number[]} preorder * @param {number[]} inorder * @return {TreeNode} */ 题目给我们一颗树经过先序遍历的数组 preorder 以及中序遍历的数组 inorder 题目要求我们根据这两个数组还原出树并返回 解题思路1 这题有两种解法，首先我们先来看没有经过优化的方法 通过 preorder[0] 确定当前树/子树的根节点 通过 inorder 中 preorder[0] 的位置分割其左子树与右子树的节点 递归调用分别处理左子树与右子树 返回一开始的根节点 时间复杂度：O(n^2) Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} preorder * @param {number[]} inorder * @return {TreeNode} */ var buildTree = function (preorder, inorder) { if (inorder.length === 0) { return null } const rootValue = preorder.shift() const rootIdx = inorder.indexOf(rootValue) const root = new TreeNode(rootValue) root.left = buildTree(preorder, inorder.slice(0, rootIdx)) root.right = buildTree(preorder, inorder.slice(rootIdx + 1)) return root }; 解题思路 2 我们通过仔细观察可以发现上面的方法中 寻找 inorder 内元素下标需要 O(n) 的复杂度 如果我们用一个 map 来代替每次寻找下标，可以把这个复杂度省略掉 于是就有了思路 2 时间复杂度：O(n) Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} preorder * @param {number[]} inorder * @return {TreeNode} */ var buildTree = function (preorder, inorder) { const inorderMap = new Map() for (let i = 0; i { if (start > end) { return null } const rootValue = preorder[preorderIdx++] const rootIdx = inorderMap.get(rootValue) const root = new TreeNode(rootValue) root.left = buildByRange(start, rootIdx - 1) root.right = buildByRange(rootIdx + 1, end) return root } return buildByRange(0, preorder.length - 1) }; "},"medium/114.html":{"url":"medium/114.html","title":"114. Flatten Binary Tree to Linked List(medium)","keywords":"","body":"114. Flatten Binary Tree to Linked List Leetcode link 题目简介 /** * @param {TreeNode} root * @return {void} Do not return anything, modify root in-place instead. */ 题目给我们一个二叉树的根节点 root 要求我们在原地把树改成链表，链表以 node.right 指针连接，链表连接顺序为树的前序遍历顺序 解题思路 前序遍历的顺序是：根节点 -> 左子树 -> 右子树 假设我们有一棵树： 1 / \\ 2 5 / \\ \\ 3 4 6 前序遍历的顺序是：1, 2, 3, 4, 5, 6 我们的移动顺序如下所示： 找到根节点的第一个左子节点 leftChild（就是上面例子的 2） 判断 leftChild 是否有右子节点，如果有则进入第 3 步，否则跳到第 6 步 找到 leftChild 最右叶子节点 tail，这个节点是当前以 leftChild 为根节点的树转换成链表后的最后一个节点（就是上面例子的 4） 把根节点的右子树 “嫁接” 到 tail 后面（如下图所示） 1 / 2 / \\ 3 4 \\ 5 \\ 6 把 leftChild 移到根节点的右子树（如下图所示） 1 \\ 2 / \\ 3 4 \\ 5 \\ 6 找到 leftChild 的第一个左子节点，重复第 1 步 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {void} Do not return anything, modify root in-place instead. */ var flatten = function(root) { let cur = root while(cur) { if(cur.left) { const leftChild = cur.left let tail = leftChild while(tail.right) { tail = tail.right } tail.right = cur.right cur.right = cur.left cur.left = null } cur = cur.right } }; "},"medium/117.html":{"url":"medium/117.html","title":"117. Populating Next Right Pointers in Each Node II(medium)","keywords":"","body":"117. Populating Next Right Pointers in Each Node II Leetcode link 解题思路——先进先出队列 这道题有两种思路，我们先说第一种队列的思路 首先我们需要一个先进先出的队列，然后我们按照题目要求的顺序从上到下从左到右一次把目标元素填入队列中 值得注意的是每一层的最后一个元素后面记得多填一个 NULL ；然后对于节点空的位置也需要填入 NULL C++ class Solution { public: Node* connect(Node* root) { if(!root) { return NULL; } queue q; q.push(root); q.push(NULL); while(q.size() > 1) { Node* node = q.front(); q.pop(); if(node == NULL) { q.push(NULL); } else { node->next = q.front(); if(node->left) { q.push(node->left); } if(node->right) { q.push(node->right); } } } return root; } }; 解题思路——递归 另一种思路是使用递归思想配合一个数组 数组的作用在于记录当前的层从左到右还没有记录 next 的第一个节点 Javascript var connect = function(root) { let levelPtr = []; var addNext = (node, level) => { if(!node) { return; } // 因为每一层都是从左到右访问，所以每一层只需要记录最左边还没有记录 next 指针的元素就好 if(levelPtr[level]) { levelPtr[level].next = node; } levelPtr[level] = node; addNext(node.left, level+1); addNext(node.right, level+1); } addNext(root, 0); return root; }; "},"medium/120.html":{"url":"medium/120.html","title":"120. Triangle(medium)","keywords":"","body":"120. Triangle Leetcode link 解题思路 本题要求我们求出一条从三角形顶部走到底部的最小路径和，且每一步只能移动到下一行的相邻节点上 很明显是一个动态规划的题目，我们需要一个二维数组 dp[i][j] 来记录走到 (i, j) 的最小路径和 我们首先得找到它的状态转移方程，总共有三种情况： j = 0：也就是在第 i 行的最左侧，这个时候只有 (i - 1, 0) 能走到，所以 dp[i][j] = dp[i-1][0] + Triangle[i][0] j = i：也就是在第 i 行的最右侧，这个时候只有 (i - 1, i - 1) 能走到，所以 dp[i][j] = dp[i-1][i-1] + Triangle[i][i] j 0：也就是在中间部分，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + Triangle[i][j] 最后当我们遍历完了 Triangle 之后，只要求 dp[i] 数组的最小元素就好 C++ class Solution { public: int minimumTotal(vector>& triangle) { int n = triangle.size(); vector> dp(n, vector(n)); dp[0][0] = triangle[0][0]; for(int i = 1;i Javascript /** * @param {number[][]} triangle * @return {number} */ var minimumTotal = function(triangle) { let len = triangle.length; let dp = new Array(len).fill(0).map(_=>_ = new Array(len).fill(0)); dp[0][0] = triangle[0][0]; for(let i = 1;i "},"medium/128.html":{"url":"medium/128.html","title":"128. Longest Consecutive Sequence(medium)","keywords":"","body":"128. Longest Consecutive Sequence Leetcode link 解题思路 本题要求我们找出一个给定数组的最长连续元素序列，并要求时间复杂度要是 O(n) 我们考虑到数组中的一个数 x，要求出它的最长连续元素序列，我们会需要一层 O(n) 循环来遍历数组 但是这个 O(n) 的过程也可以用一个哈希表来替代，这样查看一个数是否存在就可以简化成 O(1) 的复杂度 但是即使是这样我们的复杂度在最坏的情况也会达到 所以需要对遍历的元素做一个筛减： 首先如果有一个数 x，那么如果它的 x - 1 存在集合中，我们不需要遍历 如果有一个数 x，如果它的 x + 1 存在集合中，我们需要把它的最长连续元素序列一个个找出来 第二点容易理解，我来说说为什么要有第一点：假定有个数组是 [x, x+1, x+2, x+3, x+4] 那么我们应该都会预期是从 x 开始逐个往 x + 4 来找对吧，如果没有第一条的话，我们对 x+1 ~ x+4 的寻找就是多余的了，所以不应该计算 Javascript /** * @param {number[]} nums * @return {number} */ var longestConsecutive = function(nums) { let res = 0; let set = new Set(); for(let num of nums) { set.add(num); } for(let num of nums) { // 只有在当前数字没有比它小一的数字在集合中时才进入 if(!set.has(num - 1)) { let curNum = num; let curStreakLen = 1; while(set.has(curNum + 1)) { // 寻找集合中比它大一的数字 curNum++; curStreakLen++; } res = Math.max(curStreakLen, res); } } return res; }; "},"medium/131.html":{"url":"medium/131.html","title":"131. Palindrome Partitioning(medium)","keywords":"","body":"131. Palindrome Partitioning Leetcode link 题目简介 /** * @param {string} s * @return {string[][]} */ 题目给我们一个字符串 s，要求我们把 s 切分成多个回文子字符串，并且返回所有可能的切分法 解题思路 借用 ally. 评论的图： 我们依然使用回溯的思路来做： 在每次回溯中，我们需要记录当前元素的下标，从当前下标开始遍历字符串 s 直到结束 如果遍历过程中发现了回文字符串，将其用数组 arr 保存起来，然后继续回溯下一个下标 Javascript /** * @param {string} s * @return {string[][]} */ var partition = function (s) { const res = [] const backtracking = (arr, idx) => { if (idx === s.length) { res.push([...arr]) return } for (let i = idx; i { while (left "},"medium/138.html":{"url":"medium/138.html","title":"138. Copy List with Random Pointer(medium)","keywords":"","body":"138. Copy List with Random Pointer Leetcode link 解题思路 题目要求我们对有两个指针的链表进行深拷贝，那么我们可以用三个 for 循环依次做以下三件事： 对于每一个链表节点，创建一个新的节点，把旧节点的值给新节点，把新节点的 next 指向旧节点的下一个节点，把旧节点的 next 指向新节点 对于每一个新节点，把新节点的 random 指针指向旧节点的 random 的 next（也就是旧节点的 random 指向的旧节点的新节点） 对于每一个新节点，把 next 指针指向自己的 next->next （也就是旧节点的 next 指向的节点的新节点） C++ class Solution { public: Node* copyRandomList(Node* head) { if (!head) { return NULL; } for (Node* node = head; node; node = node->next->next) { Node* newNode = new Node(node->val); newNode->next = node->next; node->next = newNode; } Node* headNode = head->next; for (Node* node = head; node; node = node->next->next) { Node* newNode = node->next; newNode->random = node->random == NULL ? NULL : node->random->next; } for (Node* node = head; node; node = node->next) { Node* newNode = node->next; node->next = newNode->next; newNode->next = node->next == NULL ? NULL : node->next->next; } return headNode; } }; Javascript var copyRandomList = function(head) { if (!head) { return null; } for (let node = head; node; node = node.next.next) { const newNode = new Node(node.val, node.next, null); node.next = newNode; } const headNode = head.next; for (let node = head; node; node = node.next.next) { const newNode = node.next; newNode.random = node.random === null ? null : node.random.next; } for (let node = head; node; node = node.next) { const newNode = node.next; node.next = newNode.next; newNode.next = node.next === null ? null : node.next.next; } return headNode; }; "},"medium/139.html":{"url":"medium/139.html","title":"139. Word Break(medium)","keywords":"","body":"139. Word Break Leetcode link 题目简介 /** * @param {string} s * @param {string[]} wordDict * @return {boolean} */ 题目给我们一个字符串 s 以及一个字符串数组 wordDict 要求我们判断是否可以从 wordDict 中取出字符串 word 拼成 s wordDict 中的字符串可以重复使用，但是不允许拆开 解题思路 我们先从字符串 s 入手，假设有 s = 'leetcode' ，且 wordDict 中的字符串可以拼成 s，我们有两种可能性需要讨论： wordDict = ['leetcode']，代表 wordDict 中的一个字符串等于 s wordDict = ['leet', 'code']，代表 wordDict 中的多个字符串加起来可以拼出 s 第一种情况很直觉，我们重点看第二种情况要怎么判断 首先我们需要遍历字符串 s，目的是判断每一个 s[0..i] 子字符串是否可以找到对应的 word 判断条件有三： i >= word.length：子字符串必须要大于 word，否则不能比较 s.substring(i-word.length+1, i+1) === word：我们要选出 s 字符串中等于 word 的子字符串与 word 比较 s[0...i-word.length] 这个子字符串必须已经能被其他 word 拼起来 为了判断第三点条件，我们需要使用 dp 的思路： 声明一个 dp 数组，长度为 s.length+1，默认赋值 false 设置 dp[0] = true 代表当字符串 s 长度为 0 的时候，结果是 true 遍历 s 中的子字符串，对每个子字符串遍历 wordDict 中的 word 如果有 i 满足以上三个条件，设置 dp[i] = true 最后返回 dp[s.length] Javascript /** * @param {string} s * @param {string[]} wordDict * @return {boolean} */ var wordBreak = function (s, wordDict) { const dp = new Array(s.length + 1).fill(false) dp[0] = true for (let i = 1; i = len && dp[i - len] && word === s.substring(i - len, i)) { dp[i] = true break; } } } return dp[s.length] }; "},"medium/142.html":{"url":"medium/142.html","title":"142. Linked List Cycle II(medium)","keywords":"","body":"142. Linked List Cycle II Leetcode link 题目简介 /** * @param {ListNode} head * @return {ListNode} */ 本题是 141 题的进阶版本，题目给我们一个链表头 head 要求我们找出链表中回路开始的节点，如果链表不存在回路则返回 null 解题思路 这题的解法分为两步： 通过快慢指针找到令指针相遇的节点 从 head 与相遇节点同时出发，直到两个指针相遇，相遇的节点就是回路开始的节点 为什么呢？ 对于每一个带回路的链表，我们可以把它们拆分成三个部分： A：从 head 到回路开始节点的部分 B：从回路开始节点到快慢指针相遇节点的部分 C：从快慢指针相遇节点到回路开始节点的部分 我们快慢指针的特点是，快指针前进速度是慢指针两倍 于是有了如下公式： 经过整理得： 于是我们得到了：从 head 到回路开始节点的部分 = 从快慢指针相遇节点到回路开始节点的部分 Javascript /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var detectCycle = function (head) { // step 1: we find a cycle let slow = head let fast = head while (fast && fast.next) { slow = slow.next fast = fast.next.next if (slow === fast) { // step 2: Moving from head and fast, the node where they meet is the target node slow = head while (slow !== fast) { slow = slow.next fast = fast.next } return fast } } return null }; "},"medium/146.html":{"url":"medium/146.html","title":"146. LRU Cache(medium)","keywords":"","body":"146. LRU Cache Leetcode link 题目简介 本题是一道系统设计的题目，要求我们实现一个最近最少使用缓存 LRU LRU 的初始化传入一个参数 capacity，声明此缓存的容量 LRU 支持两个方法： put 与 get 其中 put 支持插入/更新一个数据，这个数据会被标记为最新被使用数据，如果插入的数据超过了缓存数量，最久没有被使用的数据会被删除 get 支持读取当前缓存的特定值，被读取的会被标记为最新被使用数据，如果读取的数据不在缓存中则返回 -1 解题思路 由于题目要求我们 get 与 put 都需要 O(1) 的复杂度，所以我们可以用链表配合 map 来做 链表负责维护当前数据的新旧、map 用来判断当前数据是否存在，以及读取数据的值 具体而言，当一个数据越靠近链表头，我们认为它越久没有被使用；当一个数据越靠近链表尾，我们认为它上次被使用时间离现在越近 对于 get 方法来说有两种可能： get 的数据不存在缓存中：此时我们无需操作链表 get 的数据在缓存中：我们需要把链表对应到该数据的元素移动到链表尾 对于 put 方法来说，也有两种可能： 当前数据在缓存中，需要更新：此时与 get 的数据在缓存中的场景一致，需要把链表对应到该数据的元素移动到链表尾 当前数据不在缓存中，需要插入：此时我们需要创建一个链表元素，并放置在链表尾；需要注意的是，如果此时缓存容量超了，需要从链表头删除一个数据 总结一下，我们需要对链表进行两种操作： 删除链表中任意元素 添加元素到链表尾 为了让这两个操作复杂度最低，我们需要双向链表 Double-linked list Javascript class DLN { constructor(key, value) { this.key = key this.value = value this.prev = null this.next = null } } /** * @param {number} capacity */ var LRUCache = function (capacity) { this.capacity = capacity this.map = new Map() // head.next points to the least recent used node(the most possible removed node) this.head = new DLN() // tail.prev points to the last recent used node this.tail = new DLN() // we use 2 empty nodes to cover all nodes, so we can modify the link easily this.head.next = this.tail this.tail.prev = this.head }; /** * @param {number} key * @return {number} */ LRUCache.prototype.get = function (key) { if (!this.map.has(key)) { return -1 } const node = this.map.get(key) this.remove(node) this.add(node) return node.value }; /** * @param {number} key * @param {number} value * @return {void} */ LRUCache.prototype.put = function (key, value) { if (this.get(key) !== -1) { this.tail.prev.value = value return } if (this.map.size === this.capacity) { this.map.delete(this.head.next.key) this.remove(this.head.next) } const node = new DLN(key, value) this.map.set(key, node) this.add(node) }; // add the node too the tail of the link LRUCache.prototype.add = function (node) { const prevNode = this.tail.prev const nextNode = this.tail prevNode.next = node node.prev = prevNode node.next = this.tail this.tail.prev = node } // remove the node from the link LRUCache.prototype.remove = function (node) { node.next.prev = node.prev node.prev.next = node.next } /** * Your LRUCache object will be instantiated and called as such: * var obj = new LRUCache(capacity) * var param_1 = obj.get(key) * obj.put(key,value) */ "},"medium/151.html":{"url":"medium/151.html","title":"151. Reverse Words in a String(medium)","keywords":"","body":"151. Reverse Words in a String Leetcode link 题目简介 /** * @param {string} s * @return {string} */ 题目给我们一个字符串 s 要求我们把 s 中所有的单词反转，并且只保留每个单词中间的一个空格并返回 解题思路 一行代码解决 Javascript /** * @param {string} s * @return {string} */ var reverseWords = function(s) { return s.split(' ').filter(item => item.length > 0).reverse().join(' ') }; "},"medium/152.html":{"url":"medium/152.html","title":"152. Maximum Product Subarray(medium)","keywords":"","body":"152. Maximum Product Subarray Leetcode link 解题思路 题目要求我们求乘积最大的连续子数组。 我们需要三个变量： max：保留相乘之后的最大值 min：保留相乘之后的最小值（因为只要之后有负数，这一项可能会变成最大值） res：保留每次循环结束的最大值 算法步骤如下： 循环数组，将数组的元素分别与 max，min 相乘 比较 max，min，数组元素本身，将其中最大值赋值给 max（记得把原来的 max 保存成 temp） 比较 temp，min，数组元素本身，将其中最小值赋值给 min 比较 max 与 res ，将其中最大值赋值给 res 继续步骤 1 直到循环结束 C++ class Solution { public: int maxProduct(vector& nums) { int maximum = 1, minmum = 1, res = nums[0]; for (int num : nums) { maximum *= num; minmum *= num; int temp = maximum; maximum = max({maximum, minmum, num}); minmum = min({temp, minmum, num}); res = res > maximum ? res : maximum; } return res; } }; Javascript var maxProduct = function(nums) { let max = 1, min = 1, res = nums[0]; for(const num of nums) { max *= num; min *= num; // 保存起来，不然有可能本来 max 是最小值最后呗下一行更改了 let temp = max; max = Math.max(max, min, num); min = Math.min(temp, min, num); res = max > res ? max : res; } return res; }; "},"medium/153.html":{"url":"medium/153.html","title":"153. Find Minimum in Rotated Sorted Array(medium)","keywords":"","body":"153. Find Minimum in Rotated Sorted Array Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个升序排序后向右旋转 n 位的数字数组 nums 要求我们在 O(log n) 的事件复杂度内找出数组最小的元素 解题思路 一看到 log n 就知道需要使用二分搜索了 这题有点像 33. Search in Rotated Sorted Array 我们可以用类似思路来求解： 如果 nums[mid] > nums[left] 代表 mid 的左边是升序排列 如果 nums[mid] 代表 mid 的右边是升序排列 此外，我们需要一个变量 min 来记录当前遇到的最小元素，并在每次赋值前比较 Javascript /** * @param {number[]} nums * @return {number} */ var findMin = function(nums) { let left = 0 let right = nums.length - 1 let min = Number.MAX_SAFE_INTEGER while(left "},"medium/155.html":{"url":"medium/155.html","title":"155. Min Stack(medium)","keywords":"","body":"155. Min Stack Leetcode link 题目简介 var MinStack = function() {}; /** * @param {number} val * @return {void} */ MinStack.prototype.push = function(val) {}; /** * @return {void} */ MinStack.prototype.pop = function() {}; /** * @return {number} */ MinStack.prototype.top = function() {}; /** * @return {number} */ MinStack.prototype.getMin = function() {}; 题目要求我们实现一个 MinStack 数据结构 除了常规的 push pop top 之外，还需要能在 O(1) 的复杂度下取得当前 stack 中的最小值 解题思路 我们在入栈的时候，将当前栈中的最小元素值与入栈元素一起入栈 当我们需要查找最小值的时候，只需要去栈顶元素中找到最小值返回即可 Javascript var MinStack = function () { this.stack = [] }; /** * @param {number} val * @return {void} */ MinStack.prototype.push = function (val) { const min = this.getMin() if (min === null || min > val) { this.stack.push([val, val]) } else { this.stack.push([val, min]) } }; /** * @return {void} */ MinStack.prototype.pop = function () { this.stack.pop() }; /** * @return {number} */ MinStack.prototype.top = function () { return this.stack.length ? this.stack[this.stack.length - 1][0] : null }; /** * @return {number} */ MinStack.prototype.getMin = function () { return this.stack.length ? this.stack[this.stack.length - 1][1] : null }; /** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(val) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */ "},"medium/165.html":{"url":"medium/165.html","title":"165. Compare Version Numbers(medium)","keywords":"","body":"165. Compare Version Numbers Leetcode link 题目简介 题目要求我们对比两个只由数字跟 . 构成的版本号 要求从左到右，并忽略小版本号前面的 0 如果 version1 返回 -1 如果 version1 > version2 返回 1 如果 version1 === version2 返回 0 解题思路 我们只需要用 split 将 version 拆分成数组，然后把数组的元素从字符串转换成 number 之后遍历比较就好 Javascript /** * @param {string} version1 * @param {string} version2 * @return {number} */ var compareVersion = function(version1, version2) { const ver1Arr = version1.split('.').map(item => Number(item)) const ver2Arr = version2.split('.').map(item => Number(item)) const ver1Len = ver1Arr.length const ver2Len = ver2Arr.length for(let i=0;i= ver1Len ? 0 : ver1Arr[i] const ver2Val = i >= ver2Len ? 0 : ver2Arr[i] if(ver1Val > ver2Val) { return 1 } if(ver1Val "},"medium/166.html":{"url":"medium/166.html","title":"166. Fraction to Recurring Decimal(medium)","keywords":"","body":"166. Fraction to Recurring Decimal Leetcode link 题目简介 这是道数学相关的题，题目给了分子 numerator 与分母 denominator 两个参数，要求我们返回其小数的表达方式 如果该小数是循环小数，则需要用 () 将循环的部份包裹住 此外题目确保了不会出现无限不循环小数 解题思路 想要解这道题我们需要回归除法的计算方法： 将分子除以分母，获得商与余 如果没有余数，则答案就是商，如果有余数，将答案添加一个小数点，然后余数 *10， 继续除 直到余数为 0 这道题我们也可以用这个思路，区别在于我们需要考虑其他场景： 是否分子有 0 是否两者相除为负数 如何判断出现循环 前两者都好判断，后者的话我们需要用一个 Map 来记录曾经出现过的余数，以及余数除后的商的位置 当我们后续出现了相同的余数，就等于出现了循环，此时我们只需要在之前记录的位置以及当前最后位置加上 () 就好 Javascript /** * @param {number} numerator * @param {number} denominator * @return {string} */ var fractionToDecimal = function (numerator, denominator) { if (numerator === 0) { return '0' } const res = [] // handle negative sign if (numerator "},"medium/167.html":{"url":"medium/167.html","title":"167. Two Sum II - Input Array Is Sorted(medium)","keywords":"","body":"167. Two Sum II - Input Array Is Sorted Leetcode link 解题思路 题目要求我们从一个排序好的数组中找出唯一的两个元素使得相加为 target 因为数组是排序好的，且答案有唯一性，我们可以考虑用双指针来求解 具体来说，我们可以用两个指针 left 与 right 分别指向数组的开头与结尾 当两个指针所指元素之和小于 target，则 left++ 当两个指针所指元素之和大于 target，则 right-- 如果两个指针元素之和等于 target，直接返回 [left + 1, right + 1] C++ class Solution { public: vector twoSum(vector& numbers, int target) { int left = 0, right = numbers.size() - 1; while(left target) { right--; } } return {-1, -1}; } }; Javascript var twoSum = function(numbers, target) { let left = 0, right = numbers.length - 1; while(left target) { right--; } else if(sum "},"medium/173.html":{"url":"medium/173.html","title":"173. Binary Search Tree Iterator(medium)","keywords":"","body":"173. Binary Search Tree Iterator Leetcode link 解题思路 题目给我们一个 BST 的根节点，要求我们写一个能够中序遍历的迭代器。 在没看到题目最后一行要求 O(1) 时间复杂度与 O(h) 空间复杂度的时候，我想的是直接一个先进先出队列加一个中序遍历搞定。 但是限制了空间复杂度之后就只能用折中的方法了： 构造一个方法 particalInorder，依次保存当前节点的最左边枝干 在构造函数调用上述方法 然后在每次 next 执行的时候尝试用当前节点的右节点调用上述方法 hasNext 执行的时候只要判断保存枝干的栈是否为空就好 如此一来，保存枝干的栈就不需要一次把全部的节点都保存进去了。 C++ class BSTIterator { private: // 用来保存枝干的栈 stack s; // 每次只保存最左边的枝干 void partialInorder(TreeNode* node) { while (node != nullptr) { s.push(node); node = node->left; } } public: BSTIterator(TreeNode* root) { partialInorder(root); } int next() { TreeNode* res = s.top(); s.pop(); // 保存当前节点的右节点的左枝干 partialInorder(res->right); return res->val; } bool hasNext() { return !s.empty(); } }; Javascript var BSTIterator = function(root) { this.partialInorder(root) }; /** * @return {number} */ BSTIterator.prototype.next = function() { let res = this.stack.pop(); // 保存当前节点的右节点的左枝干 this.partialInorder(res.right); return res.val; }; /** * @return {boolean} */ BSTIterator.prototype.hasNext = function() { return this.stack.length !== 0; }; // 用来保存当前节点的左枝干 BSTIterator.prototype.partialInorder = function(node) { while(node) { this.stack.push(node); node = node.left; } }; // 用一个栈来保存枝干 BSTIterator.prototype.stack = [] "},"medium/189.html":{"url":"medium/189.html","title":"189. Rotate Array(medium)","keywords":"","body":"189. Rotate Array Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {void} Do not return anything, modify nums in-place instead. */ 题目给我们一个数字数组 nums 以及一个数字 k 要求我们在本地旋转 nums 的元素 k 次，每次旋转一位 解题思路 我们以 nums = [1,2,3,4,5,6,7], k = 3 为例 我们只需要分成三步： 把整个数组反转：nums = [7,6,5,4,3,2,1] 把 0~k-1 反转：nums = [5,6,7,4,3,2,1] 把 k~nums.length-1 反转：nums = [5,6,7,1,2,3,4] 完成～ Javascript /** * @param {number[]} nums * @param {number} k * @return {void} Do not return anything, modify nums in-place instead. */ var rotate = function(nums, k) { const len = nums.length k = k % len if(k === 0) { return } const reverse = (left, right) => { while(left "},"medium/198.html":{"url":"medium/198.html","title":"198. House Robber(medium)","keywords":"","body":"198. House Robber Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 这题很有意思，题目给我们一个数组 nums 表示一排街区每个房子能偷到的钱 如果我们连续偷了相邻的两个房子，会触发报警 题目要求我们在不触发报警的情况下，一晚上最多能偷到多少钱 解题思路 我们假设只有一间房子，我们必须偷，且偷到的钱为 nums[0] 假设有两间房子，我们要选择钱多的偷，偷到的钱为 max(nums[0], nums[1]) 假设有三间房子，我们需要判断第三间偷不偷，此时有两种情况： 偷：此时收益为 num[0] + num[2]（我们会错过第二间房子的收益） 不偷：此时收益为 num[1]（我们只能偷第 2 间） 两种情况我们需要取最大值：max(num[0] + num[2], num[1]) 我们可以用数组 dp 来保存偷到当前房子的最大收入，dp 的状态转移方程为： dp[i] = max(dp[i-2] + num[i], dp[i-1]) 起始状态为： dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) Javascript /** * @param {number[]} nums * @return {number} */ var rob = function (nums) { const len = nums.length const dp = new Array(len).fill(0) dp[0] = nums[0] dp[1] = Math.max(nums[0], nums[1]) for (let i = 2; i "},"medium/199.html":{"url":"medium/199.html","title":"199. Binary Tree Right Side View(medium)","keywords":"","body":"199. Binary Tree Right Side View Leetcode link 题目简介 /** * @param {TreeNode} root * @return {number[]} */ 题目给我们一个二叉树的根节点 root 要求我们寻找二叉树从右边观看的时候能看到的节点元素值，并且将其放入数组中返回 解题思路 本题的核心思路是，当我们遍历到新的一层的时候，要把该层最右边的节点放入数组 遍历的方法可以用 DFS 与 BFS，我们使用 DFS 进行 根节点 -> 右子树 -> 左子树 的顺序遍历 此外，我们用一个 maxHeight 变量来记录当前我们达到的最深的层 如果当前遍历的层数大于 maxHeight，我们认为到了一个新的层，此时我们把当前元素入栈（因为遍历顺序保证了当前元素必定是当前层最右边的元素） Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var rightSideView = function (root) { if (!root) { return [] } const res = [] let maxHeight = 0 const dfs = (node, height) => { if (!node) { return } if (height > maxHeight) { res.push(node.val) maxHeight = height } dfs(node.right, height + 1) dfs(node.left, height + 1) } dfs(root, 1) return res }; "},"medium/200.html":{"url":"medium/200.html","title":"200. Number of Islands(medium)","keywords":"","body":"200. Number of Islands Leetcode link 题目简介 /** * @param {character[][]} grid * @return {number} */ 题目给我们一个二位数组 grid，其中元素如果为 1 表示该元素为陆地；为 0 则表示该元素为海洋 题目要求我们计算 grid 中包含有多少岛屿 岛屿的定义：上下左右四个方位都是海洋的陆地的集合 解题思路 我们需要一个二位数组 visited 来保存我们访问过的陆地 此外，当我们遍历一块陆地的时候，我们使用广度优先搜索 bfs 来遍历所有同一个岛屿的陆地，期间要更新 visited 我们通过遍历所有 grid 的元素，来判断是否有我们未访问过的陆地，如果有则岛屿数量+1 Javascript /** * @param {character[][]} grid * @return {number} */ var numIslands = function (grid) { const width = grid[0].length const height = grid.length const visited = Array.from({ length: height }, _ => new Array(width).fill(false)) const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]] let res = 0 const bfs = (row, col) => { visited[row][col] = true const queue = [[row, col]] while(queue.length > 0) { const location = queue.shift() for(const dir of dirs) { const newRow = location[0] + dir[0] const newCol = location[1] + dir[1] if(newRow>=0 && newRow =0 && newCol "},"medium/207.html":{"url":"medium/207.html","title":"207. Course Schedule(medium)","keywords":"","body":"207. Course Schedule Leetcode link 题目简介 /** * @param {number} numCourses * @param {number[][]} prerequisites * @return {boolean} */ 题目给我们一个数字 numCourses 表示当前有从 0 到 numCourses - 1 共 numCourses 门课程 以及一个数组 prerequisites，其中有多个 [a, b] 组合，表示想上 a 课程必须先上 b 题目要求我们返回是否能在 prerequisites 的约束下学完所有课程 解题思路 我们考虑两种情况： // 1. 同一路径下出现循环 a -> b -> c -> a // 2. 同一路径下没有循环 a -> b -> c a -> d -> c 综上，我们知道要满足不能学完所有课程的条件就是在当前的学习路径上存在循环 所以，我们可以设计一套深度遍历机制，来模拟不同的合法学习路径并且记录路径中学习的课程 如果在该路径中出现过的课程又出现了，表示存在循环，不可能学习完所有课程 反之如果我们遍历完所有的课程后都没有循环，则表示可以学习完所有课程 Javascript /** * @param {number} numCourses * @param {number[][]} prerequisites * @return {boolean} */ var canFinish = function (numCourses, prerequisites) { // Saves all courses that can only be taken after completing the current course const arr = Array.from({ length: numCourses }, _ => new Array()) for (const [course, prerequisite] of prerequisites) { arr[prerequisite].push(course) } const finished = new Array(numCourses).fill(false) // return if there is a cycle const dfs = (course, path) => { finished[course] = true path.push(course) for (const nextCourse of arr[course]) { if (!finished[nextCourse]) { if (dfs(nextCourse, path)) { return true } } else if(path.includes(nextCourse)) { return true } } path.pop() return false } for (let i = 0; i "},"medium/208.html":{"url":"medium/208.html","title":"208. Implement Trie (Prefix Tree)(medium)","keywords":"","body":"208. Implement Trie (Prefix Tree) Leetcode link 题目简介 var Trie = function() {}; /** * @param {string} word * @return {void} */ Trie.prototype.insert = function(word) {}; /** * @param {string} word * @return {boolean} */ Trie.prototype.search = function(word) {}; /** * @param {string} prefix * @return {boolean} */ Trie.prototype.startsWith = function(prefix) {}; 这题要求我们自己构造一个 字典树 并完成 insert，search，startsWith 三个方法的设计 解题思路 字典树的根节点一般是空节点，而且每一个节点只会存储字符串的其中一个字符 每个节点中会包含两种信息： 下一个字符的信息，有两种存储方式：一个长度为 26 的数组、Map 当前节点是否为某个字符串的最后一个字符节点 因为题目测试量小，用数组容易造成空间浪费，所以我们选择 Map，最后一个节点的标识符我们用布尔值 isEnd 来表示 Javascript class TrieNode { constructor() { this.children = new Map() this.isEnd = false } } var Trie = function () { this.root = new TrieNode() }; /** * @param {string} word * @return {void} */ Trie.prototype.insert = function (word) { let cur = this.root for (const char of word) { if (!cur.children.has(char)) { cur.children.set(char, new TrieNode()) } cur = cur.children.get(char) } cur.isEnd = true }; /** * @param {string} word * @return {boolean} */ Trie.prototype.search = function (word) { let cur = this.root for (const char of word) { if (cur.children.has(char)) { cur = cur.children.get(char) } else { return false } } return cur.isEnd }; /** * @param {string} prefix * @return {boolean} */ Trie.prototype.startsWith = function (prefix) { let cur = this.root for (const char of prefix) { if (cur.children.has(char)) { cur = cur.children.get(char) } else { return false } } return true }; "},"medium/215.html":{"url":"medium/215.html","title":"215. Kth Largest Element in an Array(medium)","keywords":"","body":"215. Kth Largest Element in an Array Leetcode link 解题思路 本题要求我们求出一个数组中第 k 大的数字 一个最简单的方法当然是排序后直接返回下标为 k-1 的数字，但是这样时间复杂度就来到了 O(nlogn) 总所皆知，排序算法在某些情况下是可以来到 O(n) 的复杂度的，那我们有没有办法根据题目的限制来缩小计算范围呢？ 答案是肯定的，我们可以使用快速排序的思想来求解： 快速排序（降序版本）的优点在于，每一次的排序总能确定选中那个数字的排序后下标，且每次排序后，该数字左边必比它大；右边必比它小 套用到这一题，我们只要当快速排序选中的下标刚好等于 k-1 就符合要求了，剩下的部分不需要计算 就算运气不好选中的下标不是 k-1，我们也可以快速定位到下一次快排的范围，进而加速整个算法 C++ class Solution { public: int findKthLargest(vector& nums, int k) { return quickSelect(nums, 0, nums.size()-1, k - 1); } int quickSelect(vector& nums, int left, int right, int index) { // 每次快排结束后检查一下下表是否是 k-1 int position = partition(nums, left, right); if(position == index) { return nums[position]; }else { // 如果不是则可以选取对应的下标范围再做快排 return index & nums, int left, int right) { int num = nums[left]; int i = left + 1; for(int j=left + 1;j num) { swap(nums[i++], nums[j]); } } swap(nums[left], nums[i - 1]); return i-1; } }; Javascript var findKthLargest = function(nums, k) { return quickSelect(nums, 0, nums.length - 1, k - 1); }; var quickSelect = function(nums, left, right, index){ let position = partition(nums, left, right); if(index === position) { return nums[position]; } else { return index > position ? quickSelect(nums, position + 1, right, index) : quickSelect(nums, left, position - 1, index); } } var partition = function(nums, left, right){ let num = nums[left]; let i = left + 1; for(let j = left + 1;j num) { [nums[i], nums[j]] = [nums[j], nums[i]]; i++; } } [nums[left], nums[i - 1]] = [nums[i - 1], nums[left]]; return i-1; } "},"medium/216.html":{"url":"medium/216.html","title":"216. Combination Sum III(medium)","keywords":"","body":"216. Combination Sum III Leetcode link 解题思路 这道题要求我们求 k 个不重复的 1～9 所有可能组合成数字 n 的组合 这种题目我们可以用回溯的方式来做，直接上代码 C++ class Solution { public: vector> res; int k; int n; vector> combinationSum3(int k, int n) { this->k = k; this->n = n; combination(1, {}, 0); return res; } void combination(int start, vector arr, int sum) { if(arr.size()== k) { if(sum == n) { res.push_back(arr); } return; } for(int i = start;i Javascript var combinationSum3 = function(k, n) { let res =[]; var combination = function(start, arr, sum) { // 如果当前组合的数组长度恰好符合 k 个 if(arr.length === k) { // 数组恰好是所求的一种组合 if(sum === n) { res.push(arr); } return; } for(let i= start;i "},"medium/230.html":{"url":"medium/230.html","title":"230. Kth Smallest Element in a BST(medium)","keywords":"","body":"230. Kth Smallest Element in a BST Leetcode link 解题思路 求第 k 小的 BST，核心思路还是在于用中序的优先遍历，当找到第 k 个元素的时候，就是第 k 小的元素 C++ class Solution { private: // 题目规范 BST 元素最小是 0 int res = -1; public: void dfs(TreeNode* node, int& k) { // k left, k); // 找到第 k 小的数之后直接返回 if (--k == 0) { res = node->val; return; } dfs(node->right, k); } int kthSmallest(TreeNode* root, int k) { dfs(root, k); return res; } }; Javascript var kthSmallest = function(root, k) { let res = -1; let count = 0 const dfs = (node, k) => { // count > k 是为了剪枝 if (!node || count > k) { return; } dfs(node.left, k); // 当找到第 k 小的数直接返回 if (++count == k) { res = node.val; return; } dfs(node.right, k); } dfs(root, k); return res; }; "},"medium/236.html":{"url":"medium/236.html","title":"236. Lowest Common Ancestor of a Binary Tree(medium)","keywords":"","body":"236. Lowest Common Ancestor of a Binary Tree Leetcode link 题目简介 /** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} */ 本题给我们一颗二叉树的根节点 root 以及两个树中的元素 p 与 q 题目要求我们找到并返回 p 与 q 的最小公共祖先节点 LCA 解题思路 要找 LCA，我们一般使用 DFS 来寻找 我们需要在找到 p 跟 q 的时候把这个信息 “向上传递” 第一个同时接收到 p 跟 q 信息的节点就是两者的 LCA Javascript /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} */ var lowestCommonAncestor = function(root, p, q) { if(!root || root === p || root === q){ return root } const left = lowestCommonAncestor(root.left, p, q) const right = lowestCommonAncestor(root.right, p, q) if(left && right) { return root } return left || right }; "},"medium/238.html":{"url":"medium/238.html","title":"238. Product of Array Except Self(medium)","keywords":"","body":"238. Product of Array Except Self Leetcode link 题目简介 (Add problem description here) 解题思路 (Add your solution approach here) Javascript (Add your solution code here) "},"medium/240.html":{"url":"medium/240.html","title":"240. Search a 2D Matrix II(medium)","keywords":"","body":"240. Search a 2D Matrix II Leetcode link 题目简介 /** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ 题目要求我们判断在 matrix 中是否能找到 target，如果可以返回 true，否则返回 false matrix 的有两个特点： 所有的行都是从左到右升序排列 所有的列都是从上到下升序排列 解题思路 这题一开始我习惯性的从左上角出发，发现要判断的情况很多 但是这题需要我们跳出习惯，需要从右上角出发 这样一来，如果当前元素比 target 小，我们只需要向下找元素；如果当前元素比 target 大，我们只需要向左找元素 Javascript /** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ var searchMatrix = function(matrix, target) { const height = matrix.length const width = matrix[0].length let row = 0 let col = width - 1 while(row =0) { if(matrix[row][col] === target) { return true } if(matrix[row][col] "},"medium/279.html":{"url":"medium/279.html","title":"279. Perfect Squares(medium)","keywords":"","body":"279. Perfect Squares Leetcode link 题目简介 /** * @param {number} n * @return {number} */ 题目给我们一个数字 n 要求我们求出 n 最少可以用多少个平方数之和来表示 平方数代表可以开根号为整数的数 解题思路 这题可以分成两个部分： 首先找出所有小于等于 n 的平方数，把这些平方数的值当成一个个硬币 用 322 题的思路来解 我们可以用一个数组 dp 来保存当前数字所需要用到的 “硬币” 数量，其状态转移方程为： dp[i] = min(dp[i], dp[i-numSquare] + 1) 如果选择了 dp[i] 代表我们不用这个硬币 如果选择了 dp[i-numSquare] + 1 代表我们使用这个硬币 初始条件为 dp[0] = 0 如果数字为 0，我们不需要任何硬币 我们通过 i 从 1 到 n 的遍历就可以求出我们最少需要多少个 “硬币” 了 Javascript /** * @param {number} n * @return {number} */ var numSquares = function (n) { const dp = new Array(n + 1).fill(Number.MAX_SAFE_INTEGER) dp[0] = 0 for (let i = 1; i "},"medium/284.html":{"url":"medium/284.html","title":"284. Peeking Iterator(medium)","keywords":"","body":"284. Peeking Iterator Leetcode link 解题思路 题目要求我们实现一个可以 peek 的 PeekingIterator。通过继承了一个 Iterator，我们可以使用它的 next 与 hasNext 方法。 为此我们可以用两个变量 nextNum 和 hasNextNum 分别记录当前的对象状态。 这样子 peek 与 hasNext 方法只要直接返回变量即可。 在构造函数与 next 方法中，我们只需要对这两个变量进行单独维护就好。 C++ class PeekingIterator : public Iterator { private: int nextNum; bool hasNextNum; public: PeekingIterator(const vector& nums) : Iterator(nums) { hasNextNum = Iterator::hasNext(); if (hasNextNum) { nextNum = Iterator::next(); } } // Returns the next element in the iteration without advancing the iterator. int peek() { return nextNum; } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. int next() { // preserve current result int res = nextNum; hasNextNum = Iterator::hasNext(); if (hasNextNum) { nextNum = Iterator::next(); } return res; } bool hasNext() const { return hasNextNum; } }; Javascript var PeekingIterator = function(iterator) { this.hasNextNum = iterator.hasNext(); if(this.hasNextNum) { this.nextNum = iterator.next(); } // 保存起来之后 next 需要用到 this.iterator = iterator; }; /** * @return {number} */ PeekingIterator.prototype.peek = function() { return this.nextNum; }; /** * @return {number} */ PeekingIterator.prototype.next = function() { let res = this.nextNum; this.hasNextNum = this.iterator.hasNext(); if(this.hasNextNum) { this.nextNum = this.iterator.next(); } return res; }; /** * @return {boolean} */ PeekingIterator.prototype.hasNext = function() { return this.hasNextNum; }; "},"medium/287.html":{"url":"medium/287.html","title":"287. Find the Duplicate Number(medium)","keywords":"","body":"287. Find the Duplicate Number Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums，其中所有数字都在 [1, n] 的范围内，其中 n === nums.length - 1 这意味着必定有一个数字是重复的，题目要求我们在 O(1) 空间复杂度与 O(n) 时间复杂度下找出这个重复的数字 解题思路 这题有两个思路，一个是类似 141 一样，用负号标识已经出现过的数字；一个是类似 142 一样，把数组当成有环的有向图并找出环的开始节点，下面我们分别讲解 用负号标识已经出现过的数字 这个方法的核心就是，在遍历数组过程中，把遍历当前元素作为下标，找到对应元素并把对应元素置为负数 如果我们遍历其他元素并以元素作为下标找到的对应元素为负，我们就知道当前元素是重复的数字了 Javascript /** * @param {number[]} nums * @return {number} */ var findDuplicate = function(nums) { for(let i=0;i 把数组当成有环的有向图并找出环的开始节点 我们延续上一个解法把元素本身当成下标的想法，如果我们把数组的元素当成有向图的节点，节点的值当成他们指向的下一个节点，我们就可以获得一个有向图 由于题目保证有重复的节点，所以构成的有向图必有环，且环的开始节点下标，就是重复的数字 至此，我们可以用 142 的思路来找出环的开始节点 Javascript /** * @param {number[]} nums * @return {number} */ var findDuplicate = function (nums) { const len = nums.length let fast = 0 let slow = 0 while(fast "},"medium/289.html":{"url":"medium/289.html","title":"289. Game of Life(medium)","keywords":"","body":"289. Game of Life Leetcode link 解题思路 本题非常有意思，我特别去找了一下还有对应的游戏，可以迭代出很多有意思的图案，感兴趣的同学可以玩玩看&#x1F606; 本题的难点在于如何在不构造另一个数组的情况下“同步”改变细胞的状态。 突破点在于构造出包含上一代信息的“伪状态”，考虑到题目给出的 int 数组只用了 1 个 bit，我们约定有如下的状态： 第 0 位表示当前的状态，第1位表示下一代的状态（注意这里是 bits） 00: 现在是死的，下一代还是死的 01: 现在是活的，下一代死了 10: 现在是死的，下一代活了 11: 现在是活的，下一代还是活的 接下来我们就遍历数组，把元素与 1 相与 & 就可以得到当前状态，把元素跟 2 相或 | 就可以记录下一代的状态（如果下一代死了就不用管，因为本来就是 0） 最后记得把所有元素右移 >> 一位就能得到下一代的状态了 C++ class Solution { public: // 计算当前活着的邻居 int countLifeNeighbor(vector>& board, int row, int col) { int count = 0; // ↖️ count += (row == 0 || col == 0) ? 0 : board[row - 1][col - 1] & 1; // ⬆️ count += (row == 0) ? 0 : board[row - 1][col] & 1; // ↗️ count += (row == 0 || col == board[0].size() - 1) ? 0 : board[row - 1][col + 1] & 1; // ⬅️ count += (col == 0) ? 0 : board[row][col - 1] & 1; // ➡️ count += (col == board[0].size() - 1) ? 0 : board[row][col + 1] & 1; // ↙️ count += (row == board.size() - 1 || col == 0) ? 0 : board[row + 1][col - 1] & 1; // ⬇️ count += (row == board.size() - 1) ? 0 : board[row + 1][col] & 1; // ↘️ count += (row == board.size() - 1 || col == board[0].size() - 1) ? 0 : board[row + 1][col + 1] & 1; return count; } void gameOfLife(vector>& board) { for (int row = 0; row >= 1; } } } }; Javascript /** * @param {number[][]} board * @return {void} Do not return anything, modify board in-place instead. */ var gameOfLife = function (board) { for (let row = 0; row >= 1; } } }; // 计算当前活着的邻居 function countLifeNeighbor(board, row, col) { let count = 0; // ↖️ count += row === 0 || col === 0 ? 0 : board[row - 1][col - 1] & 1; // ⬆️ count += row === 0 ? 0 : board[row - 1][col] & 1; // ↗️ count += row === 0 || col === board[0].length - 1 ? 0 : board[row - 1][col + 1] & 1; // ⬅️ count += col === 0 ? 0 : board[row][col - 1] & 1; // ➡️ count += col === board[0].length - 1 ? 0 : board[row][col + 1] & 1; // ↙️ count += row === board.length - 1 || col === 0 ? 0 : board[row + 1][col - 1] & 1; // ⬇️ count += row === board.length - 1 ? 0 : board[row + 1][col] & 1; // ↘️ count += row === board.length - 1 || col === board[0].length - 1 ? 0 : board[row + 1][col + 1] & 1; return count; } "},"medium/300.html":{"url":"medium/300.html","title":"300. Longest Increasing Subsequence(medium)","keywords":"","body":"300. Longest Increasing Subsequence Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums 要求我们返回 nums 中能组成最长升序数组的元素个数 解题思路 我们可以用一个数组 dp 来保存最长的升序数组元素个数（dp[i] 代表 nums[0..i] 最长的升序数组元素个数） 我们要针对 nums 中的每一个元素 num 来更新 dp 数组的对应值 具体来说，当遍历到 nums[i] 时，我们需要找出 nums[0...i] 中小于 nums[i] 且对应 dp 最大的值+1 赋值给 dp[i] 最后，我们要在 dp 数组中找到最大值返回 Javascript /** * @param {number[]} nums * @return {number} */ var lengthOfLIS = function (nums) { const len = nums.length // dp[i]: record longest increasing subsequence's length from nums[0] to nums[i] const dp = new Array(len).fill(1) for (let i = 1; i "},"medium/304.html":{"url":"medium/304.html","title":"304. Range Sum Query 2D - Immutable(medium)","keywords":"","body":"304. Range Sum Query 2D - Immutable Leetcode link 解题思路 本题要求我们实现一个类，这个类包含一个构造函数以及方法 构造函数接收一个二维数组，共有 m * n 个元素，而方法接收二维数组的两个坐标并返回两个坐标构成的矩形内部的元素之和 题目除了核心的方法之外还让我们实现了构造函数，不难看出如果我们善加利用的话，可以显著减少每一次的计算元素和的复杂度 我们考虑构建一个新的二维数组 sum，数组的元素有 (m+1) * (n+1) 个，sum[i][j] 代表从 (0, 0) 到 (i, j) 的元素之和 有了数组 sum 之后，我们不难发现要求下图红色部分面积可以看成：全部着色区块 - 绿色区块 - 蓝色区块 + 蓝色绿色重叠区块 也就是：sum[4][4] - sum[4][2] - sum[2][4] + sum[2][2] C++ class NumMatrix { public: vector> sum; NumMatrix(vector>& matrix) { int m = matrix.size(); int n = matrix[0].size(); sum = vector>(m+1, vector(n+1, 0)); for(int i=1;i Javascript /** * @param {number[][]} matrix */ var NumMatrix = function(matrix) { let m = matrix.length; let n = matrix[0].length; this.sum = new Array(m+1); for(let i=0;i "},"medium/318.html":{"url":"medium/318.html","title":"318. Maximum Product of Word Lengths(medium)","keywords":"","body":"318. Maximum Product of Word Lengths Leetcode link 解题思路 题目要求我们在一个字符串数组中找出字符完全不同的两个字符串使其长度乘积最大 这个题目的难点分为两个部分： 比较两个字符串是否有相同字符 找出符合条件的字符串中乘积最大的答案 比较两个字符串是否有相同字符 因为字符串之可能是英文的小写字母，所以我们可以用一个 int 长度的空间来放它的位掩码，位掩码从右到左依次代表 a 到 z，如果位掩码为 1 则表示该字符有出现 举个例子：abd 可以认为是 1011，aadddef 可以认为是 111001 一旦我们建立了所有字符串的位掩码，就可以通过两两相与是否大于 0 来判断是否有相同字符了 找出符合条件的字符串中乘积最大的答案 这个问题我们直接简单的双重循环来做比较，另外维护一个 res 变量保存最大结果 C++ class Solution { public: int maxProduct(vector& words) { vector bitMasks; for(string &word:words) { int bitMask = 0; for(char &c:word) { bitMask |= 1 0) { continue; } int product = words[i].size() * words[j].size(); res = max(product, res); } } return res; } }; "},"medium/322.html":{"url":"medium/322.html","title":"322. Coin Change(medium)","keywords":"","body":"322. Coin Change Leetcode link 解题思路 题目要求我们计算给出的硬币能构成指定金额的最小数量 这种求极值的问题非常适合用动态规划来求解 我们可以构造一个有 amount + 1 个元素的数组 dp，表示构成 0 ~ amount 金额的最小硬币个数 至于状态转移方程，我们考虑到有一个金额 i，我们可以通过遍历硬币的种类来更新 dp[i] 更新的思路是这样的，当我们遇到一个硬币的金额 coin 小于 i 的时候，i 有两种可能： 不用这个硬币，也就是 dp[i] = dp[i] 用这个硬币，也就是 dp[i] = dp[i - coin] + 1 题目要求我们求最小个数，所以状态转移方程就是 dp[i] = min(dp[i], dp[i - coin] + 1) 最后，我们把 1 ~ amount 金额全部遍历一遍更新 dp 就好了 C++ class Solution { public: int coinChange(vector& coins, int amount) { vector dp(amount+1, amount+1); dp[0] = 0; for(int i=1;i= coin) { dp[i] = min(dp[i], dp[i-coin] + 1); } } } return dp[amount] > amount ? -1 : dp[amount]; } }; Javascript /** * @param {number[]} coins * @param {number} amount * @return {number} */ var coinChange = function(coins, amount) { let dp = new Array(amount+1).fill(amount+1); dp[0] = 0; for(let i = 1;i amount ? -1 : dp[amount]; }; "},"medium/328.html":{"url":"medium/328.html","title":"328. Odd Even Linked List(medium)","keywords":"","body":"328. Odd Even Linked List Leetcode link 题目简介 /** * @param {ListNode} head * @return {ListNode} */ 题目给我们一个链表头 head 要求我们重新连接链表，把链表的奇数位置的元素往前移；把链表偶数位置的元素往后移 最后返回链表头 解题思路 为了解决这个问题，我们需要两个指针 odd、even 分别指向奇数位置的元素与偶数元素的位置 此外，还需要一个固定的指针 evenHead 来指向一开始的偶数元素位置 接下来我们的思路是，循环遍历整个链表，在每次循环中，我们要进行如下操作： 把 odd.next 指向 even.next 把 odd 更新为 odd.next 把 even.next 指向 odd.next 把 even 更新为 even.next 循环结束的条件是 even 指针或者 even.next 指向了 null，代表我们遍历到了链表的末尾 最后我们需要把 odd.next 指向一开始保存的 evenHead，把两个链表结合起来 Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var oddEvenList = function(head) { if(!head || !head.next) { return head } let odd = head let even = head.next const evenHead = even while(even && even.next) { odd.next = even.next odd = odd.next even.next = odd.next even = even.next } odd.next = evenHead return head }; "},"medium/334.html":{"url":"medium/334.html","title":"334. Increasing Triplet Subsequence(medium)","keywords":"","body":"334. Increasing Triplet Subsequence Leetcode link 题目简介 /** * @param {number[]} nums * @return {boolean} */ 本题要求我们在数组 nums 中找出三元组 (i, j, k) 使得 i 以及 nums[i] 如果有符合条件的三元组则返回 true，否则返回 false 解题思路 这题的核心思路是贪心思想：在遍历过程中随时记录第一小与第二小的数字，如果我们发现有比我们记录的两个数字大的数字，则返回 true 为什么这个思路可以呢？ 我们用一个最小的例子来说明：假设我们现在遍历了 [2, 4] 两个元素 此时最小的数字是 2、第二小的数字是 4 后面的元素有三种可能： 比 2 小 在 2 与 4 中间 比 4 大 不难看出只有第三种情况出现时，才能返回 true 当第一种情况发生时，我们的策略是：更新最小的数字为当前数字 当第二种情况发生时，我们的策略是：更新第二小的数字为当前数字 当我们用更小的数字替换原来记录的数字时，我们实际上是在维护更容易符合后面元素的递增二元组，因为更小的数字只会增加未来找到第三个数的可能性，而不会减少 Javascript /** * @param {number[]} nums * @return {boolean} */ var increasingTriplet = function(nums) { let first = Number.MAX_SAFE_INTEGER let second = Number.MAX_SAFE_INTEGER for(const num of nums) { if(num "},"medium/341.html":{"url":"medium/341.html","title":"341. Flatten Nested List Iterator(medium)","keywords":"","body":"341. Flatten Nested List Iterator Leetcode link 解题思路 本题的难点在于要怎么把层层嵌套的 list 摊平 在这里我们可以用递归的思路，具体而言就是写一个辅助函数 flatten 来遍历 nestedList： 如果是整数的话，就保存起来 如果是另一个 list 的话，就把 list 当新的参数递归自己 C++ class NestedIterator { private: vector res; // cpp 为了方便直接给了一个下标辅助遍历结果 int idx=0; public: NestedIterator(vector &nestedList) { flatten(nestedList); } int next() { return res[idx++]; } bool hasNext() { return idx &nestedList) { for(int i=0;i Javascript var NestedIterator = function(nestedList) { this.res = []; flatten(nestedList, this.res); }; function flatten(nestedList, arr) { for(let i=0;i "},"medium/347.html":{"url":"medium/347.html","title":"347. Top K Frequent Elements(medium)","keywords":"","body":"347. Top K Frequent Elements Leetcode link 解题思路——最小堆 TC: SC: 我们可以维护一个 map，来保存数组元素与出现频率，然后再维护一个优先队列构造的最小堆，里面保存了元素从小到大的出现频率 最后再一次遍历把前 k 小的元素丢进数组里就好了 C++ class Solution { public: vector topKFrequent(vector& nums, int k) { unordered_map map; for (int n : nums) { map[n]++; } priority_queue, greater> pq; for (auto& m : map) { pq.push(m.second); // 如果超出 k 个元素，就不保存了，这样能保证优先队列的头一定是第 k 大的 if (pq.size() > k) { pq.pop(); } } vector res; for (auto& m : map) { if (m.second >= pq.top()) { res.push_back(m.first); } } return res; } }; Javascript /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var topKFrequent = function(nums, k) { let map = {} for(let n of nums){ map[n]?map[n]++ : map[n] = 1; } let arr = []; for(let key in map) { arr.push([Number(key), map[key]]); } // 偷懒一下直接用 sort arr.sort((a,b)=>b[1]-a[1]); let res = []; for(let i = 0;i 解题思路——桶排序 TC: SC: 与上面的最小堆一样，我们还是先用一个 map 来统计频率。但是这次不同的是，我们用一个数组，把频率作为下标，依次把元素填进数组里。这样一来只要由后往前遍历，就能依次得到前 k 大高频元素了 C++ class Solution { public: vector topKFrequent(vector& nums, int k) { unordered_map map; for (int n : nums) { map[n]++; } vector> bucket(nums.size() + 1); for (auto& m : map) { bucket[m.second].push_back(m.first); } vector res; for (int i = bucket.size() - 1; i >= 0; i--) { for (int j = 0; j "},"medium/376.html":{"url":"medium/376.html","title":"376. Wiggle Subsequence(medium)","keywords":"","body":"376. Wiggle Subsequence Leetcode link 解题思路 本题要求我们找出一个数组中最长的摆动序列，且允许对数组中的元素进行删除操作 这一题我们可以用贪心的思路来求解 已知一个给定的数组有多个 “峰”（比两边都大的数） 跟多个 “谷”（比两边都小的数），峰跟谷中间也可能会有一些过渡元素 我们的目标就是，把过渡元素全部剔除掉，计算剩余的峰与谷的个数 Javascript /** * @param {number[]} nums * @return {number} */ var wiggleMaxLength = function(nums) { let len = nums.length; if(len 0 && prevDiff =0)) { res++; prevDiff = diff; } } return res; }; "},"medium/394.html":{"url":"medium/394.html","title":"394. Decode String(medium)","keywords":"","body":"394. Decode String Leetcode link 题目简介 /** * @param {string} s * @return {string} */ 题目给我们一个字符串 s，s 是一个编码后的字符串，由三个部分组成 数字，范围 [1, 300] 方括号 [] 小写英文字母 其中数字后面必跟着括号，括号中必有英文字母，代表将括号中的英文字母重复对应的数字次数 比如：s = \"3[a]2[bc]\" 解码后变成：\"aaabcbc\" 题目要求我们返回 s 解码后的字符串 解题思路 这题我们用栈 stack 来做 我们需要遍历字符串 s 当我们遇到 ] 以外的字符时，直接入栈 当遇到了 ]，我们需要分成两步分别处理字母与数字 最后再将重复好的字母放回栈中，直到遍历完所有字符后将 stack 转换成字符串就好 Javascript /** * @param {string} s * @return {string} */ var decodeString = function (s) { const stack = [] for (const char of s) { // push all chars except ']' if(char !== ']') { stack.push(char) continue } let top = stack.pop() let str = '' // pop the letters while(top !== '[') { str = top + str top = stack.pop() } let num = '' top = stack.pop() // pop the numbers while(!Number.isNaN(Number(top))) { num = top + num top = stack.pop() } stack.push(top) stack.push(str.repeat(Number(num))) } return stack.join('') }; "},"medium/399.html":{"url":"medium/399.html","title":"399. Evaluate Division(medium)","keywords":"","body":"399. Evaluate Division Leetcode link 解题思路 题目给了我们一些变量的除法结果，要求我们计算出其他变量的除法结果，如果条件不足就返回 -1.0 我们可以把问题简化一下：把它变成一幅图 equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]] values = [1.5,2.5,5.0] queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]] 把每个变量当成一个节点，节点之间的有向边表示相除的结果，注意节点间的有向边都是双向的，因为回来的边的权重可以用 1 除以出去的边得到。 另外图之间的节点有可能不相连，也有可能成环。 有了图之后，我们就可以用 DFS 或者 BFS 来找出两个边是否相连并且计算结果了（结果可以看成边的权重相乘） C++ class Solution { public: double dfs(unordered_map>> graph, unordered_set visited, string start, string end) { if (graph.find(start) == graph.end() || graph.find(end) == graph.end()) { return -1; } else if (start == end) { return 1; } // 记录已访问的节点，避免图形成环无法跳出 visited.insert(start); for (auto next : graph[start]) { if (visited.count(next.first) == 0) { double res = dfs(graph, visited, next.first, end); if (res != -1) { return res * next.second; } } } return -1.0; } vector calcEquation(vector>& equations, vector& values, vector>& queries) { int n = equations.size(); unordered_map>> graph(n); for (int i = 0; i result; for (auto q : queries) { unordered_set visited; double res = dfs(graph, visited, q[0], q[1]); result.push_back(res); } return result; } }; Javascript /** * @param {string[][]} equations * @param {number[]} values * @param {string[][]} queries * @return {number[]} */ var calcEquation = function(equations, values, queries) { let n = equations.length; let graph = {}; for (let i = 0; i "},"medium/406.html":{"url":"medium/406.html","title":"406. Queue Reconstruction by Height(medium)","keywords":"","body":"406. Queue Reconstruction by Height Leetcode link 解题思路 题目要求我们将输入的二维数组 people 按照特定的规律排序 规律是，数组元素的第一项表示当前的人的身高，第二项表示当前的人的前面有几个比他高或者跟他一样高的人 那么我们的思路就是： 首先先将所有人按照从低到高排序（因为比较低的人并不会影响到高的人的第二项，所以低的人需要优先排序） 其次，如果两个人身高相同，那么在她前面比她高的人多的排在前面（因为第二项比较大的人在身高相同的情况下肯定会比第二项比较小的人更靠后） 综上所述，我们需要对 people[0] 做升序，如果相等，则对 people[1] 做降序 重新排序完数组之后，我们就可以按照排序好的顺序来遍历数组了，具体思路如下： 首先我们需要一个长度为 people.length 的数组 res 然后我们依序遍历数组 people，按照顺序获取当前元素的第二项 k（k 代表了我们要将它放在数组 res 的第 k 个空元素的位置） 接着我们遍历数组 res，找出第 k 个空元素依次放入当前遍历的 people 元素 循环第 2、3 步直到数组遍历完毕，最后的 res 数组就是答案 Javascript /** * @param {number[][]} people * @return {number[][]} */ var reconstructQueue = function(people) { people.sort((a, b) => { if(a[0] === b[0]) { return b[1] - a[1]; } return a[0] - b[0]; }); const res = new Array(people.length).fill(0); for(let person of people) { let pos = person[1]; let space = 0; for(let j = 0;j "},"medium/416.html":{"url":"medium/416.html","title":"416. Partition Equal Subset Sum(medium)","keywords":"","body":"416. Partition Equal Subset Sum Leetcode link 题目简介 /** * @param {number[]} nums * @return {boolean} */ 题目给我们一个数字数组 nums 要求我们求出是否能将 nums 分成两个和相等的数组 解题思路 题目要求把 nums 分成两个数组，且两个数组的和相等，所以这间接告诉我们，这两个数组的和必须是 nums 所有元素和的一半 于是我们的目标变成了，从 nums 中找元素组成一个新数组（元素不可重复），其数组元素之和为 nums 所有元素和的一半 至此，这题有点类似 322，区别在于 322 的硬币可以用多个，而我们数组元素只能用一次 处理方法还是类似，我们使用一个数组 dp 来保存可以凑出来的数字 由于我们的目标是凑出 target（ target = sum(...nums)/2），所以我们只需要一个长度为 target+1 的 dp 即可 初始值：dp[0] = true 代表数字 0 我们一定能凑出来（因为不需要任何 nums 的元素） 接下来我们需要遍历 nums，找出所有可以被凑出来的数字，如果最后 target 可以被凑出来我们就返回 true；否则返回 false 对于每一个 nums 中的 num，我们需要倒序遍历 dp（因为如果正序遍历的话我们会使用多次同一个 num） 此时有两种情况： dp[i] === true 代表当前数字已经可以被凑出来，我们直接 continue dp[i-num] === true 代表在 num 出现之前数字 i-num 可以被凑出来，那么此时我们需要把 dp[i] = true（因为此时我们有 num 了，如果 i-num 可以被凑出来，i 也可以被凑出来） 循环终止条件就是 dp[target] === true 或者循环结束 Javascript /** * @param {number[]} nums * @return {boolean} */ var canPartition = function (nums) { const total = nums.reduce((acc, cur) => acc + cur, 0) // if the total is odd, it cannot be split in half if (total % 2 === 1) { return false } // now we only have to find a subset which sum(subset) = total/2 const target = total / 2 // if dp[i] === true, means we can find a subset which sum(subset) === i const dp = new Array(target + 1).fill(false) dp[0] = true for (const num of nums) { for (let i = target; i >= num; i--) { // if the i is already reachable, just continue if(dp[i]) { continue } // if i-num was reachable, and we have num now, so i is reachable now if(dp[i - num]) { dp[i] = true } // avoid unnecessary calculations if(dp[target]) { return true } } } return false }; "},"medium/417.html":{"url":"medium/417.html","title":"417. Pacific Atlantic Water Flow(medium)","keywords":"","body":"417. Pacific Atlantic Water Flow Leetcode link 题目简介 题目给我们一个二维数组 heights 表示一个岛屿，其中每个元素代表岛屿各个位置的高度 该岛屿的北面与西面被太平洋包围；东面与南面被大西洋包围 题目要求下在哪些岛屿的位置的雨水可以同时流到太平洋与大西洋 雨水能从 A 流到 B 只有可能是 A 的高度大于等于 B 的高度 题目要我们返回所有符合条件的坐标的集合 解题思路 这题我们可以从水流入大海之前的最后一个位置开始，一点一点的往回找到水流过的地方 具体来说，我们可以从岛屿的四条与大海接壤的边开始，对边上的格子依次做深度优先遍历 dfs dfs 的终止条件就是当前格子被搜寻过了，或者当前格子比上一个格子低（也就是水无法从当前格子流向上一个格子） 但是由于我们大海有两个，所以我们判断当前格子有没有被搜寻过需要区分是被流进太平洋的水流过，还是被流进大西洋的水流过 所以我们不能用一个简单的 true/false 来判断，我们可以用： 1 代表大西洋 2 代表太平洋 这样一来有两个好处： 判断被哪个洋流过只需要进行一个简单的比特位的与操作就可以了 如果当前格子被流进两个洋的水都流过了，那么它就是 3，如果当前格子为 3 我们就可以将其加入答案之中了 Javascript /** * @param {number[][]} heights * @return {number[][]} */ var pacificAtlantic = function (heights) { const res = [] const width = heights.length const len = heights[0].length // we use 0 for not visited // 1 for visited by Atlantic ocean // 2 for visited by Pacific ocean const ATLANTIC = 1 const PACIFIC = 2 const visited = Array.from({length: width}, _ => new Array(len).fill(0)) const dfs = (x, y, h, mark) => { if (visited[x][y] & mark || heights[x][y] 0) dfs(x - 1, y, heights[x][y], mark) if (x 0) dfs(x, y - 1, heights[x][y], mark) if (y "},"medium/429.html":{"url":"medium/429.html","title":"429. N-ary Tree Level Order Traversal(medium)","keywords":"","body":"429. N-ary Tree Level Order Traversal Leetcode link 题目简介 本题题目给了一颗树的根节点，要求我们返回一个数组，其元素是树的每一层元素的值 解题思路 这题我们用 bfs 的思路来做，用一个队列来维护当前层的节点 此外题目给的根节点有可能为 null，需要额外留意 Javascript /** * // Definition for a _Node. * function _Node(val,children) { * this.val = val; * this.children = children; * }; */ /** * @param {_Node|null} root * @return {number[][]} */ var levelOrder = function (root) { if (root === null) { return [] } const res = [] const queue = [[root]] while (queue.length > 0) { const elements = queue.shift() const values = [] const nextLevelElements = [] for (const ele of elements) { values.push(ele.val) nextLevelElements.push(...ele.children) } res.push(values) nextLevelElements.length > 0 && queue.push(nextLevelElements) } return res }; "},"medium/437.html":{"url":"medium/437.html","title":"437. Path Sum III(medium)","keywords":"","body":"437. Path Sum III Leetcode link 题目简介 /** * @param {TreeNode} root * @param {number} targetSum * @return {number} */ 题目给我们一个二叉树的根节点 root 以及一个数字 targetSum 题目要求我们找到路径中节点之和为 targetSum 的路径个数 合法路径定义：必须从根节点到叶子节点，且不必包含根节点或叶子节点 解题思路 这题的暴力解法思路是：通过 dfs 遍历出每一条从根到叶子的路径，然后对这些路径用滑动窗口找到窗口内节点之和为 targetSum 的窗口数量 在暴力的基础上，我们可以使用前缀和的方法来减少复杂度 步骤： 使用 dfs 遍历路径，并且在遍历每个节点的时候记录前缀和 prefixSum，并且用一个 prefixSumMap 记录该前缀和出现的次数 在 prefixSumMap 中查找 prefixSum - targetSum 出现的次数，这个次数代表了当前路径下节点之和为 targetSum 的子路径个数 依次遍历左右子树 左右子树回溯的时候记得要从 prefixSumMap 把当前前缀和的个数 - 1 prefixSumMap 的初始状态是 {0: 1} 代表当 prefixSum === targetSum 的时候出现了 1 个路径 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} targetSum * @return {number} */ var pathSum = function(root, targetSum) { // {prefixSum: count} const prefixSumMap = new Map() // if prefixSum === targetSum, then we get 1 path prefixSumMap.set(0, 1) const dfs = (node, sum) => { if(!node) { return 0 } sum += node.val let count = prefixSumMap.get(sum - targetSum) || 0 prefixSumMap.set(sum, (prefixSumMap.get(sum) || 0) + 1) count += dfs(node.left, sum) count += dfs(node.right, sum) prefixSumMap.set(sum, prefixSumMap.get(sum) - 1) return count } return dfs(root, 0) }; "},"medium/438.html":{"url":"medium/438.html","title":"438. Find All Anagrams in a String(medium)","keywords":"","body":"438. Find All Anagrams in a String Leetcode link 题目简介 /** * @param {string} s * @param {string} p * @return {number[]} */ 题目给我们两个字符串 s 与 p，要求我们在 s 中找到所有由 p 字符串字符构成的子字符串并返回子字符串的开始坐标 解题思路 这题其实算是 76 题的简化版本，76 题的字符串是不连续的，而这一题只需要寻找连续的子字符串即可 方法还是一样，我们用一个 map 来保存 p 字符串中字符的个数，然后用一个 remainingCount 保存 p 字符串的长度，这样可以减少遍历 map 的复杂度 接下来我们只需要在右指针遍历新元素与左指针离开旧元素的时候维护好 remainingCount 与 map 即可 在 remainingCount 为 0 的时候我们把左指针 left 放进答案中就好 Javascript /** * @param {string} s * @param {string} p * @return {number[]} */ var findAnagrams = function (s, p) { const map = new Map() let remainingCount = p.length for (const char of p) { map.set(char, (map.get(char) || 0) + 1) } const res = [] let left = 0 for (let right = 0; right 0) { remainingCount-- } map.set(char, map.get(char) - 1) } if (remainingCount === 0) { res.push(left) } if (right - left + 1 === p.length) { const leftChar = s[left] if (map.has(leftChar)) { map.set(leftChar, map.get(leftChar) + 1) if (map.get(leftChar) > 0) { remainingCount++ } } left++ } } return res }; 解题思路 当然，作为 medium，这题自然还会有别的思路 如果我们仔细观察题目我们会发现 s 与 p 都只包含小写英文单字，所以我们只需要维护两个长度为 64 的字符串即可对比当前 s 的子字符串是否与 p 字符串有相同字符构成 Javascript /** * @param {string} s * @param {string} p * @return {number[]} */ var findAnagrams = function (s, p) { const pCount = new Array(64).fill(0) const windowCount = new Array(64).fill(0) const res = [] for (const char of p) { pCount[getIndex(char)]++ } let left = 0 let right = 0 while (right p.length) { windowCount[getIndex(s[left])]-- left++ } if (isEqual(pCount, windowCount)) { res.push(left) } right++ } return res }; const getIndex = char => char.charCodeAt(0) - 97; const isEqual = (count1, count2) => { for (let i = 0; i "},"medium/443.html":{"url":"medium/443.html","title":"443. String Compression(medium)","keywords":"","body":"443. String Compression Leetcode link 题目简介 /** * @param {character[]} chars * @return {number} */ 题目给我们一个字符串数组 chars，要求我们把 chars 中重复的字符压缩成字符+出现次数的形式 要求在原数组中修改，并且返回新的数组的长度 解题思路 这题我们使用双指针的思路来做 慢指针 slow 负责出现在新字符的第一个位置，快指针负责寻找下一个新的字符 当快慢指针都找到对应的位置后，我们可以使用 fast - slow 来计算当前 slow 指针所在的字符有多少个 下一步我们使用 splice 替换 chars 的字符，然后更新快慢指针位置即可 Javascript /** * @param {character[]} chars * @return {number} */ var compress = function (chars) { let fast = 0 let slow = 0 while (fast 1) { const count = `${fast - slow}`.split('') chars.splice(slow + 1, fast - slow - 1, ...count) slow += count.length + 1 fast = slow } else { slow++ } } if (fast - slow > 1) { const count = `${fast - slow}`.split('') chars.splice(slow + 1, fast - slow - 1, ...count) slow += count.length + 1 fast = slow } else { slow++ } return slow }; "},"medium/450.html":{"url":"medium/450.html","title":"450. Delete Node in a BST(medium)","keywords":"","body":"450. Delete Node in a BST Leetcode link 题目简介 /** * @param {TreeNode} root * @param {number} key * @return {TreeNode} */ 题目给我们一个 BST 的跟 root，要求我们删除其中值为 key 的节点 返回修改后的 BST 的根节点 解题思路 这题我们需要分为两步求解： 找到目标节点 删除目标节点 首先是寻找，这个相对简单，只需要用 DFS 然后根据当前节点与 key 的大小来选择分支即可 删除的部分我们需要分情况来讨论： 如果当前节点没有左右子节点：直接删除 如果当前节点只有左/右节点其一：删除其第一个左/右子节点 如果当前节点的左右子节点都存在：我们需要找到其右子树的最左子节点，用其替代当前节点 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} key * @return {TreeNode} */ var deleteNode = function(root, key) { if(!root) { return null } if(key root.val) { root.right = deleteNode(root.right, key) } else { // we find it, we delete it if(!root.left && !root.right) { return null } if(!root.left) { return root.right } if(!root.right) { return root.left } // use the leftmost node of the right subtree to replace it root.val = findMin(root.right) // delete the original leftmost node root.right = deleteNode(root.right, root.val) } return root }; const findMin = node => { if(node.left) { return findMin(node.left) } return node.val } "},"medium/456.html":{"url":"medium/456.html","title":"456. 132 Pattern(medium)","keywords":"","body":"456. 132 Pattern Leetcode link 背景知识 本题要求我们找出一个数组中是否有 “132” 组合，注意是允许不连续的 考虑到时间复杂度，我们把三个数字全部遍历一次肯定会 OT 那么我们可以想一下有没有可能遍历其中一个就可以找到结果呢？答案是可以的，而且有三种方法： 遍历其中的 1，也就是最小的那个数，这样一来我们只要在它的右边找出一对 (j,k)，使得 j>k 就好 遍历其中的 3，也就是最大的数，这样一来，我们得在它的左边找到 “小于它的最小的数“，在它右边找到 ”小于它的最大的数“ 遍历其中的 2，也就是中间的数，思路与方法一差不多，只是变成要在它的左边找一对 (i,j)，使得 i。 解题思路——方法一 我们来讲一下方法一，因为方法一只要在保证 j>k 的条件下，记录最大的 k 拿来跟遍历的数比较就好。 举个例子，现在有一组数组 [3, 4, 6, 4, 3, -1, 6]，我们维护一个单调递减栈，其中存放着比 j 小的同时下标比 j 大的数。 我们从后往前遍历： 数字 6：此时栈为空，我们把它入栈；栈顶为 6 数字 -1：-1 入栈；栈顶为 -1 数字 3：3 > -1，表示它有可能是 j，这个时候我们可以把 k 设置成 “比 j 小的最大值”；在这里，k = -1；把 3 入栈 数字 4：4 > k，表示 4 不符合被当成 \"1\" 的条件；4 > 3，表示它有可能是 j；更新 k 为 3；把 4 入栈 数字 6：6 > 3，不能为 \"1\"；6 > 4，更新 k 为 4；把 6 入栈 数字 4：4 == 4，不能为 \"1\"；4 ，不更新 k；把 4 入栈 数字 3：3 ，可以当成 \"1\"，这下子三个数都找到了，返回 true 注：在找比 j 小的最大值的时候顺便会把栈里面比 j 小的数全部丢掉，因为没用了 下面的表展示了在遍历过程栈与 k 的变化： 数字 栈（栈底 -> 栈顶） k 6 [6] -∞ -1 [6, -1] -∞ 3 [6, 3] -1 4 [6, 4] 3 6 [6, 6] 4 4 [6, 6, 4] 4 3 [6, 6, 4] 4 C++ class Solution { public: bool find132pattern(vector& nums) { // 遍历 \"132\" 中最小的 \"1\" // 单调递减的栈 stack st; // k: \"132\" 中的 \"2\" int k = INT_MIN; for (int i = nums.size() - 1; i >= 0; i--) { // 只有当 k 有被更新过，当前元素才可能小于它（才有可能是 \"1\"），而后面的循环表示 k 要被更新过必须有比 k 大的数在栈中 if (nums[i] st.top())) { k = max(k, st.top()); st.pop(); } // 只要 k 有被更新过，说明这个栈里面必有比 k 大的数 st.push(nums[i]); } return false; } }; Javascript var find132pattern = function(nums) { let stack = []; let k = Number.MIN_SAFE_INTEGER; for(let i=nums.length-1;i>=0;i--) { if(nums[i] stack[stack.length-1]) { k = Math.max(k, stack.pop()); } stack.push(nums[i]); } return false; }; 解题思路——方法三 思路来源：https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/850676 因为觉得思路太好了所以搬运记录一下 这个方法是用了遍历 \"132\" 中的 \"2\"，它可以让我们从前往后遍历，如果今天的数据是流的话就只能用这个方法了 这个方法我们需要维护一个栈，还有一个数组，其中数组 leftMin 保存的是当前元素左边最小的数 我们的目标是找到一个数小于栈顶元素的同时，栈顶元素左边的最小值也小于它就返回 true 一样用 [3, 4, 6, 4, 3, -1, 6] 来做例子吧： 数字 3：目前栈为空，直接把 3 入栈；leftMin[0] = 3 数字 4：4 > 3，表示它不能被当成 j，将 3 出栈，4入栈；leftMin[1] = 3 数字 6：6 > 4，一样将 4 出栈，6入栈；leftMin[2] = 3 数字 4：4 ，表示它有可能是 j，然后我们看一下栈顶元素左边元素最小值是 3，3 ，bingo～ 注：在代码中为了访问方便栈中存放的其实是下标，这里写元素是为了理解方便 下面的表展示了在遍历过程栈与数组的变化： 数字 栈（栈底 -> 栈顶） leftMin 3 [3] [3] 4 [4] [3, 3] 6 [6] [3, 3, 3] 4 C++ class Solution { public: bool find132pattern(vector& nums) { stack st; // 存放当前元素左边最小的数 vector leftMin{INT_MAX}; for (int i = 0; i Javascript var find132pattern = function(nums) { let stack = []; // 存放当前元素左边最小的数 let leftMin = [Number.MAX_SAFE_INTEGER]; for(let i=0;i 0) && (nums[stack[stack.length-1]] 0) && leftMin[stack[stack.length-1]] "},"medium/462.html":{"url":"medium/462.html","title":"462. Minimum Moves to Equal Array Elements II(medium)","keywords":"","body":"462. Minimum Moves to Equal Array Elements II Leetcode link 解题思路 题目要求我们将一个数组中的数字使用最少的操作变成全部一样 根据题目描述，我们要找的肯定是所有数字的中位数了，所以我们只需要对数组排序之后，将每个数字都与中位数相减之后加总就是解答了 Javascript /** * @param {number[]} nums * @return {number} */ var minMoves2 = function(nums) { nums.sort((a, b)=>a-b); let mid = nums[Math.floor(nums.length / 2)] let res = 0; for(let num of nums) { res+= Math.abs(num - mid); } return res; }; 本题的性能优化点在排序算法的使用上，在 215 中，我们对快速排序做了一个改进，使其可以在 O(n) 的复杂度下求解出第 k 小的元素，这一题的思路只是把 215 的第 k 小变成第 num.lenth / 2 小罢了，具体可以参考 215 的代码 "},"medium/474.html":{"url":"medium/474.html","title":"474. Ones and Zeroes(medium)","keywords":"","body":"474. Ones and Zeroes Leetcode link 解题思路 这个题目也太难懂了吧&#x1F92F; 题目要求我们求出一个字符串数组的最长子集，约束条件是最长子集的所有 0 的个数加起来不能超过 m；所有 1 的个数加起来不能超过 n（注意是所有子集合并计算） 很明显是一道动态规划的题目，我们还是需要一个二维数组 dp 数组 dp[i][j] 表示 i 个 0 与 j 个 1 的最长子集 那么状态转移方程是什么呢？我们考虑到有一个字符串的 0 的个数为 zeros，1 的个数为 ones，状态转移方程可以写成： dp[i][j] = max(dp[i][j], dp[i - zeros, j - ones] + 1) 前面的 dp[i][j] 表示不选这个字符串的最长子集，后面表示选择这个字符串之后的最长子集，求其最大值 最后总结一下流程： 首先初始化二维数组 dp 的每一个元素为 0 再来遍历字符串数组 strs，计算每一个字符串的 zeros 跟 ones 接着对 zeros 跟 ones 遍历，更新 dp 数组 返回 dp[m][n] C++ class Solution { public: int findMaxForm(vector& strs, int m, int n) { vector> dp(m+1, vector(n+1, 0)); for(string str:strs) { int zeros = count(str.begin(), str.end(), '0'); int ones = count(str.begin(), str.end(), '1'); for(int i = m;i >= zeros;i--) { for(int j = n;j >= ones;j--) { dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1); } } } return dp[m][n]; } }; Javascript var findMaxForm = function(strs, m, n) { // dp[i][j]: i 个 0，j 个 1 的时候最长子集 let dp = new Array(m+1).fill(0).map(arr=>new Array(n+1).fill(0)); for(let str of strs) { let zeros = (str.match(/0/g) || []).length; let ones = (str.match(/1/g) || []).length; for(let i = m;i >= zeros;i--) { for(let j = n;j >= ones;j--) { dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1); } } } return dp[m][n]; }; "},"medium/535.html":{"url":"medium/535.html","title":"535. Encode and Decode TinyURL(medium)","keywords":"","body":"535. Encode and Decode TinyURL Leetcode link 解题思路 这道题让我们模拟短链接生成算法。这题出的……直接原路返回也能过。 一般而言，短链接生成分为两步： 根据某种规则生成后面的乱序字符串 将乱序字符串与原来的长链接建立映射关系 C++ class Solution { private: unordered_map urlMap; string characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; public: // Encodes a URL to a shortened URL. string encode(string longUrl) { srand(time(NULL)); // 因为测试用例规模就 700 多个，用 4 位字符串已经够了 string tinyUrl = \"http://tinyurl.com/\" + generateRandomStr(4); urlMap[tinyUrl] = longUrl; return tinyUrl; } // Decodes a shortened URL to its original URL. string decode(string shortUrl) { return urlMap[shortUrl]; } string generateRandomStr(int length) { string res = \"\"; while (length--) { int randomIndex = rand() % 62; res += characters[randomIndex]; } return res; } }; Javascript /** * Encodes a URL to a shortened URL. * * @param {string} longUrl * @return {string} */ var encode = function(longUrl) { // 因为测试用例规模就 700 多个，用 4 位字符串已经够了 let tinyUrl = \"http://tinyurl.com/\" + generateRandomStr(4); urlMap[tinyUrl] = longUrl; return tinyUrl; }; /** * Decodes a shortened URL to its original URL. * * @param {string} shortUrl * @return {string} */ var decode = function(shortUrl) { return urlMap[shortUrl]; }; var urlMap = {}; const characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; var generateRandomStr = function(length) { let res = '' while (length--) { let randomIndex = Math.random() % 62; res += characters[randomIndex]; } return res; } /** * Your functions will be called as such: * decode(encode(url)); */ "},"medium/538.html":{"url":"medium/538.html","title":"538. Convert BST to Greater Tree(medium)","keywords":"","body":"538. Convert BST to Greater Tree Leetcode link 解题思路 本题要求我们把一个 BST 的每个节点的值变成节点本身的值加上所有比它大的节点的值 仔细看题目给出的示例，可以看到这个节点的累加过程是 右节点 根节点 左节点 所以我们可以用中序深度优先搜索来做这题，记得维护一个 sum 变量来保存之前累加的值就好 C++ class Solution { private: int sum = 0; public: void dfs(TreeNode* root) { if (!root) { return; } if (root->right) { dfs(root->right); } root->val = sum += root->val; if (root->left) { dfs(root->left); } } TreeNode* convertBST(TreeNode* root) { dfs(root); return root; } }; Javascript var convertBST = function(root) { // 如果用全局变量好像 leetcode 跑测试会有问题，就写进来了 let sum = 0 var dfs = function(root) { if(!root) { return; } if(root.right) { dfs(root.right); } root.val = sum+= root.val; if(root.left){ dfs(root.left); } } dfs(root); return root; }; "},"medium/547.html":{"url":"medium/547.html","title":"547. Number of Provinces(medium)","keywords":"","body":"547. Number of Provinces Leetcode link 题目简介 /** * @param {number[][]} isConnected * @return {number} */ 题目给我们一个长度为 n*n 的二维数组，数组元素之可能为 1 或 0（1 表示当前横坐标代表的城市与纵坐标代表的城市连通、0 表示不连通） 规定所有有连通的城市都会被划分为一个省 题目要求我们计算出 isConnected 这个图中有多少个省 解题思路 这道题我们需要用到 DFS 的思想来做 具体而言，我们在遍历图的过程中如果碰到了连通的城市，我们需要深度遍历与其连通的城市，把所有连通的城市串起来 由于 dfs 过程中难免会碰到重复的城市，所以我们可以用一个长度为 n 的 visited 数组来表示到访过的城市 最后我们在最外层遍历数组的时候，如果有碰到未到访过的城市，表示我们遇到了一个新的省，把省的数量加一 最后返回省的数量即可 Javascript /** * @param {number[][]} isConnected * @return {number} */ var findCircleNum = function (isConnected) { const len = isConnected.length const visited = Array(len).fill(false) let res = 0 const dfs = (city) => { visited[city] = true for (let cur = 0; cur 复杂度分析 时间 由于我们需要遍历所有的数组元素，所以是 空间 空间复杂度主要来源于 dfs，最坏的情况下，所有城市都被连在一起，所以是 O(n) 的复杂度 "},"medium/560.html":{"url":"medium/560.html","title":"560. Subarray Sum Equals K(medium)","keywords":"","body":"560. Subarray Sum Equals K Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {number} */ 本题给我们一个数字数组 nums 以及一个目标数字 k 题目要求我们计算出数组 nums 中有多少子数组其和为 k 解题思路 算数组中的子数组和，我们需要使用到一个前缀和技巧： sum[num[i..j]] = sum(num[0..j]) - sum(num[0..i]) 白话就是，我们要计算数组中任意两个下标 i 到 j 的子数组和，我们可以用下标为 0 到 j 的子数组和减去下标为 0 到 i 的子数组和 回到这题，我们怎么做呢 我们只需要用一个 map 来保存所有出现过的前缀和及其次数 然后我们就可以用上面公式的变形找到适合的前缀和（sum[num[i..j]]就是题目要求的 k）： sum(num[0..i]) = sum(num[0..j]) - sum[num[i..j]] 如果找到，我们就将其出现次数加到结果中即可 Javascript /** * @param {number[]} nums * @param {number} k * @return {number} */ var subarraySum = function (nums, k) { // {prefixSum: frequency} const freqneucyMap = new Map([[0, 1]]) let prefixSum = 0 let res = 0 for (const num of nums) { prefixSum += num const difference = prefixSum - k if (freqneucyMap.has(difference)) { res += freqneucyMap.get(difference) } freqneucyMap.set(prefixSum, (freqneucyMap.get(prefixSum) || 0) + 1) } return res }; "},"medium/581.html":{"url":"medium/581.html","title":"581. Shortest Unsorted Continuous Subarray(medium)","keywords":"","body":"581. Shortest Unsorted Continuous Subarray Leetcode link 解题思路——排序 TC: O(n * log(n)) SC: O(n) 本题要求我们找出一个未排序数组的最长已排序连续子数组 既然是这样，那我们可以直接用一个相同的数组，经过排序之后分别从左边跟右边寻找第一个不相同的元素然后计算元素之间的距离就好 C++ class Solution { public: int findUnsortedSubarray(vector& nums) { vector sortedNums(nums); sort(sortedNums.begin(), sortedNums.end()); int left = 0, right = nums.size() - 1; while ((left = 0) && (sortedNums[right] == nums[right])) { right--; } int res = right - left + 1; return res > 0 ? res : 0; } }; Javascript var findUnsortedSubarray = function(nums) { let sortedNums = [...nums]; sortedNums.sort((a,b)=>a-b); let left = 0, right = nums.length - 1; while ((left = 0) && (sortedNums[right] === nums[right])) { right--; } let res = right - left + 1; return res > 0 ? res : 0; }; 解题思路——逻辑 TC: O(n) SC: O(1) 我们也可以用逻辑推导出问题的答案： 首先我们先从左往右找第一个不是升序的元素，从这个元素开始，找出剩余数组的最小值，记为 minimum 然后我们从右往左找第一个不是降序的元素，从这个元素开始，找出剩余数组的最大值，记为 maximun 接着我们从左往右遍历数组，这次的目标是找到第一个比 minimum 大的元素，其下标记作 k 我们再从右往左遍历数组，找到第一个比 maximum 小的元素，其下标记作 l 求 l 与 k 之间的距离，就是我们的答案 C++ class Solution { public: int findUnsortedSubarray(vector& nums) { int maximun = INT_MIN, minimum = INT_MAX; int len = nums.size(); bool flag = false; for (int i = 1; i nums[i]) { flag = true; } if (flag) { minimum = min(nums[i], minimum); } } flag = false; for (int j = len - 2; j >= 0; j--) { if (nums[j] > nums[j + 1]) { flag = true; } if (flag) { maximun = max(nums[j], maximun); } } int k, l; for (k = 0; k minimum) { break; } } for (l = len - 1; l >= 0; l--) { if (nums[l] Javascript var findUnsortedSubarray = function(nums) { let maximun = Number.MIN_SAFE_INTEGER, minimum = Number.MAX_SAFE_INTEGER; let len = nums.length; let flag = false; for (let i = 1; i nums[i]) { flag = true; } if (flag) { minimum = Math.min(nums[i], minimum); } } flag = false; for (let j = len - 2; j >= 0; j--) { if (nums[j] > nums[j + 1]) { flag = true; } if (flag) { maximun = Math.max(nums[j], maximun); } } let k, l; for (k = 0; k minimum) { break; } } for (l = len - 1; l >= 0; l--) { if (nums[l] "},"medium/583.html":{"url":"medium/583.html","title":"583. Delete Operation for Two Strings(medium)","keywords":"","body":"583. Delete Operation for Two Strings Leetcode link 解题思路 本题给定我们两个字符串，要求删除最少的字符使得两个字符串相同 本题考虑动态规划的思考 我们需要一个二维数组 dp，其中 dp[i][j] 表示使 word1 长度为 i 的前缀与 word2 长度为 j 的前缀相同的最少删除操作次数 首先判断边界情况： i = 0：表示 word1 字符串为空，那么对于任意的 j，有 dp[0][j] = j j = 0：表示 word2 字符串为空，呢么对于任意的 i，有 dp[i][0] = i 再来判断 i，j 都大于 0 的情况 word1[i - 1] = word2[j - 1]：加入两个相同的字符，则他们的最少删除数取决于之前的删除个数，换言之 dp[i][j] = dp[i-1][j-1] word1[i - 1] != word2[j - 1]：加入两个不相同的字符，这个时候要判断 dp[i][j - 1] 还是dp[i - 1][j] 哪个比较小，将比较小的那个 +1 综上所述，状态转移方程为： C++ class Solution { public: int minDistance(string word1, string word2) { int len1 = word1.size(); int len2 = word2.size(); vector> dp(len1 + 1, vector(len2 + 1)); for(int i = 1;i Javascript /** * @param {string} word1 * @param {string} word2 * @return {number} */ var minDistance = function(word1, word2) { let len1 = word1.length; let len2 = word2.length; let dp = new Array(len1+1).fill(0).map(_=>_ = new Array(len2+1).fill(0)); for(let i = 1;i "},"medium/611.html":{"url":"medium/611.html","title":"611. Valid Triangle Number(medium)","keywords":"","body":"611. Valid Triangle Number Leetcode link 题目简介 本题给了一个数组 nums 要求我们在数组中任意选取三个数字组成一个三角形，并且求出三个数字的组合有多少种 如果有两个数组元素相等，也视为两个不同的元素 解题思路 要组成三角形的要求就是两边之和大于第三边 我们可以先对数组升序排序，然后我们用下标 k 由后往前遍历数组（从大到小） 遍历的过程中，我们需要用双指针 i, j 来分别指向 0 以及 k-1 接下来我们计算 nums[i] + nums[j] > nums[k] ，有两种可能： true 代表当前组合可以组成三角形，那么我们可以组成三角形的组合数 count 需要加上 j-i 种（因为如果 i 可以组成三角形，比 i 大且比 j 小的数组元素也能够组成三角形） false 代表当前组合无法组成三角形，那么我们可以将 i++ 来寻找更大的数组元素 当我们完成下标 k 的遍历时，组合数 count 就是答案 Javascript /** * @param {number[]} nums * @return {number} */ var triangleNumber = function(nums) { let count = 0 nums.sort((a, b) => a - b) for(let k = nums.length - 1;k>=0;k--) { let i = 0, j = k - 1 while(i nums[k]) { count += j - i j-- } else { i++ } } } return count }; "},"medium/633.html":{"url":"medium/633.html","title":"633. Sum of Square Numbers(medium)","keywords":"","body":"633. Sum of Square Numbers Leetcode link 解题思路 本题目给到我们一个正整数 c，要求我们找出是否有正整数 a，b 符合等式：a^2 + b^2 = c 一个简单的想法就是用两个指针 a，b 往中间夹紧遍历，如果直到 a>b 还没找到，那么就可以返回 false 了 a 一般从 0 开始（因为不能排除有 b^2 = c 的可能性） b 则从 sqrt(c) 开始（因为 b 最大的情况就刚好是 c 开根号） Javascript /** * @param {number} c * @return {boolean} */ var judgeSquareSum = function(c) { let a = 0; let b = Math.floor(Math.sqrt(c)); while(a "},"medium/647.html":{"url":"medium/647.html","title":"647. Palindromic Substrings(medium)","keywords":"","body":"647. Palindromic Substrings Leetcode link 解题思路——回文特性 题目要求我们求一个字符串中回文子字符串的个数 首先我们分析一下要达成回文有哪些可能： aba 形式：也就是由奇数个字符组成，除了中间的那个之外其他的两两相同 aa 形式：由偶数个字符组成，两两相同 至此，我们可以通过遍历输入的字符串并分别判断以上两种可能性来计算回文子字符串的个数 C++ class Solution { public: int countSubstrings(string s) { int res = 0; for(int i = 0;i=0 && right =0 && right Javascript var countSubstrings = function(s) { let res = 0; for(let i=0;i=0 && right = 0 && right 解题思路——DP 这题也可以用动态规划来解 首先我们把二维数组 dp[i][j] 定义为下标从 i 到 j 的字符串是否能构成回文 接下来，我们使用两个指针 i 跟 j，来遍历字符串 什么情况会构成回文呢？首先 s[i] == s[j] 是所有的大前提，满足这个前提之下有三种可能： i 跟 j 中间只有一个字符 i 跟 j 是相邻的 dp[i+1][j-1] 能构成回文 详情看代码： C++ class Solution { public: int countSubstrings(string s) { int res = 0; int len = s.size(); vector> dp(len, vector(len, false)); for(int i = len-1;i>=0;i--) { for(int j = i;j Javascript var countSubstrings = function(s) { let res = 0; let len = s.length; let dp = new Array(len); for(let i=0;i=0;i--) { for(let j = i;j "},"medium/649.html":{"url":"medium/649.html","title":"649. Dota2 Senate(medium)","keywords":"","body":"649. Dota2 Senate Leetcode link 题目简介 /** * @param {string} senate * @return {string} */ 题目给我们一个字符串 senate 由 R 与 D 两个字符组成 每个字符代表一种角色，每个角色都有两种操作可以选： 禁用后面的某个角色的发言权（等于把那个角色踢下牌桌了） 如果牌桌上只有一种角色，可以宣布获胜 游玩的顺序根据字符串的遍历顺序来，可以一直游玩直到某个角色宣布胜利 最后返回胜利的阵营即可 解题思路 我们可以用两个队列来分别保存两个阵营的角色位置下标 每一轮游玩的时候，我们分别获取两个队列的队头，下标小的角色可以留下，下标大的角色直接出局 我们把下标小的角色下标加上 senate 长度放入队列尾供下一轮游玩 最后我们只要判断哪个队列还剩下角色即可判断哪一队赢了 Javascript /** * @param {string} senate * @return {string} */ var predictPartyVictory = function (senate) { const radiant = [] const dire = [] const len = senate.length for (let i = 0; i 0 ? \"Radiant\" : \"Dire\" }; "},"medium/665.html":{"url":"medium/665.html","title":"665. Non-decreasing Array(medium)","keywords":"","body":"665. Non-decreasing Array Leetcode link 解题思路 题目给定一个数组 nums，要求我们判断在对多改变一个元素的情况下是否能将该数组变为升序（包含相等） 本题的关卡有两个： 在满足题目的要求下最多能有几个非升序的元素呢？ 一个 在发现有非升序的元素 nums[i] 时，应该如何改变元素呢？ 第一种情况 nums[i + 1] ：这种情况需要将 nums[i + 1] 变为 nums[i] 第二种情况 nums[i + 1] >= nums[i - 1]：这种情况需要将 nums[i] 变为 nums[i + 1] C++ class Solution { public: bool checkPossibility(vector& nums) { bool flag = false; for(int i = 0;i y) { if(flag) { return false; } flag = true; if(i >0 && y Javascript /** * @param {number[]} nums * @return {boolean} */ var checkPossibility = function(nums) { let flag = false; for(let i = 0;i y) { // 只允许更改一次 if(flag) { return false; } flag = true; // 第一种情况 if(i>0 && y "},"medium/669.html":{"url":"medium/669.html","title":"669. Trim a Binary Search Tree(medium)","keywords":"","body":"669. Trim a Binary Search Tree Leetcode link 解题思路 本题要求我们给 BST 剪枝， 可以用 dfs 的思想递归。 考虑到有两种情况： 如果当前节点小于 low，则返回当前节点的右边子节点 如果当前节点大于 high，则返回当前节点的左边子节点 接下来就可以针对 root->left 与 root->right 来递归了 C++ class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { if (!root) { return nullptr; } if (root->val right, low, high); } else if ((root->val > high)) { return trimBST(root->left, low, high); } root->left = trimBST(root->left, low, high); root->right = trimBST(root->right, low, high); return root; } }; Javascript var trimBST = function(root, low, high) { if(!root) { return null; } if(root.val high) { return trimBST(root.left, low, high); } root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; }; "},"medium/735.html":{"url":"medium/735.html","title":"735. Asteroid Collision(medium)","keywords":"","body":"735. Asteroid Collision Leetcode link 题目简介 /** * @param {number[]} asteroids * @return {number[]} */ 题目给我们一个数字数组表示一群行星，数组元素代表行星的大小，正负值代表行星前进方向，每个行星前进速度一致 如果大行星碰到小行星，则小行星消失、如果两个相同大小的碰撞则都消失 要求我们最后计算出来剩下的元素有哪些 解题思路 这题需要用到栈来求解，用一个栈 stack 来维护当前的行星 我们正常遍历数组，有三种情况我们可以直接入栈： 当前栈为空 当前栈顶是负的 当前遍历元素是正的 接下来我们需要考虑栈顶为正且当前遍历元素为负的情况，一共有三种： stack[stack.length - 1] > -asteroids[i]：栈顶比当前行星大，不需要做什么操作继续遍历 stack[stack.length - 1] ：栈顶比当前行星小，需要出栈并且重新遍历当前行星一次 stack[stack.length - 1] === -asteroids[i]：两个同体积行星碰撞，都消失，直接出栈当前栈顶即可 最后返回该栈即可 Javascript /** * @param {number[]} asteroids * @return {number[]} */ var asteroidCollision = function (asteroids) { const stack = [] for (let i = 0; i 0 ) { stack.push(cur) } else if(-cur === top) { stack.pop() } else if(top "},"medium/739.html":{"url":"medium/739.html","title":"739. Daily Temperatures(medium)","keywords":"","body":"739. Daily Temperatures Leetcode link 题目简介 /** * @param {number[]} temperatures * @return {number[]} */ 题目给我们一个数字数组 temperatures 代表每天的温度 要求我们返回一个新的数组，数组元素代表要多少天后才会升温 解题思路 这题暴力解法可以用双重循环来做，但也可以借助单调栈来减少一重循环的复杂度 核心思路是，我们在遍历每一个元素的时候，在入栈前判断当前栈顶元素是否比当前元素小，如果是的话需要依序出栈并计算下标的差保存起来 由于这么做栈中元素只会是单调递减的，所以这个栈也叫做单调栈 Javascript /** * @param {number[]} temperatures * @return {number[]} */ var dailyTemperatures = function (temperatures) { const len = temperatures.length const stack = [] const res = new Array(len).fill(0) for (let i = 0; i 0 && temperatures[stack[stack.length - 1]] "},"medium/763.html":{"url":"medium/763.html","title":"763. Partition Labels(medium)","keywords":"","body":"763. Partition Labels Leetcode link 题目简介 /** * @param {string} s * @return {number[]} */ 题目给我们字符串 s，要求我们讲 s 分割成多个子字符串，要求不同的子字符串中不能有相同的字符元素 而且分割后的子字符串可以按顺序拼回字符串 s 最后返回每段子字符串的长度 解题思路 我们使用贪心的思路： 遍历字符串 s，对于每一个字符 char，我们都去寻找其在 s 中最后一次出现的下标 一旦遍历的指针 i 等于最后一次出现的下标，就表示我们找到了一段符合题意的子字符串 为了计算该字符串长度，我们需要一个变量 start 来记录上一个满足条件子字符串的后面第一个下标 这么一来我们就可以用 i-start+1 来求得长度了 Javascript /** * @param {string} s * @return {number[]} */ var partitionLabels = function (s) { const len = s.length let left = 0 let right = 0 let lastIndices = new Map() const res = [] for (let i = 0; i "},"medium/769.html":{"url":"medium/769.html","title":"769. Max Chunks To Make Sorted(medium)","keywords":"","body":"769. Max Chunks To Make Sorted Leetcode link 题目简介 本题给了我们一个数组，要求我们对其分块后进行升序排列（分块就是将其拆分成任意长度的数组），要求分块后合并的排序结果要跟一开始的数组排序结果保持一致 解题思路 在题目的约束中，我们能够完成分块，有一个主要的原则：每个分块中，最小的数字必须在最后面，否则都能从该分块中拆出符合题目要求的别的分块来 基于这个原则我们来看一个例子：[0,1,4,3,2,5,6] 我们不难看出，这个例子最多能拆出 5 个分块：[0], [1], [4,3,2], [5], [6] 所以这题的难点在于要怎么把 [4,3,2] 这种情况判断出来 有意思的是，题目的限制给了我们线索，其中最关键的有两条： - 0 - 数组中任何数字都是唯一的 这两条告诉我们，数组的下标与数字是一一对应的 那么，我们只需要遍历数组，一旦数组当前遍历下标的和与数组当前遍历值的和相等时，则表示可以分块 拓展一下，如果没有这两个条件我们该怎么做？ 将原数组深拷贝成一个新数组，并将其排序 同时遍历新数组与原数组 一旦他俩遍历过元素的和相等，则表示可以分块 Javascript /** * @param {number[]} arr * @return {number} */ var maxChunksToSorted = function (arr) { let indexSum = 0 let valueSum = 0 let trunk = 0 for (let i = 0; i "},"medium/785.html":{"url":"medium/785.html","title":"785. Is Graph Bipartite?(medium)","keywords":"","body":"785. Is Graph Bipartite? Leetcode link 背景介绍 很调皮的一个题目 文字说明也很难懂。。。 简单来说题目提供一个二维数组，graph[0] 代表与第 0 个元素有无向边的元素集合，且每个两个元素之间最多有一条边，也有可能没有边 题目要求我们判断这个图是不是二分图：也就是能把图分成两个不相交的集合，使得同一集合的顶点之间不相连 解题思路——染色 我们把图染色，染色规则是：有边的两个点不能染同一个颜色 因为是二分图，所以我们的颜色有三种状态：0 表示未染色、1, -1分别代表两种不同颜色 一旦发现有两个相邻的元素被染了同一个颜色，表示这个图不是二分图，返回 false C++ class Solution { public: bool isBipartite(vector>& graph) { int n = graph.size(); vector colors(n); for (int i = 0; i >& graph, int color, int index, vector& colors) { if (colors[index] != 0) { return colors[index] == color; } colors[index] = color; for (int i : graph[index]) { if (!valid(graph, -color, i, colors)) { return false; } } return true; } }; Javascript /** * @param {number[][]} graph * @return {boolean} */ var isBipartite = function(graph) { let n = graph.length; let colors = new Array(n).fill(0); for (let i = 0; i 解题思路——并查集 与前面的染色思路相近，我们把连接到同一个节点的节点集合划分到一个组：graph[0] 是一个组，graph[1] 也是一个组。。。 接下来，我们只需要判断同一个组里的元素是否有相邻就好，如果有，则不是二分图 举个例子： graph[0] 的元素跟元素 0 如果在同一个组，则表示这个图不是二分图 C++ class UnionFind { private: vector root; vector rank; public: UnionFind(int size) : root(size), rank(size) { for (int i = 0; i = rank[rootY]) { root[rootY] = rootX; rank[rootX] += rank[rootY]; } else { root[rootX] = rootY; rank[rootY] += rank[rootX]; } } } }; class Solution { public: bool isBipartite(vector>& graph) { int n = graph.size(); UnionFind uf(n); for (int i = 0; i JS class UnionFind { constructor(size) { this.root = new Array(size); this.rank = new Array(size); for (let i = 0; i = this.rank[rootY]) { this.root[rootY] = rootX; this.rank[rootX] += this.rank[rootY]; } else { this.root[rootX] = rootY; this.rank[rootY] += this.rank[rootX]; } } } }; var isBipartite = function(graph) { let n = graph.length; let uf = new UnionFind(n); for (let i = 0; i "},"medium/820.html":{"url":"medium/820.html","title":"820. Short Encoding of Words(medium)","keywords":"","body":"820. Short Encoding of Words Leetcode link 解题思路 本题要求我们将一个字符串数组编码为一个用 # 区隔的长字符串 根据题目的描述，我们的出一个结论：当一个字符串是另一个字符串的后缀时，可以忽略它的长度 根据这个结论，我们可以使用字典树这个数据结构来求解 具体而言，我们可以用字符串倒叙的方式来组织字典树，举个例子： 数组 words 有两个元素 ['time', 'me', 'abe', 'el', bell]，按照字符串倒叙来组织字典树之后如下图所示 我们在组织完字典树的时候，顺便用变量 count 记录一下当前节点有多少子节点，比如 'me' 的 m 就有两个子节点 最后我们只需要判断 count 为 0 的字符串长度加一的总和就是我们的答案了 C++ class TrieNode { TrieNode* children[26]; public: int count; TrieNode() { for(int i = 0;i & words) { TrieNode* trie = new TrieNode(); unordered_map nodes; for(int i = 0;i = 0;j--) { cur = cur->add(word[j]); } nodes[cur] = i; } int res = 0; for(auto& [node, idx]: nodes) { if(node->count == 0) { res += words[idx].size() + 1; } } return res; } }; "},"medium/826.html":{"url":"medium/826.html","title":"826. Most Profit Assigning Work(medium)","keywords":"","body":"826. Most Profit Assigning Work Leetcode link 解题思路 本题题目有点难懂，而且中间有个小坑，我先来重新描述一下题目的要求： 首先题目规定了总共有 m 份工作与 n 个工人，并且给定了 difficulty，profit，worker 三个数组，其中： difficulty 代表工作的难度，限制长度为 m，与 profit 数组一一对应 profit 代表工作的报酬，限制长度为 m，与 difficulty 数组一一对应 worker 代表工人的技能水平，限制长度为 n 此外，题目还给了两个限制： 一个工人只能做一次工作，并且做的工作难度不能超过工人自身的技能水平（也就是 worker 数组的对应值） 一个工作可以被多个工人多次完成，并且报酬可以累加 题目要求在这些条件下，计算出所有工人可以获得最高利润的工作分配方法。 在题目中包含的内容只有这么多，但是在实际的测试 case 中，其实还有一个情况是题目忽略的： 相同难度的工作可能有多份，并且其报酬可能不唯一 了解了上述的要求之后，为了使利润最大化，我们需要让每一个工人做能力范围内利润最高的工作，那么我们需要遵循如下步骤： 先使用一个 Map 把所有工作的难度与利润一一对应起来（为了第二步排序之后还能保留对应关系） 给所有的工作难度从小到大排序 根据难度的排序遍历 Map，给所有难度对应的利润调整成：当前难度的工作所能获得的最高利润 遍历所有工人的能力，找出能力范围能获得的最高利润进行加总 Javascript /** * @param {number[]} difficulty * @param {number[]} profit * @param {number[]} worker * @return {number} */ var maxProfitAssignment = function(difficulty, profit, worker) { let result = 0; const difficulty2Profit = new Map(); for(let i=0;i profit[i]) continue; } difficulty2Profit.set(difficulty[i], profit[i]); } // sort the difficulty in ascending order difficulty.sort((a, b)=> a-b); // get the maximum profit base on previous difficulty for(let i=1;i curProfit) { difficulty2Profit.set(difficulty[i], prevProfit); } } // Calcutale the maximum profit for(let i=0;i=0;j--) { if(worker[i] >= difficulty[j]) { result += difficulty2Profit.get(difficulty[j]); break; } } } return result; }; "},"medium/912.html":{"url":"medium/912.html","title":"912. Sort an Array(medium)","keywords":"","body":"912. Sort an Array Leetcode link 题目简介 题目要求我们给数组升序排列，要求 nlogn 的时间复杂度以及不能使用内置排序方法 解题思路 直接快排秒了 Javascript /** * @param {number[]} nums * @return {number[]} */ var sortArray = function(nums) { return nums.quickSort(); }; Array.prototype.quickSort = function (left = 0, right = this.length - 1) { if (left >= right) { return this; } let i = left - 1; let j = right + 1; const pivot = this[Math.floor((i + j) / 2)]; while (i pivot); if (i "},"medium/923.html":{"url":"medium/923.html","title":"923. 3Sum With Multiplicity(medium)","keywords":"","body":"923. 3Sum With Multiplicity Leetcode link 解题思路 TC: ， M 是数组 arr 中最大的数 SC: ，M 是数组 arr 中最大的数 题目要求我们找出三个数之和为 target 的多种可能，且数组 arr 可能存在重复数字 我们可以观察一下题目给出的范围： 3 0 0 可能出现的数字范围 arr[i] 从 0 到 100，那么我们可以用 count[x] 来保存数字 x 在数组中出现的次数，对于每一个 x + y + z = target 组合，我们用数学方法来分析几种可能性的组合： x != y != z：有 种组合 x == y != z：有 种组合 x == y == z：有 种组合 x == y == z：有 种组合 最后把上述所有可能加总取模就好了。 C++ class Solution { public: int threeSumMulti(vector& arr, int target) { int MOD = 1e9 + 7; long res = 0; long count[101] = {0}; for (int num : arr) { count[num]++; } // x != y != z for (int x = 0; x = 0 && x Javascript /** * @param {number[]} arr * @param {number} target * @return {number} */ var threeSumMulti = function(arr, target) { const MOD = 1e9 + 7; let res = 0; let count = new Array(101).fill(0); for (let num of arr) { count[num]++; } // x != y != z for (let x = 0; x = 0 && x "},"medium/966.html":{"url":"medium/966.html","title":"966. Vowel Spellchecker(medium)","keywords":"","body":"966. Vowel Spellchecker Leetcode link 题目简介 题目给我们两个参数： wordlist：一个字符串数组，表示我们有的字典 queries：一个字符串数组，表示我们要用来查询字典的字符串 由于 queries 中的字符串可能会出现一些母音字母的笔误，所以我们需要设计一个算法来输出每一个查询字符串的正确字符串 输出字符串的规则如下： 如果查询字符串在大小写敏感的情况下完全符合字典的某个字符串，直接返回该字符串 如果查询字符串在大小写不敏感的情况下符合字典某个字符，返回字典出现的第一个对应的字符串 如果查询字符串某些母音字符误写成了其他的母音字符（允许大小写不敏感），返回字典出现的第一个对应字符串 如果以上都不成立，则返回空字符串 解题思路 根据上述规则，我们能很快写出一个该逻辑的算法，但是直接写出来的算法复杂度会是 $O(W \\times Q \\times N)$ 其中 W 代表 wordlist.length，Q 代表 queries.length，N 代表所有 wordlist 字符串的平均长度 所以我们需要采取一些空间换时间的策略 这个策略分成两个部分：数据预处理、查询 数据预处理 首先为了应对第一种情况，我们可以将 wordlist 用一个 Set 保存，这种情况下我们查找任意一个 Query 的复杂度是 $O(1)$ 其次为了应付第二种情况，我们可以用一个 Map 来保存所有字典字符串到全小写字典字符串的映射 第三种情况也是可以用一个 Map 来保存所有字典字符串到归一化母音字符串（把字符串中的母音字符都用一个符号代替）的映射 这个部份的时间复杂度是 $O(W \\times N)$、空间复杂度是 $O(W \\times N)$ 查询 我们只需要遍历 queries 分别在 Set 与两个 Map 中寻找符合条件的字符就好 这个部份的时间复杂度是 $O(Q \\times N)$ 这样一来我们的算法时间复杂度就降低到了 $O((Q + W) \\times N)$ Javascript /** * @param {string[]} wordlist * @param {string[]} queries * @return {string[]} */ var spellchecker = function(wordlist, queries) { const wordSet = new Set(wordlist) const caseInsensitiveMap = new Map() const vowelInsensitiveMap = new Map() const res = [] const equalizeVowels = word => word.toLowerCase().replace(/[aeiou]/g, '@') wordlist.forEach(word => { const lowerCaseWord = word.toLowerCase() if(!caseInsensitiveMap.has(lowerCaseWord)) { caseInsensitiveMap.set(lowerCaseWord, word) } const equalVowelWord = equalizeVowels(word) if(!vowelInsensitiveMap.has(equalVowelWord)) { vowelInsensitiveMap.set(equalVowelWord, word) } }) for(const q of queries) { // 1. exactly match if(wordSet.has(q)) { res.push(q) continue } // 2. case-independant match const lowerCaseQuery = q.toLowerCase() if(caseInsensitiveMap.has(lowerCaseQuery)) { res.push(caseInsensitiveMap.get(lowerCaseQuery)) continue } // 3. vowel error match const equalVowelQuery = equalizeVowels(q) if(vowelInsensitiveMap.has(equalVowelQuery)) { res.push(vowelInsensitiveMap.get(equalVowelQuery)) continue } // 4. no match res.push('') } return res }; "},"medium/994.html":{"url":"medium/994.html","title":"994. Rotting Oranges(medium)","keywords":"","body":"994. Rotting Oranges Leetcode link 题目简介 /** * @param {number[][]} grid * @return {number} */ 题目给我们一个二维数字数组 grid，其中元素有三种可能： 0:表示当前格子是空的 1:表示当前格子有一个新鲜橘子 2:表示当前格子有一个腐烂的橘子 每一分钟过去，腐烂的橘子都会让其上下左右的新鲜橘子腐烂 题目要求我们计算需要用多少时间才能把所有橘子腐烂 如果没办法把所有橘子腐烂则需要返回 -1 解题思路 我们可以遍历整个 grid，对每个腐烂的橘子使用 dfs 遍历起上下左右的新鲜橘子，同时记录时间 不过我们还需要考虑到这种可能性： 211 111 012 所以我们需要加入一个判断：如果有橘子被其他橘子腐烂了，且用时更短，我们需要记录较短的用时 最后，我们需要再次遍历所有的 grid，如果有发现还有新鲜橘子则返回 -1，否则返回用时 Javascript /** * @param {number[][]} grid * @return {number} */ var orangesRotting = function (grid) { const height = grid.length const width = grid[0].length const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]] const dfs = (row, col, minute) => { // grid[row][col] > 1 && grid[row][col] = height || col = width || grid[row][col] === 0 || (grid[row][col] > 1 && grid[row][col] "},"medium/1004.html":{"url":"medium/1004.html","title":"1004. Max Consecutive Ones III(medium)","keywords":"","body":"1004. Max Consecutive Ones III Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {number} */ 题目给我们一个只包含 0 或 1 的数字数组 nums 以及一个数字 k 要求我们计算最多可以反转 k 个 0 为 1 的情况下，最长且连续为 1 的子数组长度是多少 解题思路 这题的主要思路为滑动窗口，而且是不定长的滑动窗口 我们在构建滑动窗口的时候需要注意两点： 窗口中不能含有超过 k 个 0 窗口的左右边界必须是 0 或者数组边界（要包含所有可能的 1） 滑动窗口由两个阶段构成： 扩张：如果当前窗口 0 的个数小于 k，则可以持续扩张 收缩：如果当前窗口的 0 个数为 k 时，我们需要收缩窗口直到个数小于 k 最后我们需要一个变量记录最长的窗口长度 Javascript /** * @param {number[]} nums * @param {number} k * @return {number} */ var longestOnes = function (nums, k) { let res = 0 let left = 0 for (let right = 0; right 0) { k-- } res = Math.max(res, right - left + 1) } return res }; "},"medium/1015.html":{"url":"medium/1015.html","title":"1015. Smallest Integer Divisible by K(medium)","keywords":"","body":"1015. Smallest Integer Divisible by K Leetcode link 题目简介 /** * @param {number} k * @return {number} */ 题目给我们一个数字 k，要求我们判断是否有只由 1 组成的十进制数字可以整除 k 解题思路 我们知道，当除数是 k 的时候，余数最多有 k 种（0～k-1） 所以我们可以知道，如果我们循环了 k 次还没有结束（k 还不能被整除），那么就不可能有数字被 k 整除 Javascript /** * @param {number} k * @return {number} */ var smallestRepunitDivByK = function(k) { let remainder = 0; for(let i = 1; i "},"medium/1029.html":{"url":"medium/1029.html","title":"1029. Two City Scheduling(medium)","keywords":"","body":"1029. Two City Scheduling Leetcode link 解题思路 题目叫我们把一半的人安排到 a 市，一半的人安排到 b 市，那我们可以针对去 a 市的成本 aCost 与去 b 市的成本 bCost 求差值之后升序排序来确定去 a 市的名单，剩下的一半则是去 b 市的名单。 使用 aCost - bCost 之后由小到大排序是因为当去 a 市的成本与去 b 市的成本少的越多（差值越大）很显然我们应该优先安排该候选人去 a 市（机会成本更小一点） C++ bool comparator(vector &a, vector &b) { if (a[0] - a[1] > &costs) { // 排序 sort(costs.begin(), costs.end(), comparator); int result = 0, n = costs.size() / 2; // 只遍历一半的 vector，前面的一半去 a 市，后面的一半去 b 市 for (int i = 0; i Javascript /** * @param {number[][]} costs * @return {number} */ var twoCitySchedCost = function(costs) { costs.sort((a,b)=> (a[0]-a[1]) - (b[0]-b[1])); let result = 0, len = costs.length / 2; for(let i=0;i "},"medium/1039.html":{"url":"medium/1039.html","title":"1039. Minimum Score Triangulation of Polygon(medium)","keywords":"","body":"1039. Minimum Score Triangulation of Polygon Leetcode link 题目简介 题目给我们一个参数数组 values 代表一个凸多边形的顶点集合，数组的顺序代表了多边形沿顶点顺时针的顶点的价值 题目要求我们对多边形进行三角剖分（将其分割成多个三角形）剖分出的三角形的价值是三个顶点价值的乘积 最后我们需要求出所有三角形价值之和最小的值是多少 解题思路 这一题需要慢慢推导，我们先从三角形开始：假设一开始题目给了三个顶点 [1,2,3] 则这个三角形的价值就是三个顶点相乘，也就是 6 接下来是正方形 [3,7,4,5]： 3--7 | | 5--4 我们可以选取相邻的两个点 [3, 5] 他们会组成一条边，基于这条边，我们可以再任意选取一点（假设是 7） 此时我们可以将正方形剖分成两个三角形：[3, 5, 7]，[5, 7, 4] 此时我们已经将问题拆分成了处理三角形的模式 接下来我们来看看正五边形： 1 / \\ 5 2 \\ / 4-3 我们一样可以选取相邻的两个点 [1, 5]，基于这条边我们再任意选取一个点（假设是 3） 此时我们可以将正五边形拆分成一个三角形 [1, 5, 2] 以及一个四边形 [5, 2, 3， 4] 其中三角形我们可以用一开始的方式来处理、四边形也可以继续用上面方式处理…… 看到规律了吧！ 接下来我们来聊聊怎么构建这个算法 这个算法的初始是由两个点组成的，我们可以使用一个二维数组 dp[i][j] 来表示点 [i, j] 组成的边进行剖分之后的价值 这两个点我们选择数组的第一个以及最后一个元素（因为这样一来我们可以通过 j-i 来判断剩下的点是否可以组成三角形） 然后我们需要构建一个 helper 函数使用递归的方式慢慢剖分多边形 Javascript /** * @param {number[]} values * @return {number} */ var minScoreTriangulation = function (values) { const len = values.length const dp = new Array(len).fill().map(item => new Array(len).fill(0)) return helper(dp, values, 0, len - 1) }; const helper = (dp, values, i, j) => { // cannot form triangles if (j - i "},"medium/1048.html":{"url":"medium/1048.html","title":"1048. Longest String Chain(medium)","keywords":"","body":"1048. Longest String Chain Leetcode link 解题思路 本题要求我们求出给定字符串数组的最长词链；词链中每一个元素都是后一个元素的前身；前身指的是在给定字符串不改变顺序的情况下删除任意一个字符构成的新字符串 首先，由于词链中元素的长度一定是从小到大且每个元素长度都是前一个长度加一，所以我们需要先对 words 排序 排完序之后，我们考虑动态规划的方法，创建一个数组 dp，其中 dp[i] 表示排序后的 words 数组中第 i 个元素的最长词链长度 有了 dp 之后，我们可以方便的得出，假设有个新字符串 words[j]，且它是 words[i] 的前身，则 dp[i] = max(dp[i], dp[j] + 1) 最后，如果字符串 a 是 b 的前身，要满足两个条件： a 的长度只能是 b 的长度减一 a 中的字符必须按顺序出现在 b 中 C++ class Solution { public: int longestStrChain(vector& words) { sort(words.begin(), words.end(), [](const string& a, const string& b){ return a.size() dp(len, 1); int res = 1; for(int i = 0;i = 0;j--) { if(isPredecessor(words[j], words[i])) { dp[i] = max(dp[i], dp[j] + 1); } } res = max(res, dp[i]); } return res; } bool isPredecessor(const string& s1, const string& s2) { if(s1.size() != s2.size() - 1) { return false; } int i = 0; for(int j = 0;j Javascript /** * @param {string[]} words * @return {number} */ var longestStrChain = function (words) { words.sort((a, b) => a.length - b.length); let len = words.length; let dp = new Array(len).fill(1); let res = 1; for (let i = 1; i = 0; j--) { if (isPredecessor(words[j], words[i])) { dp[i] = Math.max(dp[i], dp[j] + 1); } } res = Math.max(dp[i], res); } return res; }; var isPredecessor = function (str1, str2) { // predecessor 最多允许少一个字符 if (str1.length !== str2.length - 1) { return false; } let i = 0; for (let j = 0; j "},"medium/1052.html":{"url":"medium/1052.html","title":"1052. Grumpy Bookstore Owner(medium)","keywords":"","body":"1052. Grumpy Bookstore Owner Leetcode link 解题思路 本题题目说的有点模糊，我简单用自己的语言描述一下题意 题目给了我们三个参数： customers：Array，代表在第 n 分钟进来的客人数量，所有的客人都会一直呆到关门 grummpy：Array，取值为 0 或 1，0 代表店主脾气很好，此时客人会很满意；1 代表此时店主脾气暴躁，此时进来的客人会很不满（但是不会离开，也不会影响之前或之后进来的客人） minutes：Number，店主得到高人指点，习得了抑制脾气的方法（参考班纳压抑绿巨人的情况）但是这个方法只能持续一段固定的连续时间，这段时间的长度就是 minutes 题目要求我们求店主最多能让多少顾客满意 这一题最主要的思路就是把固定的部分与变化的部分分开计算： 固定的部分：指的是店主脾气好的时候进来的客人，这一组客人始终都是满意的 变化的部分：值得是店主脾气不好的时候进来的客人，这一部分客人的满意度取决于店主有没有在这个时间段使用技巧 固定的部分很好计算，只要把 grumpy 是 0 的时间段进来的客人数量全部加起来就好 变化的部分就需要用到滑动窗口来求解了，我们把 minutes 的长度当成窗口，通过窗口的滑动来计算每一个窗口能让本来不满意的顾客（grumpy 为 0 的时候进来的顾客）满意的数量，最后求所有可能的最大值就好 为了方便理解，我写了两个版本，第一个版本用到了两次循环，更加方便理解；第二个版本直接把两个循环合在一起了，复杂度降低胃了 O(n) Javascript——方便理解版 /** * @param {number[]} customers * @param {number[]} grumpy * @param {number} minutes * @return {number} */ var maxSatisfied = function (customers, grumpy, minutes) { // calculate the initial satisfication for all customers let initSatisfication = 0; for (let i = 0; i Javascript——时间复杂度 O(n) 版 /** * @param {number[]} customers * @param {number[]} grumpy * @param {number} minutes * @return {number} */ var maxSatisfied = function (customers, grumpy, minutes) { // use for sliding window let left = 0, right = 0; // satisfication without technique let initSatisfication = 0; // satisfication using technique let extra = 0, maxExtra = 0; while (right = minutes - 1) { maxExtra = Math.max(extra, maxExtra); } right++; } return initSatisfication + maxExtra; } "},"medium/1091.html":{"url":"medium/1091.html","title":"1091. Shortest Path in Binary Matrix(medium)","keywords":"","body":"1091. Shortest Path in Binary Matrix Leetcode link 解题思路 题目要求我们从给定的一个 n*n 的格子里面找出一条最短的从左上角到右下角的路径（这个路径只能由 0 构成且可以往 8 个方向走） 这种题目可以用 bfs 来做，我们把起始点当成第一层，起始点能到的地方当成第二层，以此类推 每次都遍历完同一层之后再遍历下一层，这样一来，只要碰到了右下角的格子，当前的层数就是我们要的最短路径长 C++ class Solution { public: int shortestPathBinaryMatrix(vector>& grid) { int size = grid.size(); int level = 0; queue> q; vector> visited(size, vector(size, false)); if(grid[0][0] == 0) { q.push({0, 0}); visited[0][0] = true; } while(!q.empty()) { level++; int n = q.size(); for(int i = 0;i node = q.front(); q.pop(); int x = node.first, y = node.second; if(x == size-1 && y == size-1) { return level; } for(int j = x-1;j>& grid, vector> &visited) { int size = grid.size(); return x>=0 && x = 0 && y Javascript /** * @param {number[][]} grid * @return {number} */ var shortestPathBinaryMatrix = function (grid) { let size = grid.length; // 记录当前元素访问状态 let visited = new Array(size); for (let i = 0; i 0) { let len = queue.length; level++; for (let i = 0; i = 0 && y >= 0 && x "},"medium/1110.html":{"url":"medium/1110.html","title":"1110. Delete Nodes And Return Forest(medium)","keywords":"","body":"1110. Delete Nodes And Return Forest Leetcode link 解题思路 本题要求我们 “去除” 二叉树中的某些点，然后按照任意顺序返回剩余的根结点们（就有点像是把一棵树砍了然后把树枝重新种下的感觉） 本题的难点主要在于，我们要怎么在遍历二叉树的同时把对应节点的引用处理好 首先我们会需要一个遍历函数 delNode，我们采取迭代的方式遍历 在遍历中，我们需要判断当前节点是否需要被删除： 如果不需要则正常遍历 如果需要，则要给当前节点的父节点返回 null；然后，在遍历到当前节点的子节点时，需要把他们加到返回的数组中 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number[]} to_delete * @return {TreeNode[]} */ var delNodes = function(root, to_delete) { const result = []; const delNode = (node, isRoot) => { if(!node) return null; // 判断当前节点是否需要被删除 const shouldDel = to_delete.includes(node.val); // 如果当前节点的上个节点被删除，且当前节点需要保留，则判断当前节点是一个新的根结点，需要返回 if(isRoot && !shouldDel) { result.push(node); } // 正常遍历 node.left = delNode(node.left, shouldDel); node.right = delNode(node.right, shouldDel); // 如果当前节点被删除了，需要给当前节点父节点返回 null return shouldDel ? null : node; } delNode(root, true); return result; }; "},"medium/1143.html":{"url":"medium/1143.html","title":"1143. Longest Common Subsequence(medium)","keywords":"","body":"1143. Longest Common Subsequence Leetcode link 题目简介 /** * @param {string} text1 * @param {string} text2 * @return {number} */ 题目给我们两个字符串 text1 与 text2 要求我们找到两个字符串的最长公共子序列 子序列指的是字符串在删除某些元素后，且不改变元素顺序的情况下产生的新字符串 解题思路 我们可以用 dp 的思路来做这道题 dp 数组是一个二位数组，dp[i][j] 用来记录 text1[0..i] 与 text2[0..j] 的最长公共子序列长度 转移方程如下： 如果 text1[i] === text2[j]，dp[i][j] = dp[i-1][j-1]+1 否则，dp[i][j] = min(dp[i-1][j], dp[i][j-1]) 为了方便计算，我们给 dp 加一行一列并初始化为 0 Javascript /** * @param {string} text1 * @param {string} text2 * @return {number} */ var longestCommonSubsequence = function (text1, text2) { const len1 = text1.length const len2 = text2.length const dp = Array.from({ length: len1 + 1 }, _ => new Array(len2 + 1).fill(0)) for (let row = 1; row "},"medium/1161.html":{"url":"medium/1161.html","title":"1161. Maximum Level Sum of a Binary Tree(medium)","keywords":"","body":"1161. Maximum Level Sum of a Binary Tree Leetcode link 题目简介 /** * @param {TreeNode} root * @return {number} */ 题目给我们一个二叉树的根节点 root 要求我们将树的每一层加总，并且返回和最大且层数最小的层（根节点是第 1 层） 解题思路 需要把树的同一层元素值加总，我们使用 BFS 来做 在 BFS 的时候，我们需要 max 来表示当前最大的和是多少；curLayer 记录当前遍历到哪一层了 如果当前层的和大于 max，我们需要更新 max 与返回值 res 最后遍历结束后我们返回 res 即可 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var maxLevelSum = function (root) { const queue = [root] let max = Number.MIN_SAFE_INTEGER let curLayer = 1 let res = 1 while (queue.length > 0) { const size = queue.length let sum = 0 for (let i = 0; i max) { res = curLayer max = sum } curLayer++ } return res }; 复杂度分析 假设 n 代表树的节点个数 时间 因为我们需要遍历完完整的树，所以时间复杂度是 O(n) 空间 空间复杂度主要取决于 queue 数组，其复杂度为 O(w)，其中 w 代表树的最宽宽度 最坏的情况，会是 O(n) "},"medium/1190.html":{"url":"medium/1190.html","title":"1190. Reverse Substrings Between Each Pair of Parentheses(medium)","keywords":"","body":"1190. Reverse Substrings Between Each Pair of Parentheses Leetcode link 解题思路 题目要求我们翻转括号内的字符串 这一题的关键在于，如何处理三种不同的情况： 遇到 (：我们需要维护一个栈，把 ( 之前的字符串存起来 遇到 )：把之前遍历过的 ( 之后的字符串翻转一次，并且从栈顶拿到字符串拼接到反转后的字符串前 遇到一般字符：用一个字符串变量保存起来 Javascript /** * @param {string} s * @return {string} */ var reverseParentheses = function(s) { const stack = []; let result = ''; for(const c of s) { switch(c) { case '(': stack.push(result); result = ''; break; case ')': result = result.split('').reverse().join(''); const lastStr = stack.pop(); if(lastStr) { result = lastStr + result; } break; default: result = result + c; } } return result; }; "},"medium/1202.html":{"url":"medium/1202.html","title":"1202. Smallest String With Swaps(medium)","keywords":"","body":"1202. Smallest String With Swaps Leetcode link 解题思路 题目给了我们一个字符串，并且给了多个可以多次交换的字符串下标，要求我们经过一连串交换之后返回字典序最小的字符串。 首先我们需要知道一件事：交换是有传递性的。 也就是说，如果有可交换下标 [a,b] 与[b,c]，那么 a 与 c 也是可以交换的（通过 b） 所以，我们可以把所有可以互相交换的字符下标收集起来，称为一个组。 将所有的字符下标都收集完了之后，我们对每个组内都以字典序排序，然后按照顺序放回原来在的下标，就是题目所求了。 针对上面的思路，我们使用并查集数据结构。 C++ class UnionFind { private: vector root; vector rank; public: UnionFind(int size) : root(size), rank(size) { for (int i = 0; i = rank[rootY]) { root[rootY] = rootX; rank[rootX] += rank[rootY]; } else { root[rootX] = rootY; rank[rootY] += rank[rootX]; } } } }; class Solution { public: string smallestStringWithSwaps(string s, vector>& pairs) { int n = s.size(); UnionFind uf(n); // 给所有字符分组（保存下标） for (auto& edge : pairs) { uf.unionSet(edge[0], edge[1]); } // 建立组长->组员的映射（保存下标） unordered_map> groups; for (int i = 0; i indics = group.second; // 把每一组的成员按照字典顺序排列 vector chars; for (int index : indics) { chars.push_back(s[index]); } sort(chars.begin(), chars.end()); // 把排列好的字符放回对应的位置 for (int i = 0; i Javascript class UnionFind { constructor(size) { this.root = new Array(size); this.rank = new Array(size); for (let i = 0; i = this.rank[rootY]) { this.root[rootY] = rootX; this.rank[rootX] += this.rank[rootY]; } else { this.root[rootX] = rootY; this.rank[rootY] += this.rank[rootX]; } } } } var smallestStringWithSwaps = function (s, pairs) { const n = s.length; const uf = new UnionFind(n); // 给所有字符分组（保存下标） for (let edge of pairs) { uf.unionSet(edge[0], edge[1]); } // 建立组长->组员的映射（保存下标） let groups = {}; for (let i = 0; i a.charCodeAt('0') - b.charCodeAt('0')); // 把排列好的字符放回对应的位置 for (let i = 0; i "},"medium/1209.html":{"url":"medium/1209.html","title":"1209. Remove All Adjacent Duplicates in String II(medium)","keywords":"","body":"1209. Remove All Adjacent Duplicates in String II Leetcode link 解题思路 题目要求我们去掉字符串重复 k 次的字符，需要注意的是每次删除完字符之后还要重新检查新的字符串是否还存在重复 k 次的字符 我们可以用栈来做这道题，栈内存放 字符 - 连续出现个数 的集合，当连续出现个数等于 k 的时候，就可以把这一组集合出栈了 最后，我们根据栈内的信息重新还原字符串就好 C++ class Solution { public: string removeDuplicates(string s, int k) { stack> st; for (int i = 0; i 0) { st.push({s[i], count}); } } // 最后根据栈内信息还原字符串 string res = \"\"; while (!st.empty()) { auto top = st.top(); while (top.second-- > 0) { res += top.first; } st.pop(); } reverse(res.begin(), res.end()); return res; } }; Javascript var removeDuplicates = function(s, k) { let stack = []; for (let i = 0; i 0) { stack.push([s[i], count]); } } // 最后根据栈内信息还原字符串 let res = \"\"; while (stack.length!==0) { let [ch, count] = stack[stack.length-1]; while (count-- > 0) { res = ch + res; } stack.pop(); } return res; }; "},"medium/1262.html":{"url":"medium/1262.html","title":"1262. Greatest Sum Divisible by Three(medium)","keywords":"","body":"1262. Greatest Sum Divisible by Three Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 本题给我们一个数字数组 nums，要求我们算出 nums 中最大的可以被 3 整除的和是多少 解题思路 我们假设数组 nums 所有元素总和为 sum，sum 除以 3 的余数可能为 0，1，2 如果余数为 1，有两种方式可以让 sum 可以被 3 整除： 我们从数组中选出余数为 1 的元素中最小的元素（假设是 num1），sum - num1 可以被 3 整除 我们从数组中选出余数为 2 的元素，然后选取其中最小的两个元素（假设是 num2, num3），sum - (num2 + num3) 可以被 3 整除 我们要做的，就是在 num1 与 num2 + num3 中找出一个最小值，使得剩下的 sum 值最大化 余数为 2 的情况正好与余数为 1 的情况相反 Javascript /** * @param {number[]} nums * @return {number} */ var maxSumDivThree = function (nums) { // the max possible of nums[i] let remain1 = remain2 = 10 ** 4 let sum = 0 // if sum of nums' remainder is 1, there are two posibilities: // 1. We select one smallest element in the array with a remainder of 1 // 2. We select two smallest elements in the array with a remainder of 2 // we want to choose the minimum(**remain1**) so the sum can be as big as possible // -------- // if sum of nums' remainder is 2, vice versa // the minumum should be **remain2** nums.forEach(num => { sum += num if (num % 3 === 1) { remain2 = Math.min(remain2, remain1 + num) remain1 = Math.min(remain1, num) } else if (num % 3 === 2) { remain1 = Math.min(remain1, remain2 + num) remain2 = Math.min(remain2, num) } }) switch (sum % 3) { case 0: return sum case 1: return sum - remain1 case 2: return sum - remain2 } }; "},"medium/1268.html":{"url":"medium/1268.html","title":"1268. Search Suggestions System(medium)","keywords":"","body":"1268. Search Suggestions System Leetcode link 解题思路 本题要求我们实现一个搜索推荐系统，要求输入每一个字符都要展示前三个搜索结果（字典序排序） 这种逐个字符搜索的题目很适合使用 字典树 来求解，对于字典树中任意一个 node 节点，从根节点到它的字符串称为 prefix 另外，因为要逐个展示搜索结果，所以我们需要额外使用一个优先队列来保存三个以当前 prefix 为开头的字符串 C++ // 字典树结构 struct Trie { unordered_map child; priority_queue words; }; class Solution { public: void addWord(Trie* root, const string& word) { Trie* cur = root; for(const char& c : word) { if(!cur->child.count(c)) { cur->child[c] = new Trie(); } cur = cur->child[c]; // 额外维护一个优先队列保存当前 prefix 的前三个字符串 cur->words.push(word); if(cur->words.size() > 3) { cur->words.pop(); } } } vector> suggestedProducts(vector& products, string searchWord) { Trie* root = new Trie(); for(const string& word: products) { addWord(root, word); } vector> ans; Trie* cur = root; // 标记字典树的结尾 bool flag = false; for(const char& c: searchWord) { if(flag || !cur->child.count(c)) { ans.push_back({}); flag = true; } else { cur = cur->child[c]; vector selects; while(!cur->words.empty()) { selects.push_back(cur->words.top()); cur->words.pop(); } reverse(selects.begin(), selects.end()); ans.push_back(move(selects)); } } return ans; } }; "},"medium/1302.html":{"url":"medium/1302.html","title":"1302. Deepest Leaves Sum(medium)","keywords":"","body":"1302. Deepest Leaves Sum Leetcode link 解题思路 这道题可以用队列与递归两种方法来写，因为思路很简单我用 C++ 实现了队列；用 js 实现递归 队列的话记得把每一行的最后一个元素后面插入一个空指针判别一行的结束 递归的话需要额外的一个变量来记录最深的层数，只需要记录最深那一层的加总就好 C++——队列 class Solution { public: int deepestLeavesSum(TreeNode* root) { queue pq; int sum = 0; pq.push(root); pq.push(nullptr); while(pq.size() > 1) { TreeNode* node = pq.front(); pq.pop(); if(node == nullptr) { pq.push(nullptr); sum = 0; continue; } sum+=node->val; if(node->left) { pq.push(node->left); } if(node->right) { pq.push(node->right); } } return sum; } }; Javascript——递归 var deepestLeavesSum = function(root) { let deepestLevel = 1; let sum = 0; let dfs = (node, level) => { if(!node) { return; } dfs(node.left, level+1); if(level > deepestLevel) { deepestLevel = level; sum = node.val; } else if(level == deepestLevel) { sum += node.val; } dfs(node.right, level+1); } dfs(root, 1); return sum; }; "},"medium/1352.html":{"url":"medium/1352.html","title":"1352. Product of the Last K Numbers(medium)","keywords":"","body":"1352. Product of the Last K Numbers Leetcode link 题目简介 本题要求我们实现一个类，这个类有着两个功能：添加数字、计算最后 k 个数字的乘积 解题思路 为了最大化减小计算开销，我们可以额外使用一个数组，来保存每一个数字与前面所有数字的乘积 举个例子，如果题目给的数字是：[1,2,3,4]，那么这个数组保存的就是：[1,2,6,24] 这样一来，如果我们要计算后两位的乘积，直接使用 24 / 2 就可以了 但是这个方案还有一个小问题，那就是 0 如果遇到了 0，那么 0 前面的所有乘积都会变成 0，所以在遇到 0 的时候，我们需要将整个保留乘积的数组恢复初始值 [1] 然后我们加一个判断条件，如果当前要求的 k 大于等于当前乘积数组的长度时，直接返回 0，否则就用除法得出答案 Javascript var ProductOfNumbers = function() { // 初始值 this.product = [1] }; /** * @param {number} num * @return {void} */ ProductOfNumbers.prototype.add = function(num) { if(num === 0) { this.product = [1] } else { this.product.push(num * this.product[this.product.length - 1]) } }; /** * @param {number} k * @return {number} */ ProductOfNumbers.prototype.getProduct = function(k) { if(k "},"medium/1372.html":{"url":"medium/1372.html","title":"1372. Longest ZigZag Path in a Binary Tree(medium)","keywords":"","body":"1372. Longest ZigZag Path in a Binary Tree Leetcode link 题目简介 /** * @param {TreeNode} root * @return {number} */ 题目给我们一个二叉树的根节点 root 要求我们计算出这棵树最长的交互路径是多少 交互路径指的是我们沿着二叉树任意节点，走左节点、右节点、左节点……直到遇到 null 路径的长度指的是路径上节点个数 - 1 最后返回最长的路径长度 解题思路 要求树的路径长度（深度）第一反应就是 DFS 这题算是 DFS 的变体，在 DFS 的过程中，我们需要额外记录两个信息： 当前遍历的方向（左还是右） goLeft 当前满足交互路径的长度 len 此外，在 DFS 过程中我们需要考虑两种情况： 我们继续沿着交互的方式走（当前是左接下来走右；反之亦然） 我们重新开始，沿着不交互的方式走（当前是左接下来继续往左；反之亦然） 这两种情况加上当前走的方向，我们可以总结出 4 种走法 接下来遍历左节点 加下来遍历右节点 当前遍历左节点 刷新 len 的值 len+1 当前遍历右节点 len+1 刷新 len 的值 最后，我们需要一个全局的 res 来保存最长的结果，并且在每次遍历新节点的时候更新它的值 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var longestZigZag = function (root) { let res = 0 // goLeft means next direction const dfs = (node, goLeft, len) => { if (!node) { return } res = Math.max(len, res) if (goLeft) { // we go left now, so the next dirextion should be right dfs(node.left, false, len + 1) // since we don't go left, this node should be the first node dfs(node.right, true, 1) } else { dfs(node.right, true, len + 1) dfs(node.left, false, 1) } } // assume we first go right dfs(root.right, true, 1) // assume we first go left dfs(root.left, false, 1) return res }; 复杂度分析 假设树的节点数量为 n 时间 我们需要遍历树的每个节点两次，所以是 O(n) 空间 由于是迭代方式遍历树，复杂度取决于树的高度，平均情况为 O(log n)，最差的情况为 O(n) "},"medium/1379.html":{"url":"medium/1379.html","title":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree(medium)","keywords":"","body":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree Leetcode link 解题思路 题目给了我们两棵一模一样的树，并且将一个指针 target 指向了原树的其中一个节点，要求我们找到拷贝树上对应的节点 这种题目一般用 bfs 或者 dfs 来求解，一种简单的思路就是： 遍历拷贝的树，当遇到与 target 指针指向的值一样的树节点的时候，返回拷贝树对应的节点指针 但是这个思路有一个限制条件，就是树上不能有两个值相同的节点。 所以在这里我们用同时遍历两棵树的方法，详情见代码： C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) { TreeNode* res = nullptr; dfs(original, cloned, target, res); return res; } // 记得这里的 res 需要使用引用，因为我们需要记录 res 指针存放的地址 void dfs(TreeNode* original, TreeNode* cloned, TreeNode* target, TreeNode*& res) { // 如果已经找到了 res，就没必要继续下去了 if(original == nullptr || res != nullptr) { return; } // 当原树的节点等于目标节点的时候，拷贝树的对应节点就是我们的解 if(original == target) { res = cloned; return ; } dfs(original->left, cloned->left, target, res); dfs(original->right, cloned->right, target, res); } }; "},"medium/1396.html":{"url":"medium/1396.html","title":"1396. Design Underground System(medium)","keywords":"","body":"1396. Design Underground System Leetcode link 解题思路 题目要求我们实现一个 UndergroundSystem 类，该类有三个方法： checkIn：记录某个用户的 id，进站的站名，进站的时间 checkOut：记录某个用户的 id，出站的站名，出站的时间 getAverageTime：返回所有直接从站 A 到坐到站 B 的乘客所花的平均时间 另外题目还保证了用户只要进站就会出站，且出站时间一定比进站时间晚。 有了以上信息，我们可以构造两个映射表： routeTime：它保存了从站 A 到站 B 的路线名称与记录所有旅客旅行时间的数组 { “startStation_endStation”: [routeTime1, routeTime2, ...] } checkInInfo：它保存了用户 A 的 Uid 与进站站名，进站时间 { Uid: [stationName, time] } 下一步，我们可以借助映射表保存的数据，对三个方法进行操作： checkIn：把用户的 id，进站的站名，进站的时间保存到 checkInInfo 中 checkOut：根据 checkInInfo，找出有同样 id 的进站用户，拼接进出站名称，然后跟经过时间一起保存到 routeTime 中 getAverageTime：根据 routeTime 中的数据，给用户的旅行时间求一个平均值并返回 C++ class UndergroundSystem { private: // {startStation_endStation: [routeTime1, routeTime2, ...]} unordered_map> routeTime; // {Uid: [stationName, time]} unordered_map> checkInInfo; public: UndergroundSystem() {} void checkIn(int id, string stationName, int t) { checkInInfo[id] = {stationName, t}; } void checkOut(int id, string stationName, int t) { string station = checkInInfo[id].first + \"_\" + stationName; int time = t - checkInInfo[id].second; routeTime[station].push_back(time); } double getAverageTime(string startStation, string endStation) { string station = startStation + \"_\" + endStation; int totalTime = 0; int count = 0; for (auto &time : routeTime[station]) { totalTime += time; count++; } // 题目要求输出 double return (double)totalTime / count; } }; Javascript var UndergroundSystem = function() { // {startStation_endStation: [routeTime1, routeTime2, ...]} this.routeTime = {}; // {Uid: [stationName, time]} this.checkInInfo = {}; }; /** * @param {number} id * @param {string} stationName * @param {number} t * @return {void} */ UndergroundSystem.prototype.checkIn = function(id, stationName, t) { this.checkInInfo[id] = [stationName, t]; }; /** * @param {number} id * @param {string} stationName * @param {number} t * @return {void} */ UndergroundSystem.prototype.checkOut = function(id, stationName, t) { const station = this.checkInInfo[id][0] + \"_\" + stationName; const time = t - this.checkInInfo[id][1]; (this.routeTime[station] === undefined) && (this.routeTime[station] = []); this.routeTime[station].push(time); }; /** * @param {string} startStation * @param {string} endStation * @return {number} */ UndergroundSystem.prototype.getAverageTime = function(startStation, endStation) { const station = startStation + \"_\" + endStation; let totalTime = 0; let count = 0; for (let time of this.routeTime[station]) { totalTime += time; count++; } return totalTime / count; }; "},"medium/1423.html":{"url":"medium/1423.html","title":"1423. Maximum Points You Can Obtain from Cards(medium)","keywords":"","body":"1423. Maximum Points You Can Obtain from Cards Leetcode link 解题思路 本题给定我们一个数组，要求我们每次只能从数组两端取值，要求取 k 次之后总和最大 这个题目其实很适合用滑动窗口来求解，有两种思路： 假想数组头尾拼接起来，从数组最后 k 个开始遍历，然后遍历最后 k-1 个到第一个，最后 k-2 个到第二个。。。 求数组剩余连续部分的最小值，然后用数组总和减去最小值，因为剩余部分最小表示取的 k 个最大 C++ class Solution { public: int maxScore(vector& cardPoints, int k) { int total = accumulate(cardPoints.begin(), cardPoints.end(), 0); int len = cardPoints.size(); int windowSize = len - k; int left = 0, right = windowSize - 1; int sum = accumulate(cardPoints.begin(), cardPoints.begin() + windowSize, 0); int minSum = sum; while(right Javascript /** * @param {number[]} cardPoints * @param {number} k * @return {number} */ var maxScore = function(cardPoints, k) { let totalSum = cardPoints.reduce((prev, cur)=> prev + cur, 0); let len = cardPoints.length; // window size let size = len - k; let left = 0, right = size - 1; let sum = 0; for(let i=0;i "},"medium/1448.html":{"url":"medium/1448.html","title":"1448. Count Good Nodes in Binary Tree(medium)","keywords":"","body":"1448. Count Good Nodes in Binary Tree Leetcode link 题目简介 /** * @param {TreeNode} root * @return {number} */ 题目给我们一个二叉树的根节点 要求我们计算出有多少个节点是根节点到当前节点的最大元素 最后返回节点数量 解题思路 要判断从根节点到叶子节点的路径，一般选择 DFS 在 DFS 过程中，我们在参数保存当前路径上的最大节点的值 largest，通过当前节点的值域 largest 的比较我们就能判断当前节点是否是路径上的最大元素 如果是的话，我们可以把返回的节点数量 +1 并且更新 largest Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var goodNodes = function(root) { let res = 0 const dfs = (node, largest) => { if(!node) { return } if(node.val >= largest) { res++ largest = node.val } dfs(node.left, largest) dfs(node.right, largest) } dfs(root, Number.MIN_SAFE_INTEGER) return res }; 复杂度分析 时间 需要遍历所有的树节点，所以是 O(n)，n 代表树的所有节点数量 空间 Dfs 迭代取决于树的高度，最差的情况是 O(n)，最好的情况是 O(log n) "},"medium/1456.html":{"url":"medium/1456.html","title":"1456. Maximum Number of Vowels in a Substring of Given Length(medium)","keywords":"","body":"1456. Maximum Number of Vowels in a Substring of Given Length Leetcode link 题目简介 /** * @param {string} s * @param {number} k * @return {number} */ 题目给我们一个字符串 s 与数字 k 要求我们在 s 中找出每个长度为 k 的子字符串中的母音字符个数，并返回最大的个数有多少 解题思路 这题我们使用滑动窗口来求解 我们创建一个长度为 k 的窗口并计算其中母音字符的个数 移动窗口时，我们只需要判断窗口右侧与左侧两个字符是否为母音字符并更新窗口的母音字符个数即可 最后我们收集最大的母音字符个数返回 Javascript /** * @param {string} s * @param {number} k * @return {number} */ var maxVowels = function (s, k) { const isVowel = (c) => c === 'a' || c === 'e' || c === 'i' || c === 'o' || c === 'u'; let left = 0 let right = 0 let count = 0 while (right "},"medium/1461.html":{"url":"medium/1461.html","title":"1461. Check If a String Contains All Binary Codes of Size K(medium)","keywords":"","body":"1461. Check If a String Contains All Binary Codes of Size K Leetcode link 解题思路——哈希表 题目给定一个二进制字符串 s 跟一个数字 k，要求我们判断所有的 k 位二进制是否都是字符串 s 的子串 首先，所有的 k 位二进制总共有 个，一个字符串要包含所有的 k 位二进制，长度不能小于 哈希表的思路是这样的： 遍历字符串 s，找出所有长度为 k 的子串 将这些子串放到一个哈希表中 利用哈希表去重的特性，如果遍历完了之后哈希表的长度等于 则表示所有的 k 位二进制都被我们找到了 C++ class Solution { public: bool hasAllCodes(string s, int k) { // reduce computation if(s.size() subStrs; for(int i=0;i+k 解题思路——哈希表+滑动窗口 上述思路最大的性能瓶颈在于对字符串的操作，我们可以依靠滑动窗口的思路来减少对字符串的操作 我们假设字符串当前遍历到长度为 k 的二进制子串为： 下一个子串就是： 我们可以把上述两个二进制子串转成十进制的表示为 结合上述两个式子，我们可以得到递推公式： 至此，我们就可以把哈希表的指责从保存字符串变成保存整数了，最重要的是，对字符串的操作少了非常多次 C++ class Solution { public: bool hasAllCodes(string s, int k) { if(s.size() substrs{num}; for(int i = 1;i+k "},"medium/1465.html":{"url":"medium/1465.html","title":"1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts(medium)","keywords":"","body":"1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts Leetcode link 解题思路 本题给出了一个 h * w 的蛋糕以及他要切的地方，要求我们求出蛋糕经过切割后剩下的最大面积 本题的思路很简单，就是分别找出横着切与竖着切中的最大距离，然后相乘起来就好了 最后一个要注意的点是，相乘之后的数字可能会超过精度，所以可以选用 JS 中的 bigInt 来保存 Javascript var maxArea = function(h, w, horizontalCuts, verticalCuts) { horizontalCuts.push(h, 0); horizontalCuts.sort((a, b) => a-b); verticalCuts.push(w, 0); verticalCuts.sort((a, b) => a-b); let maxWidth = 0, maxHeight = 0; for(let height = 1;height "},"medium/1482.html":{"url":"medium/1482.html","title":"1482. Minimum Number of Days to Make m Bouquets(medium)","keywords":"","body":"1482. Minimum Number of Days to Make m Bouquets Leetcode link 解题思路 题目给了我们三个参数： bloomDay：Array，代表花园所有花各自开始盛开的天数 m：Number，代表我们需要制作的花束数量 k：Number，代表我们制作一束花束需要用到多少株花 此外，题目要求我们所有的花束都只能用（数组中）相邻的花来制作，且一枝花只能用来制作一个花束 这个题解题的思路是：我们需要一天天的比较现在盛开的花，看看哪一天符合制作所有花束的条件 因此，我们需要一个函数 canMakeBouquets 来帮我们判断某一天是否符合制作花束的条件了 此外，为了减少复杂度，我们可以使用二分法来减少计算的天数，二分法的范围从 1～bloomDay.length 详情请看代码： Javascript /** * @param {number[]} bloomDay * @param {number} m * @param {number} k * @return {number} */ var minDays = function(bloomDay, m, k) { if(m*k > bloomDay.length) { return -1; } const canMakeBouquets = (day) => { let bouquet = 0; let flowers = 0; for(const date of bloomDay) { if(date = m) { return true } } return false; } let low = 1, high = Math.max(...bloomDay); while(low "},"medium/1488.html":{"url":"medium/1488.html","title":"1488. Avoid Flood in The City(medium)","keywords":"","body":"1488. Avoid Flood in The City Leetcode link 解题思路 本题的关键在于我们要怎么在同一个湖的下一场雨之前把湖水排干 为了这个目的我们需要提前做一些准备： fullLakes：一个 Map，用来保存 rains[i], i，记录之前的雨下在 rains[i] 湖的下标（日期） dryDays：数组，用来记录还未使用的没下雨的下标（日期），这样可以在将来下雨的时候用 res：数组，用来保存答案 有了这些之后，我们的算法步骤如下： 遍历 rain 数组 如果当天没下雨，则将当前下标保存到 dryDays 中，然后回到步骤 1 如果当天下雨了，判断当前下雨的湖泊之前是否有下过雨（是否在 fullLakes 中），如果有则在 dryDays 中寻找从上次下雨到现在范围内最早的 dryDay 放水；如果没有就把当前下雨的湖泊记录到 fullLakes 中 如果在 dryDays 中找不到符合规则的时间，则返回空数组 [] 题目描述有一点没有说清楚，如果当天没下雨，但是也没有需要放水的湖泊了，我们仍然需要选择一个 1～无限大的数字来填充进数组 不然这个 case 就会失败： // testcase [69,0,0,0,69] // expect [-1,69,1,1,-1] 下标 2、3 的数字不能是 -1。。。所以我们一开始给数组 res 要默认赋值 1 Javascript /** * @param {number[]} rains * @return {number[]} */ var avoidFlood = function (rains) { const res = new Array(rains.length).fill(1) // {rains[i], i} const fullLakes = new Map() const dryDays = [] for (let i = 0; i { let left = 0 let right = arr.length while (left > 1 if (arr[mid] "},"medium/1493.html":{"url":"medium/1493.html","title":"1493. Longest Subarray of 1's After Deleting One Element(medium)","keywords":"","body":"1493. Longest Subarray of 1's After Deleting One Element Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个由 0 与 1 组成的数字数组 nums 要求我们在最多去掉一个 0 的情况下，计算出 nums 中最长的全 1 子数组有多长 最后返回子数组长度 解题思路 这题我们要使用变长滑动窗口的思想 我们使用滑动窗口的右边界遍历数组，当遇到第二个 0 的时候，我们需要更新窗口的左边界 并且在窗口右边界每次移动的时候，我们都需要更新一下当前最长的全 1 子数组长度 最后我们只需要返回我们记录的子数组长度即可 Javascript /** * @param {number[]} nums * @return {number} */ var longestSubarray = function (nums) { let left = 0 let hasZero = false let res = 0 for (let right = 0; right "},"medium/1513.html":{"url":"medium/1513.html","title":"1513. Number of Substrings With Only 1s(medium)","keywords":"","body":"1513. Number of Substrings With Only 1s Leetcode link 题目简介 /** * @param {string} s * @return {number} */ 题目给我们一个字符串 s，字符串由 0 与 1 组成 题目要求我们求出可能有多少个全 1 的子字符串 由于数量可能过大，最后我们要对结果取 mod (10 ** 9 + 7) 解题思路 我们可以把字符串 s 拆分成若干个全部都是 1 组成的字符串 对于每一个全 1 组成的字符串来说，总共会有 (1 + length) * length / 2 种可能的子字符串 我们把它全部加总后取 mod 就好 Javascript /** * @param {string} s * @return {number} */ var numSub = function (s) { const arr = s.split('0') let res = 0 for (const str of arr) { const len = str.length res += (1 + len) * len / 2 } return res % (10 ** 9 + 7) }; "},"medium/1530.html":{"url":"medium/1530.html","title":"1530. Number of Good Leaf Nodes Pairs(medium)","keywords":"","body":"1530. Number of Good Leaf Nodes Pairs Leetcode link 题目简介 本题给了我们两个参数，第一个 root 代表了二叉树的根结点、第二个 distance 代表了距离（距离由两个节点要经过多少节点才能相遇决定） 题目要求我们找出树的所有叶子节点中，相遇的距离小于 distance 有几对 解题思路 本题是一个树相关的题目，要求找树的叶子节点的距离我们可以使用 DFS 来遍历整棵树 但是问题是，我们怎么在遍历的过程中，把叶子节点直接的距离也一起计算出来呢？ 方式有很多种，我在这里选择了用数组来记录 我构建了一个数组 leafDistances，数组记录的是以该节点为根结点，它到所有它的叶子节点的距离 假设今天有一棵树： a | \\ b c // leafDistances = [1, 1] 当我们构建了一个这样的数组的时候，我们就可以对数组中每个叶子节点的距离进行相加比较了 举个上面的例子，b 到 c 的距离就是 leafDistances[0] + leafDistances[1] 只要他们小于 distance，就可以给结果加一了 那么我们的问题就变成了，要怎么构造这个数组呢？分成两种情况： 遍历叶子节点时：要返回 [1]，代表叶子节点的父节点到叶子节点的距离为 1 遍历到父节点时：构建一个新的数组，把改节点左右两个子节点记录的数组距离都加一后 push 进新数组后返回 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} distance * @return {number} */ var countPairs = function(root, distance) { let result = 0; function dfs(node) { if(!node) return []; // 遍历到叶子节点的情况 if(!node.left && !node.right) return [1]; const leftDistances = dfs(node.left); const rightDistances = dfs(node.right); // 每遍历到一个节点，找找经过当前节点的叶子节点有没有距离小于 distance 的其他叶子节点，如果有则记录下来 for(const leftDistance of leftDistances) { for(const rightDistance of rightDistances) { if(leftDistance + rightDistance "},"medium/1552.html":{"url":"medium/1552.html","title":"1552. Magnetic Force Between Two Balls(medium)","keywords":"","body":"1552. Magnetic Force Between Two Balls Leetcode link 解题思路 本题本质上要我们去求极小值中的极大值，这种题目我们优先使用二分法来做 二分法的范围左边（min）取 0，右边（max）取 force 最大的值（也就是 position 中的最大值减掉最小值） 每次二分，我们都要判断当前的 force 是否可以放下所有的球： 如果可以，则重新调整范围 min 为上次的 force 如果不行，则重新调整范围 max 为上次的 force 最后我们再看看 max 还是 min 能放下所有小球，返回能放下小球的最大值就好 Javascript /** * @param {number[]} position * @param {number} m * @return {number} */ var maxDistance = function (position, m) { position.sort((a, b) => a - b) let min = 0; let max = position[position.length - 1] - position[0] while (min + 1 { let lastPosition = position[0]; balls--; for (const pos of position) { if (pos - lastPosition >= force) { balls--; lastPosition = pos; } if (balls === 0) { break; } } return balls === 0; } "},"medium/1578.html":{"url":"medium/1578.html","title":"1578. Minimum Time to Make Rope Colorful(medium)","keywords":"","body":"1578. Minimum Time to Make Rope Colorful Leetcode link 题目简介 /** * @param {string} colors * @param {number[]} neededTime * @return {number} */ 题目给我们一个字符串 colors 代表在一个绳子上按顺序不同气球的颜色；一个数字数组 neededTime 代表解开每一个气球所需要花的时间 题目要求我们解开任意数量的气球，使得两个相同颜色的气球不要相邻在一起，最后返回满足结果的所需最短时间是多少 解题思路 这一题我们分为三个步骤去求解： 找到连续的同颜色的气球组合 计算出将该组合的气球解到只剩一个所需的最短时间 将所有组合的最短所需时间加总并返回 我们一步一步来解析： 要找到连续同颜色的气球组合，我们需要用到两个指针形成一个窗口，该窗口理论上能把找到的组合包裹在内 一旦有了窗口，我们就能得出需要的时间是解开该窗口所有气球的时间 - 该窗口需要解最久的气球的时间（换句话说，我们保留需要解最久的气球，把其他气球全解了） 最后一步将其加总就好 让我们来看看代码： Javascript /** * @param {string} colors * @param {number[]} neededTime * @return {number} */ var minCost = function (colors, neededTime) { const len = colors.length let res = 0 let left = 0 while (left "},"medium/1584.html":{"url":"medium/1584.html","title":"1584. Min Cost to Connect All Points(medium)","keywords":"","body":"1584. Min Cost to Connect All Points Leetcode link 背景知识 这道题本质上是一道最小生成树 Minimum Spanning Tree (MST) 的题目。 题目给了我们在二维平面上的 n 个点，让我们求能让总距离最短且能将所有点连接起来的路径。 这个过程，恰巧也是生成 MST 的过程。 求 MST，主要有两个算法：Kruskal 与 Prim，下面将会分别描述两个算法的思路 解题思路——Kruskal's Algorithm Kruskal 算法把焦点放在 “边” 上，他的想法是： 先求出所有的边，再对它们的权重（一般是距离）排序 根据排序，从小到大依次取边 如果取得的边会让图形构成 “回路”，就抛弃这条边，继续第二步 如果不会则持续第二步，直到所有边都被取完或被丢弃 里面值得推敲的是，要如何判断取得的边会构成 “回路”，这一点就要用到并查集 Union-find, aka Disjoint-set。 简单来说，并查集是一个数据解构，它提供了两种方法： 合并 Union：将一个节点合并到一个组中 查 Find：查找一个节点是否在一个组中 我们可以利用它的特性，经过以下步骤确认是否成环： 把第一个点加到组里 取得选中的边的终点，并且确认是否已经在组里了 如果已经在组里了，那么表示加入这个边必定成环，则丢弃 如果不在组里，表示选中的边不会成环，把它的终点加到组里，然后重复第二步直到所有的边都取完了 C++ class UnionFind { private: vector group; public: UnionFind(int size) { group = vector(size); for (int i = 0; i >& points) { int n = points.size(); vector>> edges; // store edges' distance for (int curNode = 0; curNode 解题思路——Prim's Algorithm 相比 Kruskal 把重心放在边上，Prim 算法把重心放在 “点” 上。 它的核心思路在于： 一开始选中任意一点，将其加入 MST 中 选中距离 MST 最近的一个点，将其也加入 MST 中 重复第二步直到所有的点都被纳入 MST 中 使用一般的 Prim 算法的性能瓶颈在于：要维护一个优先队列，用以保存所有与 MST 相邻的边长度。 实现如下： /* * @lc app=leetcode id=1584 lang=cpp * * [1584] Min Cost to Connect All Points */ struct Edge { int start; int target; int distance; Edge(int _start, int _target, int _distance) { start = _start; target = _target; distance = _distance; } }; struct Cmp { bool operator()(Edge &a, Edge &b) { return a.distance > b.distance; } }; // @lc code=start class Solution { private: // visited points vector visited; // reserve shortest edge at top priority_queue, Cmp> pq; // find all edges of the point, and push into pq void findEdge(int point, vector>> &graph) { for (auto &edge : graph[point]) { int target = edge.first; // if visited, forget it if (visited[target]) { continue; } int distance = edge.second; pq.push({point, target, distance}); } } public: int minCostConnectPoints(vector> &points) { int n = points.size(); visited.resize(n); vector>> graph(n); // reserve edges' distance for (int curNode = 0; curNode 所以，我们可以换一种思路，优化一下优先队列。 具体地说，我们可以改为维护一个数组 minDist，它是一个长度等于节点数的数组，minDist[n] 表示从节点 n 到 MST 树的最短距离。 具体步骤如下： 在一开始，我们先把 minDist 的每一项都设为∞ 然后我们任意选择一点 将选择的点加入 MST 然后将 minDist[n] 设为 0（n 为选择的点），将其他元素更新成该点到点 n 的距离 从更新好的距离中选择还没被加入 MST 且距离最短的点，重复步骤三 实现如下： class Solution { public: int minCostConnectPoints(vector> &points) { int n = points.size(); int result = 0; int edgeUsed = 0; vector visited(n); // minDist[n]: the shortest distance from n to MST vector minDist(n, INT_MAX); // start from points[0] minDist[0] = 0; while (edgeUsed minDist[i]) { curMinEdge = minDist[i]; curNode = i; } } visited[curNode] = true; result += curMinEdge; edgeUsed++; // update minDist for adjacent node for (int nextNode = 0; nextNode 如果还有看不懂的同学可以看一下 官方解答 的第三个的动图就懂了 "},"medium/1625.html":{"url":"medium/1625.html","title":"1625. Lexicographically Smallest String After Applying Operations(medium)","keywords":"","body":"1625. Lexicographically Smallest String After Applying Operations Leetcode link 题目简介 吐槽一下：这一题能成为 medium 单纯就是暴力模拟的计算量不大，如果要简化这题的话个人认为是一道 hard…… /** * @param {string} s * @param {number} a * @param {number} b * @return {string} */ 本题给了我们一个原始字符串 s（其中每个字符都是 0～9 的数字字符，并且 s 的长度是偶数）以及一个整数 a 与整数 b 要求我们经过无限次的操作之后，求出语义最小的字符串 s 操作有两种： 旋转（将字符串往右旋转 b 个字符）：假设 s=0123, b = 2，旋转后得到 s=2301 求和（将当前字符串奇数下标加 a 后对 10 取余）：假设 s=0123, a = 9，结果为 s=0022 解题思路——模拟 这题最简单的思路就是把所有可能的字符串都找出来，然后比较一下将语义最小的字符串返回 具体来说，我们可以用一个 set 来记录我们处理过的字符串；一个 queue 来将所有新字符串入栈；一个变量 res 来记录当前语义最小的字符串 每次循环我们从 queue 中取出字符串，更新 res 变量，然后将其旋转与求和的新字符串入栈，直到 queue 栈为空 Javascript /** * @param {string} s * @param {number} a * @param {number} b * @return {string} */ var findLexSmallestString = function (s, a, b) { let res = s const set = new Set() const queue = [s] while (queue.length > 0) { const str = queue.shift() if (str { return str.slice(b, str.length) + str.slice(0, b) } const add = (str, a) => { let newStr = '' for (let i = 0; i 解题思路——数学简化 上面的方法虽然能过，但是构造所有字符串无疑是有点麻烦了，我们接下来研究一下要如何简化 首先我们明确一下目标，要让语义最小，我们的首要目标就是让最高位的数字最小 题目提供了两种调整最高位数字的方法，所以我们可以将目标拆解为两个： 通过求和把所有的数字调整到最小 通过旋转把最小的数字调整到最前面 求和 根据题目要求，我们每次求和都只能将所有位于当前奇数下标的数字全部求和 所以，在只讨论求和的情况下，我们的目标就是，把最高位的奇数下标的数字调整到最小，也就是将 s[1] 的数字调整到最小 那么我们如何将 s[1] 调整到最小呢？有两种方式： 循环对 s[1] 求和，直到得出最小的数字为止，然后对余下的奇数下标数字操作相同次数的求和（最差的情况会多 10 次计算） 用我们伟大的数学直接计算出需要加多少～（在所有情况都只需要一次计算） 第一个方式的实现非常简单，但是缺点是会提升复杂度（但是这一题暴力都能解所以肯定是可以通过的） 我们接下来重点看一下第二个方式的推导： 根据题目求和的要求，我们可以得出如下公式 $ r = (s[1] + ak) \\mod 10$ 其中 k 代表我们进行了 k 次的操作，r 代表 s[1] 经过 k 次操作之后的结果 我们的目标就是得出 ak 是多少可以让 r 最小 我们再进一步可以将 mod 10 操作看成减去多次的 10，我们假设 q 为需要减去 10 的次数，于是公式变成了 $ r = s[1] + ak - 10q$ 由于我们的目标是得出 s[1] 要如何操作才能变成 r，所以我们调换一下公式 $ak - 10q = r - s[1]$ 其中 ak - 10q 就是我们需要对 s[1] 进行的操作，所以我们接下来的目标就是看看如何使得 ak - 10q 有解 万幸的是～我们有 裴蜀定理： 裴蜀定理假设有 a，b 两个不全为 0 的整数，必定存在两个整数 x 与 y 使得 ax+by= gcd(a, b) 成立 Gcd 表示最大公因数 我们把其中的 x 替换成 k、y 替换成 q、a 还是 a、b 替换成 10，可以得到： $ak - 10q = gcd(a, 10) = r - s[1]$ 于是我们得到结论一：r - s[1] 是 gcd(a, 10) 的倍数 根据同余的定义，我们可以根据结论一推导出～ 如果整数 (a) 和 (b) 的差 ((a-b)) 能被 (m) 整除，即 (m|(a-b))，则称 (a) 和 (b) 对模 (m) 同余 结论二： r 与 s[1] 对gcd(a, 10) 同余 由于我们要让 r 最小，所以我们可以推导出～ 结论三：r = s[1] mod gcd(a, 10) 我们把结论三套回一开始的公式： $s[1]\\ mod\\ gcd(a, 10) = s[1] + ak - 10q$ 调整一下，计算 ak 的公式就有了： $ak = s[1]\\ mod\\ gcd(a, 10) - s[1] + 10q$ 由于我们最后会对 10 取余，所以我们只需要让 q = 1 就可以防止 s[1] mod gcd(a, 10) - s[1] 是负的了 旋转 接下来我们来看看旋转要如何简化 首先明确一点，我们旋转的目的是为了让最高位的数字最小，换言之就是 s[0] 最小 那么我们接下来就来分析一下，有哪些数字有机会成为 s[0]（或者换一个思路，s[0] 通过旋转能出现在哪些位置） 假设字符串 s 长度是 len，每次能旋转 b 位，我们不难得出以下公式 $0 + bk\\ mod\\ len$ 其中 k 代表旋转的次数，这个公式代表 s[0] 通过 k 次旋转后会出现的位置，我们整理一下公式 $bk - len*q$ 其中 mod len 可以看成减去了 q 次的 len 根据我们的老熟人 裴蜀定理 得知：如果该公式有解，这些解必须是 gcd(b, len) 也就是说，只有位置在 gcd(b, len) 的倍数的字符有机会旋转到 s[0] 旋转+求和 接下来我们来讨论一下两个操作一起来的情况 具体而言，我们要来讨论一下我们是否能通过旋转将下标为奇数的字符旋转为下标为偶数的字符 我们已经知道字符串长度必为偶数，那么只有两种情况： b 为奇数：旋转一次会让奇偶下标的字符位置互换 b 为偶数：奇偶下标字符不会互换 所以我们得到结论：只有当 b 为奇数的时候，我们才需要对偶数下标的数字求和 Javascript /** * @param {string} s * @param {number} a * @param {number} b * @return {string} */ var findLexSmallestString = function (s, a, b) { const arr = s.split('').map(c => Number(c)) const len = arr.length const rotateStep = gcd(b, len) const addGcd = gcd(a, 10) let res = arr for (let i = 0; i { while (a) { [a, b] = [b % a, a] } return b } const add = (arr, addGcd, start) => { const c = arr[start] const inc = c % addGcd - c + 10 for (let i = start; i { for (let i = 0; i "},"medium/1631.html":{"url":"medium/1631.html","title":"1631. Path With Minimum Effort(medium)","keywords":"","body":"1631. Path With Minimum Effort Leetcode link 解题思路——并查集 本题给了我们一个二维数组，并要求我们找到从左上角到右下角元素波动最小（就是靠近的两个元素差值的最大值最小）的路径。 我们可以把这个问题简化成：找到一个图上的一条路径，这条路径最长的部分必须是所有路径最长的部分的最小值。 因此，我们可以使用基于并查集的 Kruskal 算法来做，具体思路如下： 计算所有相邻元素之间的距离（就是两个元素之间的差值） 将所有的距离从小到大排序 从最小的距离开始，依次将元素加入并查集中 检查左上角的起点与右下角的终点是否已经在同一个组中，如果是则返回当前的距离 如果不是则回到第三步继续计算 C++ class UnionFind { private: vector root; vector rank; public: UnionFind(int size) : root(size), rank(size) { for (int i = 0; i = rank[rootY]) { root[rootY] = rootX; rank[rootX] += rank[rootY]; } else { root[rootX] = rootY; rank[rootY] += rank[rootX]; } } } }; class Solution { public: int minimumEffortPath(vector> &heights) { int col = heights[0].size(), row = heights.size(); vector> edges; // 计算节点与下面、右边的边距（effort） for (int i = 0; i (a) (b); }); UnionFind uf(col * row); int start = 0, end = col * row - 1; for (auto [cell1, cell2, distance] : edges) { uf.unionSet(cell1, cell2); if (uf.find(start) == uf.find(end)) { return distance; } } return 0; } }; Javascript class UnionFind { constructor(size) { this.root = new Array(size); this.rank = new Array(size); for (let i = 0; i = this.rank[rootY]) { this.root[rootY] = rootX; this.rank[rootX] += this.rank[rootY]; } else { this.root[rootX] = rootY; this.rank[rootY] += this.rank[rootX]; } } } }; var minimumEffortPath = function(heights) { const row = heights.length, col = heights[0].length; let edges = []; // 计算元素与下面，右边的边距 for(let i=0;i 大） edges.sort((a, b)=> a[2] - b[2]); const uf = new UnionFind(col * row); const start = 0, end = col * row - 1; for(let edge of edges) { const [cell1, cell2, effort] = edge; uf.unionSet(cell1, cell2); if(uf.find(start) === uf.find(end)) { return effort; } } return 0; }; 解题思路——Dijkstra 我们可以把题目化简成求图上指定起点与终点的最短路径。只是最短路径的定义不再是路径累加，而是用最长的一段路径代表。 于是，我们就可以用 Dijkstra 的思想来做了，具体思路如下： 我们需要一个数组 dist 来记录任意点到起点的最短路径，并在一开始初始化数组元素为∞ 我们还需要一个优先队列 pq 来记录当前 “发现” 的元素以及当前的最短路长度 最后我们维护一个已到达数组 visited 来保存已经确定了最短路的元素 然后就可以开始 Dijkstra 了，区别在于更新 dist 的条件是当前节点到起始点最长的一段路径要小于 dist 里面记录的长度 C++ class Solution { private: int direction[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; bool inRange(int x, int y, int row, int col) { return x >= 0 && x = 0 && y >& heights) { int row = heights.size(), col = heights[0].size(); auto Cmp = [](const auto& e1, const auto& e2) { auto&& [x1, y1, d1] = e1; auto&& [x2, y2, d2] = e2; return d1 > d2; }; // {row, col, distance} priority_queue, vector>, decltype(Cmp)> pq(Cmp); pq.push({0, 0, 0}); vector dist(row * col, INT_MAX); dist[0] = 0; vector visited(row * col); while (!pq.empty()) { auto [x, y, distance] = pq.top(); pq.pop(); int position = x * col + y; if (visited[position]) { continue; } if (x == row - 1 && y == col - 1) { break; } visited[position] = true; for (int i = 0; i "},"medium/1641.html":{"url":"medium/1641.html","title":"1641. Count Sorted Vowel Strings(medium)","keywords":"","body":"1641. Count Sorted Vowel Strings Leetcode link 解题思路 这道题规律特别明显，可以直接列出来看看： N a u e i o 1 1 1 1 1 1 2 5 4 3 2 1 3 15 10 6 3 1 4 25 20 10 4 1 5 50 25 15 5 1 可以看到，对于 [n = 2, a] 这个格子，它的值等于 [n = 1, a] + [n = 1, u] + [n = 1, e] + [n = 1, i] + [n = 1, o] 对于 [n = 3, u] 这个格子，它的值等于 [n = 2, u] + [n = 2, e] + [n = 2, i] + [n = 2, o] 不难看出，每一个格子的值等于其上一行同一列 到 上一行最后一列的加总 注：还有另一种规律是，从右上到左下是一个倾斜了 45 度的杨辉三角，也可以套公式来解 C++ class Solution { public: int countVowelStrings(int n) { int a = 1, e = 1, i = 1, o = 1, u = 1; while(n-- > 1) { a = a + e + i + o + u; e = e + i + o + u; i = i + o + u; o = o + u; u = u; } return a + e + i + o + u; } }; Javascript var countVowelStrings = function(n) { let [a, e, i, o, u] = new Array(5).fill(1); while(n-- > 1) { a = a + e + i + o + u; e = e + i + o + u; i = i + o + u; o = o + u; u = u; } return a + e + i + o + u; }; "},"medium/1642.html":{"url":"medium/1642.html","title":"1642. Furthest Building You Can Reach(medium)","keywords":"","body":"1642. Furthest Building You Can Reach Leetcode link 解题思路 leetcode 难得有这么幽默的一道题，本题要求我们在屋顶玩跑酷，题目给定我们两个工具：砖块与梯子，其中梯子可以无限延长，而砖块只有固定高度；题目要求我们翻越尽可能多的建筑屋顶，要求是，如果要翻越的建筑比当前建筑低，直接跳下去就完事；如果比当前建筑高，则需要借助砖块或者梯子。 可想而知，梯子是我们想要翻越尽可能多屋顶的最佳选择，所以必须尽可能的 “换” 更多的砖块 至于怎么换呢？我门需要用到贪心的思路，具体步骤如下： 首先我们往前翻越要优先使用砖块 当遇到砖块用完的情况下，我们可以用梯子 “换” 砖块 也就是比较当前高度差以及之前最高的高度差，如果之前的高度差比较大，则用梯子替代掉之前用了最多砖块的地方；否则直接用梯子 重复步骤 1，3 直到砖块梯子都用完且无法前进的时候返回当前下标 C++ class Solution { public: int furthestBuilding(vector &heights, int bricks, int ladders) { // 大根堆保存之前翻越每一栋楼用的砖块数量 priority_queue pq; for (int num = 0; num 0) { // 梯子还够的话，用梯子 ladders--; // 如果之前用过的砖块比现在要用的多就用砖块换，否则直接用梯子 if (!pq.empty() && pq.top() > altitude) { bricks += pq.top(); pq.pop(); num--; } } else { // 连梯子都无了那就是真的无了 return num; } } } } return heights.size() - 1; } }; "},"medium/1653.html":{"url":"medium/1653.html","title":"1653. Minimum Deletions to Make String Balanced(medium)","keywords":"","body":"1653. Minimum Deletions to Make String Balanced Leetcode link 题目简介 题目给我们一个入参 s，代表一个由 a 与 b 两个字母组成的字符串 题目要求我们删除最少的字符让字符串中不存在 ba 的组合 并且最后返回需要删除的字符数量 解题思路 想要让字符串中没有 ba 的组合，有两种方式： 删除掉 ba 中的 b 删除掉 ba 中的 a 但是我们要怎么知道我们应该选择哪一种方式呢？ 答案是选择删除 ba 组合中连续数量比较少的那个字母 举个例子：aababbab 我们可以看到第一个 ba 组合是：aababbab 这个时候因为这个组合的 b 跟 a 数量是一样的，所以我们任意删除一个都可以，删除字符数记 1 第二个组合是：aababbab 这个时候我们可以看到 a 的数量比 b 少，所以就把 a 删除，删除字符记 2 结果返回 2 具体编码中，我们只需要在遇到 b 的时候用一个计数器 count 把 b 的数量记下，然后在遇到 a 的时候把 count 的数量减一的同时把删除字符的数量加一即可 Javascript /** * @param {string} s * @return {number} */ var minimumDeletions = function(s) { let count = 0; let deletion = 0; for(const c of s) { if(c === 'b') { count++; } else if(count > 0) { deletion++; count--; } } return deletion; }; "},"medium/1657.html":{"url":"medium/1657.html","title":"1657. Determine if Two Strings Are Close(medium)","keywords":"","body":"1657. Determine if Two Strings Are Close Leetcode link 题目简介 /** * @param {string} word1 * @param {string} word2 * @return {boolean} */ 题目给我们两个字符串 word1 与 word2 要求我们判断两个字符串之间是否接近 接近的定义是在通过多次应用下列两种操作的情况下，能够将 word1 转换成 word2 任意交换两个字符 将现有的一个字符转换为现有的另一个字符；对现有的另一个字符也同步转换成现有的一个字符 解题思路 根据两种操作，可以看出两个字符串是否接近需要满足以下三个条件： 两个字符串长度相等 两个字符串需要有相同的字符组成（word1 有的字符 word2 必须得有；反之亦然） 字符串中字符出现次数一致（比如 aaabc 与 bbbac 都是 321 符合条件；aaabc 与 aabcc 一个是 321 一个是 221 不符合条件） 所以我们的任务就变成了判断这三种条件是否符合，在这里我使用数组的方式来记录 Javascript /** * @param {string} word1 * @param {string} word2 * @return {boolean} */ var closeStrings = function (word1, word2) { const freq1 = Array(26).fill(0) const freq2 = Array(26).fill(0) const codeA = 'a'.charCodeAt(0) for (const c of word1) { freq1[c.charCodeAt(0) - codeA]++ } for (const c of word2) { freq2[c.charCodeAt(0) - codeA]++ } // check the letters for (let i = 0; i a - b) freq2.sort((a, b) => a - b) // check the occurrence for (let i = 0; i "},"medium/1658.html":{"url":"medium/1658.html","title":"1658. Minimum Operations to Reduce X to Zero(medium)","keywords":"","body":"1658. Minimum Operations to Reduce X to Zero Leetcode link 解题思路 本题要求我们用一个数组 nums 的两端之和组成整数 x 我们可以换个角度思考，首先求一个数 count 等于数组 nums 所有元素之和减去整数 x 我们就可以把问题转变为，找出数组中，长度之和为 count 的最长连续子串 因此，我们就可以用滑动窗口的思想来做题了 C++ class Solution { public: int minOperations(vector& nums, int x) { int left = 0, right = 0; // nums 数组的每一项之和 int arrSum = 0; for(int num :nums) { arrSum += num; } int count = arrSum - x; // 当前滑动窗口之和 int sum = 0; // 题目所求的长度 int res = -1; // 数组所有元素之和小于整数 x，不可能有结果 if(count count) { sum -= nums[left++]; } if(count == sum) { res = max(res, right - left + 1); } right++; } if(res == -1) { return -1; } else { return nums.size() - res; } } }; Javascript var minOperations = function(nums, x) { let left = 0, right = 0; // nums 数组的每一项之和 let arrSum = nums.reduce((prev, cur)=> prev + cur, 0); let count = arrSum - x; // 当前滑动窗口之和 let sum = 0; // 题目所求的长度 let res = -1; // 数组所有元素之和小于整数 x，不可能有结果 if(count count) { sum -= nums[left++]; } if(count === sum) { res = Math.max(res, right - left + 1); } right++; } if(res === -1) { return -1; } else { return nums.length - res; } }; "},"medium/1679.html":{"url":"medium/1679.html","title":"1679. Max Number of K-Sum Pairs(medium)","keywords":"","body":"1679. Max Number of K-Sum Pairs Leetcode link 解题思路——排序+双指针 TC: O(nlogn) SC: O(1) 题目要求我们计算在数组中任取两个不重复的数字总和为 k 的组合数，且用过的数字不能再用 那么我们可以用排序+双指针来解： 先把数组由小到大排序 使用两个指针分别从数组的左边跟右边开始往中间遍历 如果左右指针所指元素相加小于 k ，则可以将左指针 +1来加大两数之和 反之如果左右指针所指元素相加大于 k ，则可以将右指针 -1来缩小两数之和 如果两数之和刚好相等，那么组合数 +1，并且把左指针 +1，右指针 -1 重复步骤 2～5 直到左右指针相遇（指向同一个元素） C++ class Solution { public: int maxOperations(vector& nums, int k) { int res = 0, left = 0, right = nums.size() - 1; sort(nums.begin(), nums.end()); while ((left k) { right--; } else { left++; right--; res++; } } return res; } }; Javascript var maxOperations = function(nums, k) { let left = 0, right = nums.length-1, res = 0; nums.sort((a,b)=>a-b); while((left 解题思路——建立映射 TC: O(n) SC: O(n) 第一种方法因为用了排序使得时间复杂度比较高，那么我们可以用时间换空间的方式，也就是： 建立一个映射来保存出现过的数字的次数，然后对数组中的每个元素，在映射中找 k 与元素的差，如果在映射表中存在计数，则表示我们需要的组合出现了 C++ class Solution { public: int maxOperations(vector& nums, int k) { int res = 0; unordered_map freq; for (int num : nums) { int rest = k - num; if (freq[rest] > 0) { res++; freq[rest]--; } else { freq[num]++; } } return res; } }; Javascript var maxOperations = function(nums, k) { let res = 0; let freq = {}; for(let num of nums) { let rest = k - num; if(freq[rest]!== undefined && freq[rest] > 0) { freq[rest]--; res++; } else { (freq[num] === undefined) && (freq[num] = 0); freq[num]++; } } return res; }; "},"medium/1689.html":{"url":"medium/1689.html","title":"1689. Partitioning Into Minimum Number Of Deci-Binary Numbers(medium)","keywords":"","body":"1689. Partitioning Into Minimum Number Of Deci-Binary Numbers Leetcode link 解题思路 题目要求我们使用二进制的数来拼出十进制的任何数 本题答案个数的限制在于给出的十进制数最大的一位数，所以我们只要遍历找出最大的那个元素就好 C++ class Solution { public: int minPartitions(string n) { return *max_element(n.begin(), n.end()) - '0'; } }; Javascript /** * @param {string} n * @return {number} */ var minPartitions = function(n) { let max = 0; for(let c of n) { max = Math.max(c, max); } return max; }; "},"medium/1695.html":{"url":"medium/1695.html","title":"1695. Maximum Erasure Value(medium)","keywords":"","body":"1695. Maximum Erasure Value Leetcode link 解题思路 题目要求我们求一个正整数数组 nums 的累加和最大的无重复元素的连续子数组，返回其累加和的值 因为要求连续子数组，所以我们优先考虑滑动窗口的方式 另外，我们可以用一个集合来记录当前窗口内已有的元素，如果出现了重复元素，则将窗口内该元素包含之前的元素全部清理出窗口外 我们记录下每个符合条件的窗口累加和，最后再取最大值就是题目所求了 C++ class Solution { public: int maximumUniqueSubarray(vector& nums) { int left = 0, right = 0; int res = -1; int sum = 0; unordered_set set; int len = nums.size(); while(right Javascript /** * @param {number[]} nums * @return {number} */ var maximumUniqueSubarray = function(nums) { let left = 0, right = 0; let set = new Set(); let res = -1; let sum = 0; let len = nums.length; while(right "},"medium/1717.html":{"url":"medium/1717.html","title":"1717. Maximum Score From Removing Substrings(medium)","keywords":"","body":"1717. Maximum Score From Removing Substrings Leetcode link 解题思路 本题给了我们一个字符串 s 以及两个数字 x 与 y，其中： x 代表当 ab 组合从字符串去除时候得到的分数 y 代表当 ba 组合从字符串去除时候得到的分数 最后要我们求能够从给定条件下获得的最高分数 这个题目我们可以采用顺序遍历字符串的形式来做，在遍历过程中我们会遇到几种情况： 遇到了字母 a 遇到了字母 b 遇到了其他字母 我们来分别分析一下这三种情况： 遇到字母 a 首先我们要明确的一点是，我们的希望永远优先把分数高的组合给去除掉 当我们遇到字母 a 的时候，我们要先做两个个判断： 去除 ba 的得分是否比去除 ab 高：if(y > x) a 前面是否有 b 可以凑成 ba 如果这两个条件成立，恭喜，我们可以把 y 的分数收入囊中了 如果这两个条件有一个不成立，那么不好意思，我们先把 a 的数量记起来，继续遍历（因为在这一轮遍历，我们只希望去除分数高的组合） 遇到字母 b 这个时候的目标与上述一致，我们的希望永远优先把分数高的组合给去除掉 只是判断条件改了： 去除 ab 的得分是否比去除 ba 高：if(x > y) a 前面是否有 b 可以凑成 ab 如果条件成立，把分数 x 纳入囊中 如果不成立，记下 b 的数量，继续遍历 遇到其他字母 遇到其他字母的时候，我们的目标是：把前面分数低的得分组合做一个结算 这个目标有两个问题要解决： 为什么前面都是分数低的？因为我们优先把分数高的组合去除了，剩下来的 a/b 只可能是分数低的组合或者单个字母两种情况 要怎么结算？我们取 a/b 中数量最少的个数去✖️低分分数 循环结束 当循环结束的时候，字符串的尾巴可能还会有剩下一些低分组合，要记得把这些低分组合用遇到其他字母的算法做一个结算 Javascript /** * @param {string} s * @param {number} x: 'ab' * @param {number} y: 'ba' * @return {number} */ var maximumGain = function(s, x, y) { let aCount = 0; let bCount = 0; const minPoint = Math.min(x, y); let result = 0; for(let i=0;i 'b': // 如果出现了不是 a/b 的字符，要把前面留存的 a/b 的分数算一下 // 因为后面两个 case 的规则决定了当出现分数比较高的组合会第一时间处理掉 // 所以这里如果有能凑成一堆的 a/b，一定是分数比较低的组合 result += Math.min(aCount, bCount) * minPoint; aCount = bCount = 0; break; case c === 'a': // 当 y > x 且 ba 组合出现的时候，优先处理掉当前的 ba 组合（计算分数） if(y > x && bCount > 0) { result += y; bCount--; } else { // 如果没出现，就先记着之后处理 aCount++; } break; case c === 'b': // 当 x > y 且 ab 组合出现的时候，优先处理掉当前的 ab 组合（计算分数） if(x > y && aCount > 0) { result += x; aCount--; } else { // 如果没出现，就先记着之后处理 bCount++; } break; } } // 当上述循环结束的时候，有可能还会有分数少的组合在字符串末尾没有处理的情况，这里统一处理 result += Math.min(aCount, bCount) * minPoint; return result; }; "},"medium/1721.html":{"url":"medium/1721.html","title":"1721. Swapping Nodes in a Linked List(medium)","keywords":"","body":"1721. Swapping Nodes in a Linked List Leetcode link 解题思路 本题要求我们找到单向链表第 k 个节点与倒数第 k 个节点交换，难点在于如何在一次遍历中找到倒数第 k 个节点 我们可以先找到第 k 个节点 n1，这个时候 head 跟 n1 的距离刚好是 k，我们用一个指针 n2 指向 head，然后 n1 与 n2 同时往后遍历链表，这样只要 n1 找到了链表的尾节点， n2 就恰巧是倒数第 k 个节点了。 C++ class Solution { public: ListNode* swapNodes(ListNode* head, int k) { ListNode *n1 = head, *n2 = head, *n_kth; while (--k > 0) { n1 = n1->next; } n_kth = n1; while (n1->next != NULL) { n2 = n2->next; n1 = n1->next; } swap(n_kth->val, n2->val); return head; } }; Javascript var swapNodes = function(head, k) { let n1 = head, n2 = head, n_kth; while (--k > 0) { n1 = n1.next; } n_kth = n1; while (n1.next != null) { n2 = n2.next; n1 = n1.next; } [n_kth.val, n2.val] = [n2.val, n_kth.val]; return head; }; "},"medium/1733.html":{"url":"medium/1733.html","title":"1733. Minimum Number of People to Teach(medium)","keywords":"","body":"1733. Minimum Number of People to Teach Leetcode link 题目简介 题目给了我们三个参数： n：代表有多少种语言 languages：是一个二维数组，代表每一种语言有多少个人会 friendships：也是一个二维数组，在同一个数组元素内的人表示是朋友 题目要求我们选择一种语言去教人，使得所有朋友都能够互相使用相同语言沟通 要求我们得出最少教多少个人就能够符合要求 解题思路 这道题需要分成三个步骤来解： 先通过遍历所有的朋友，找出有多少人是需要被教新的语言的（只要朋友双方没有共同语言就需要将两个人都列入需要教学的范围） 在所有需要教学的人中，找出他们共同会最多的语言 用所有需要教学的人，减去会最多语言的人数，就是需要教学的最少人数了 Javascript /** * @param {number} n * @param {number[][]} languages * @param {number[][]} friendships * @return {number} */ var minimumTeachings = function (n, languages, friendships) { // 计算需要被教学的人 const userToTeach = new Set() for (const [u1, u2] of friendships) { const hasCommonLang = languages[u1 - 1].some(lang => languages[u2 - 1].includes(lang)) if (!hasCommonLang) { userToTeach.add(u1) userToTeach.add(u2) } } // 计算最多人会的语言与其会的人数 const langCount = new Array(n+1).fill(0) let mostKnownLangCount = 0 for(const user of userToTeach) { for(const lang of languages[user - 1]) { langCount[lang]++ mostKnownLangCount = Math.max(langCount[lang], mostKnownLangCount) } } // 所有需要被教学的人，减去最多人会的语言的人数 return userToTeach.size - mostKnownLangCount } "},"medium/1926.html":{"url":"medium/1926.html","title":"1926. Nearest Exit from Entrance in Maze(medium)","keywords":"","body":"1926. Nearest Exit from Entrance in Maze Leetcode link 题目简介 /** * @param {character[][]} maze * @param {number[]} entrance * @return {number} */ 题目给我们一个二维数组 maze 以及一个数组 entrance maze 元素有两种 . 代表可以走的路、+ 代表不能走的墙 entrance 代表我们一开始在 maze 中的位置 题目要求我们计算从 entrance 到 maze 的边缘最少需要用到几步（起始位置在边缘的话不算） 解题思路 这题的思路是运用图的 BFS 来做 具体思路就是，我们每次都从当前位置的上下左右四个方向出发，直到第一个遇到边缘就返回当前的步数 为了减少不必要的计算，我们可以使用 visited 数组来记录已经遍历过的位置 Javascript /** * @param {character[][]} maze * @param {number[]} entrance * @return {number} */ var nearestExit = function(maze, entrance) { const height = maze.length const width = maze[0].length const visited = Array.from({length: height}, _ => Array(width).fill(false)) visited[entrance[0]][entrance[1]] = true const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]] // [positionRow, poitionColumn, steps] const queue = [[...entrance, 0]] while(queue.length > 0) { const [row, col, steps] = queue.shift() if((row === 0 || row === height-1 || col === 0 || col === width-1) && steps > 0) { // the shortest path will reach here first return steps } for(const [dr, dc] of dirs) { const newRow = row + dr const newCol = col + dc if(newRow = height || newCol = width || visited[newRow][newCol] || maze[newRow][newCol] === '+') { continue } visited[newRow][newCol] = true queue.push([newRow, newCol, steps+1]) } } return -1 }; 复杂度分析 m 代表 maze 的宽 n 代表 maze 的高 时间 最坏的情况我们需要把所有的 maze 元素入栈（复杂度 O(mn)）+每个入栈元素需要进行四个方向查找（复杂度 O(4mn)） 所以加起来是 O(mn) 空间 主要来源于 visited 的空间占用以及栈的空间占用，所以是 O(mn) "},"medium/1930.html":{"url":"medium/1930.html","title":"1930. Unique Length-3 Palindromic Subsequences(medium)","keywords":"","body":"1930. Unique Length-3 Palindromic Subsequences Leetcode link 题目简介 /** * @param {string} s * @return {number} */ 题目给我们一个只包含小写字母的字符串 s，要求我们从中找出有多少对不重复的长度为 3 的回文子字符串 解题思路 由于题目只要求长度为 3 所以我们可以先找到字符串中重复字母最左的下标与最右的下标，然后遍历下标范围内不重复的字符个数就可以了 由于字符串 s 中只包含小写的字符，所以我们可以用长度为 26 的数组来保存我们所需的下标信息 Javascript /** * @param {string} s * @return {number} */ var countPalindromicSubsequence = function (s) { const BASELINE = 'a'.charCodeAt(0) const firstIdxArr = new Array(26).fill(Infinity) const lastIdxArr = new Array(26).fill(-1) let res = 0 for (let i = 0; i = right) { continue } const seenLetters = new Array(26).fill(false) for (let k = left + 1; k acc + (cur ? 1 : 0), 0) } return res }; "},"medium/2043.html":{"url":"medium/2043.html","title":"2043. Simple Bank System(medium)","keywords":"","body":"2043. Simple Bank System Leetcode link 题目简介 这是一道系统设计题 题目回调用我们的构造函数 Bank 并且传入一个数字数组 balance，其长度为账户的数量，数组内的元素代表该帐号的余额 题目要求我们实现一系列的操作： transfer：将 account1 账户的 money 转账到 account2 账户 deposit：将 money 存入 account 账户 withdraw：从 account 账户取出 money 解题思路 只需要注意这些操作失败的原因有两个： 该帐号不存在：account > balance.length 该帐号转出的钱比当前存款多：money > balance[account - 1] Javascript /** * @param {number[]} balance */ var Bank = function (balance) { this.balance = balance this.len = balance.length }; /** * @param {number} account1 * @param {number} account2 * @param {number} money * @return {boolean} */ Bank.prototype.transfer = function (account1, account2, money) { if (account1 > this.len || account2 > this.len || this.balance[account1 - 1] this.len) { return false } this.balance[account - 1] += money return true }; /** * @param {number} account * @param {number} money * @return {boolean} */ Bank.prototype.withdraw = function (account, money) { if (account > this.len || this.balance[account - 1] "},"medium/2048.html":{"url":"medium/2048.html","title":"2048. Next Greater Numerically Balanced Number(medium)","keywords":"","body":"2048. Next Greater Numerically Balanced Number Leetcode link 题目简介 /** * @param {number} n * @return {number} */ 题目给我们一个数字 n 要求我们求出比 n 大的最小的平衡数 平衡数的定义：这个数字内的每一个数字的数量必须与数字大小一致 举例：333221 就是平衡数、3221 就不是（因为 3 没有 3 个） 解题思路 这题的关键在与这个范围限制：0 由于比 10^6 更大的平衡数是 1224444，我们不难看出这个是可以通过简单的暴力判断求出的 具体而言我们从 n+1 开始循环，对每个数判断是否是平衡数，返回遇到的第一个平衡数即可 Javascript /** * @param {number} n * @return {number} */ var nextBeautifulNumber = function (n) { for (let i = n + 1; ; i++) { if (isBalance(i)) { return i } } return -1 }; const isBalance = num => { const count = new Array(10).fill(0) while (num > 0) { count[num % 10]++ num = Math.floor(num / 10) } for (let i = 0; i 0 && count[i] !== i) { return false } } return true } "},"medium/2095.html":{"url":"medium/2095.html","title":"2095. Delete the Middle Node of a Linked List(medium)","keywords":"","body":"2095. Delete the Middle Node of a Linked List Leetcode link 题目简介 /** * @param {ListNode} head * @return {ListNode} */ 题目给我们一个链表的头 head 要求我们删除链表的中间元素，并且返回新链表的头 解题思路 寻找链表的中间元素一般思路是使用快慢指针，快指针的行进速度是慢指针的两倍 这样一来一旦快指针走到链表末尾或者 null 的时候，慢指针恰巧指向中间元素 为了删除中间元素，我们需要有一个指针指向中间元素，这个指针需要在我们每次更新快慢指针之前指向慢指针 最后，为了处理只有一个元素的 case，我们加一个 if case 返回 null Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteMiddle = function(head) { if(!head.next) { return null } let slow = head let fast = head let prev = null while(fast && fast.next) { prev = slow slow = slow.next fast = fast.next.next } prev.next = slow.next return head }; "},"medium/2096.html":{"url":"medium/2096.html","title":"2096. Step-By-Step Directions From a Binary Tree Node to Another(medium)","keywords":"","body":"2096. Step-By-Step Directions From a Binary Tree Node to Another Leetcode link 解题思路 本题给了我们一棵二叉树，以及一个起点与一个终点，要求我们得出从起点到终点的最短路线 最短路线是一个字符串，有三个字符代表三个方向： U：往父节点走 L：往左边子节点走 R：往右边子节点走 本题可以分成三个步骤来走： 找到最近共同父节点 LCA(Lowest Common Ancestor)：详见代码中的 findLCA 方法 从 LCA 出发，分别遍历到起点与终点的路径：详见代码中的 findPath 方法 最后，我们将起点终点的路径拼起来，注意从起点到 LCA 的路径要全部替换成 U Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} startValue * @param {number} destValue * @return {string} */ var getDirections = function(root, startValue, destValue) { const lca = findLCA(root, startValue, destValue); let startPath = []; let destPath = []; findPath(lca, startValue, startPath); findPath(lca, destValue, destPath); return 'U'.repeat(startPath.length) + destPath.reverse().join('') }; // LCA: Lowest Common Ancestor const findLCA = (node, startValue, destValue) => { if(!node || node.val === startValue || node.val === destValue) { return node; } const left = findLCA(node.left, startValue, destValue); const right = findLCA(node.right, startValue, destValue); // 遍历到这里有两种可能： // 1. startValue 与 destValue 有一个共同的祖先节点，此时 left && right 会同时存在 // 2. startValue 或 destValue 是另一方的祖先节点，此时只有作为祖先节点的节点才会被赋值 if(left && right) { return node; } else { return left ? left : right; } } const findPath = (node, target, path) => { if(!node) { return false; } if(node.val === target) { return true; } if(findPath(node.left, target, path)) { path.push('L'); return true; } if(findPath(node.right, target, path)) { path.push('R'); return true; } return false; } "},"medium/2125.html":{"url":"medium/2125.html","title":"2125. Number of Laser Beams in a Bank(medium)","keywords":"","body":"2125. Number of Laser Beams in a Bank Leetcode link 题目简介 /** * @param {string[]} bank * @return {number} */ 题目给我们可以字符串数组 bank，其字符串都是由 0 与 1 组成 其中 0 代表当前格子是空的，1 代表当前格子有安保设施 当满足以下两个条件时，安保设施可以发出一道光束： 当两个安保设施不在同一行时（也就是不属于同一个字符串） 当两个安保设施所在的两行中间没有别的带有安保设施的行（也就是要么两个安保设施所在的行紧挨着；要么两个安保设施中间的行没有安保设施） 题目要求我们在给定的 bank 下会有多少条光束产生 解题思路 根据题目我们不难看出，如果有两行 i，j 满足产生光束的条件的话，产生的光束数量为 bank[i] * bank[j] 如果有完全没有安保设施的行的话，我们直接忽略 Javascript /** * @param {string[]} bank * @return {number} */ var numberOfBeams = function (bank) { let res = 0 // beams in previous line let prev = 0 for (let i = 0; i Javascript（或者用数组来做） /** * @param {string[]} bank * @return {number} */ var numberOfBeams = function (bank) { let res = 0 const arr = bank.map(str => { return str.split('').reduce((acc, cur) => { return acc + (cur & 1) }, 0) }).filter(num => num > 0) for (let i = 1; i "},"medium/2130.html":{"url":"medium/2130.html","title":"2130. Maximum Twin Sum of a Linked List(medium)","keywords":"","body":"2130. Maximum Twin Sum of a Linked List Leetcode link 题目简介 /** * @param {ListNode} head * @return {number} */ 题目给我们一个链表 head，链表元素长度为 len，len 为偶数 要求我们给 [0, len-1], [1, len-2], ... 的值求和，并返回最大的和 解题思路 这题需要分为两步来求解：反转链表、求和比大小 在反转链表部分，我们不需要反转整个链表，我们只需要反转前半部分的链表即可 当前半部分链表被反转之后，我们只需要同步遍历两个链表求和最后保存最大值返回即可 Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {number} */ var pairSum = function (head) { // revrese the first half of the list let prev = null let slow = head let next = slow.next let fast = head while (fast && fast.next) { fast = fast.next.next slow.next = prev prev = slow slow = next next = next.next } // now we have 2 list: prev and slow let res = -1 while(prev) { const val = prev.val + slow.val res = Math.max(val, res) prev = prev.next slow = slow.next } return res }; "},"medium/2191.html":{"url":"medium/2191.html","title":"2191. Sort the Jumbled Numbers(medium)","keywords":"","body":"2191. Sort the Jumbled Numbers Leetcode link 题目简介 本题也是一个数组排序题，题目给了我们两个入参： mapping：映射数组，代表下标到对应数字的映射，比如 [9] 代表数字 0 映射到数字 9 nums：需要被排序的数字数组 题目要求我们将 nums 的数字按照 mapping 映射之后的值升序排序，并且要求我们在元素映射后相等时不能改变对应的位置 解题思路 这一题只需要完成三步操作就可以解出： 求的 nums 中所有数字的映射值 根据映射值进行升序排序 排序过程中保证相等的元素相对位置不变（这个 js 的 sort 方法已经帮我们保证了这点） Javascript /** * @param {number[]} mapping * @param {number[]} nums * @return {number[]} */ var sortJumbled = function (mapping, nums) { // 求得数字的映射值 const transform = (num) => { return parseInt( num. toString(). split(''). map(item => mapping[item]). join('')) } const numMap = {}; for(const num of nums) { numMap[num] = transform(num); } // 根据映射值排序 return nums.sort((a, b) => numMap[a] - numMap[b]); }; "},"medium/2196.html":{"url":"medium/2196.html","title":"2196. Create Binary Tree From Descriptions(medium)","keywords":"","body":"2196. Create Binary Tree From Descriptions Leetcode link 解题思路 本题要求我们根据题目给定的描述信息，构造一个二叉树 入参是一个数组 descriptions，其中每一项包含了三个信息： parent：标识当前元素的父元素 child：标识当前元素的 value isLeft：标识当前元素是否是父元素的左节点 最后题目要求我们返回二叉树的根结点 通过观察题目给到的测试 case，我们不难发现题目给到的节点其实是乱序的 那么我们就需要维护一个 map 的映射，保证我们能够找到之前创建的节点 其次，我们还需要解决一个问题：如何找到跟节点 通过观察测试 case，我们可以得到一个结论：跟节点永远不会出现在 child 的位置上 我们可以通过这一点，维护一个 childNode Set，用来保存出现在 child 位置上的节点，最后遍历找出没在 Set 中的节点就是根结点 解决了这两个难点后，我们就可以开始遍历 descriptions 了，遍历过程中我们只需要做好四件事： 判断父节点有没有被创建过，没有的话创建一个父节点，并将其保存到 map 中 判断子节点有没有被创建过，没有的话创建一个子节点，并将其保存到 map 中 建立父子节点之间的关系 把子节点保存到 set 中 最后，我们遍历 map 然后找到没有在 set 中的节点返回就行～ Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[][]} descriptions * @return {TreeNode} */ var createBinaryTree = function (descriptions) { const childNode = new Set(); const createdNode = new Map(); for (const node of descriptions) { // 处理子节点 let curNode if (createdNode.has(node[1])) { curNode = createdNode.get(node[1]); } else { curNode = new TreeNode(node[1]); createdNode.set(node[1], curNode); } // 处理父节点 let parentNode if (createdNode.has(node[0])) { parentNode = createdNode.get(node[0]); } else { parentNode = new TreeNode(node[0]); createdNode.set(node[0], parentNode); } // 建立父子节点之间关系 if (node[2]) { parentNode.left = curNode; } else { parentNode.right = curNode; } // 记录子节点 childNode.add(node[1]); } // 找出根节点返回 for (const [key, value] of createdNode) { if (!childNode.has(key)) { return value; } } }; function TreeNode(val, left, right) { this.val = (val === undefined ? 0 : val) this.left = (left === undefined ? null : left) this.right = (right === undefined ? null : right) } "},"medium/2221.html":{"url":"medium/2221.html","title":"2221. Find Triangular Sum of an Array(medium)","keywords":"","body":"2221. Find Triangular Sum of an Array Leetcode link 题目简介 题目给我们一个数组 nums ，nums 的每一个元素都是 0～9 的数字 题目要求我们按照如下步骤计算数组直到数组长度为 1 并返回唯一的元素： 假设原数组有 n 个元素，创建一个长度为 n - 1 的数组 newArr 对于每一个符合条件 0 的 i，newArr[i] = (nums[i] + nums[i + 1]) % 10 使用 newArr 取代原来的数组 回到步骤 1 解题思路 这题有两个思路，第一个思路是直接按照题目要求模拟出来就好，复杂度是 O(n^2)，但是可以 accept 另外有一个解法用到了组合数以及中国余数定理，能够把复杂度降到 O(n) Javascript:O(n^2) /** * @param {number[]} nums * @return {number} */ var triangularSum = function(nums) { let res = [...nums] let temp = [] let i = 0 while(i Javascript: O(n) /** * @param {number[]} nums * @return {number} */ var triangularSum = function(nums) { const n = nums.length; if (n === 1) return nums[0] % 10; const m = n - 1; // --- mod 2 --- let S2 = 0; for (let i = 0; i 0 ? 0 : r5; // if any factor 5 remains, coeff ≡ 0 (mod 5) } S5 = (S5 + (nums[i] % 5) * (i === 0 ? 1 : c5)) % 5; } // --- CRT combine to mod 10 --- const t = (S2 - (S5 & 1) + 2) & 1; // choose t in {0,1} s.t. parity matches return (5 * t + S5) % 10; }; "},"medium/2257.html":{"url":"medium/2257.html","title":"2257. Count Unguarded Cells in the Grid(medium)","keywords":"","body":"2257. Count Unguarded Cells in the Grid Leetcode link 题目简介 /** * @param {number} m * @param {number} n * @param {number[][]} guards * @param {number[][]} walls * @return {number} */ 本题给了我们一个 m*n 的格子，并且在格子上标注了 guards 跟 walls 分别代表守卫跟墙体 每个守卫可以看到上下左右四个方向的所有格子，除非遇到了墙体或者另一个守卫 题目要求我们返回在给定的守卫以及墙体的情况下，有多少个格子没有被守卫看到 解题思路 很遗憾，这题其实只有一个模拟的解法 我们可以把格子分成三类： 没被守卫看到的格子 守卫或墙体在的格子 能被守卫看到的格子 我们模拟的方法就是根据题目给定的第二类格子，推导出第三类格子，最后计算第一类格子的数量 模拟步骤如下： 用一个 m*n 的数组模拟所有格子 根据题目参数标注守卫以及墙体的位置到数组对应的格子上 遍历所有守卫，对守卫的四个方向持续遍历，直到遇到了另一个守卫或者墙体，遍历过程中遇到的格子全部标注成 “能被守卫看到的格子” 当第三步遍历完成后，遍历整个数组找出 “没被守卫看到的格子” 的个数返回 Javascript /** * @param {number} m * @param {number} n * @param {number[][]} guards * @param {number[][]} walls * @return {number} */ var countUnguarded = function (m, n, guards, walls) { const UNGARDED_AREA = 0 const GUARDED_AREA = 1 const WALL_AND_GUARD_AREA = 2 const arr = new Array(m).fill(0).map(item => new Array(n).fill(UNGARDED_AREA)) for (const [row, col] of walls) { arr[row][col] = WALL_AND_GUARD_AREA } for (const [row, col] of guards) { arr[row][col] = WALL_AND_GUARD_AREA } const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]] for (const [row, col] of guards) { for (const dir of dirs) { let newRow = row + dir[0] let newCol = col + dir[1] while(newRow >=0 && newCol >=0 && newRow { return cur.filter(item => item === UNGARDED_AREA).length + acc }, 0) return res }; "},"medium/2300.html":{"url":"medium/2300.html","title":"2300. Successful Pairs of Spells and Potions(medium)","keywords":"","body":"2300. Successful Pairs of Spells and Potions Leetcode link 题目简介 题目给了 spells 与 potions 两个数组还有一个 number success，要求针对每一个 spells 中的元素 spells[i]，有多少个 potions 的元素 potions[j] 符合：spells[i] * potions[j] >= success 解题思路 针对题目要求，我们可以对 potions 做排序后，遍历当前 spells ，针对每一个 spell 用 binary search 找出符合题目要求的最小的 potions[j] 的下标 j 然后用 potions.length - j 就可以得出基于当前 spell 符合条件的 potion 有多少个了 Javascript /** * @param {number[]} spells * @param {number[]} potions * @param {number} success * @return {number[]} */ var successfulPairs = function (spells, potions, success) { potions.sort((a, b) => a - b) const res = [] spells.forEach(s => { const idx = binarySearch(potions, s, success) const count = potions.length - idx res.push(count) }) return res }; const binarySearch = (arr, multiples, target) => { let left = 0 let right = arr.length while (left > 1 if (arr[mid] * multiples >= target) { right = mid } else { left = mid + 1 } } return left } "},"medium/2327.html":{"url":"medium/2327.html","title":"2327. Number of People Aware of a Secret(medium)","keywords":"","body":"2327. Number of People Aware of a Secret Leetcode link 题目简介 有个人在第一天的时候知晓了一个秘密，但是他只会在 delay 了几天后，才会把秘密告诉另外一个人（每人每天只能告诉一个人） 而且，每个人在得知消息的 forget 天后，就会忘了这个消息，在忘记消息的当天也无法再把秘密告诉其他人 题目要我们求在第 n 天的时候，这个秘密会有多少人知道 解题思路 根据题目，我们可以把所有的人分成两个部分： 当天刚得知秘密的人：我们用 dp[i] 代表在第 i 天有多少人刚刚得知秘密 当天能够分享秘密的人：我们用 share 来代表 根据题目描述，因为第一天只有一个人知道秘密，所以 dp[1] = 1，share = 0 从第二天开始，我们需要计算 share 跟 dp[i] share 的计算有两个部分： 如果 $i - delay > 0$ ，share += dp[i - delay] ：这个等式表示，如果当前天数大于 delay 的天数之后，过了 delay 天数的那些人就可以开始分享秘密了 如果 $i-forget > 0$，share -= dp[i - forget]：这个等式表示，如果当前天数大于 forget 的天数之后，过了 forget 天数的那些人就不能分享秘密了 经过上述计算，我们可以得到当天可以 share 的人数 当天可以 share 的人数 = 当天新知道消息的人数，所以 dp[i] = share 综上，我们可以得知从第二天到第 n 天每天新得知消息的人数，那么我们要计算第 n 天还有多少人知道消息，我们只需要计算从第 n - forget + 1 天到第 n 天总共有多少人新得知消息就好，也就是 sum(dp[i]), i form (n-forget+1) to n 最后别忘了 mod 一个 $10^9+7$ Javascript /** * @param {number} n * @param {number} delay * @param {number} forget * @return {number} */ var peopleAwareOfSecret = function (n, delay, forget) { const mod = 1000000007n const dp = new Array(n + 1).fill(0n) dp[1] = 1n // the number of people who can share on that day let share = 0n for (let i = 2; i 0n) { share += dp[i - delay] } if (i - forget > 0) { share -= dp[i - forget] } dp[i] = share } let res = 0n for (let i = n - forget + 1; i "},"medium/2352.html":{"url":"medium/2352.html","title":"2352. Equal Row and Column Pairs(medium)","keywords":"","body":"2352. Equal Row and Column Pairs Leetcode link 题目简介 /** * @param {number[][]} grid * @return {number} */ 题目给我们一个 n*n 的数字数组 要求我们找到所有的 (row, col) 使得该位置的行跟列有相同的元素与排列 最后返回符合条件的 (row, col) 的个数 解题思路 这题暴力解法的话我们需要遍历 n*n 个格子的基础上，再找每个格子的行与列来比较 换个角度想，我们只需要找到列跟行相同的组合，该组合必定会对应到一个 (row, col) 格子 所以我们可以先用 map 来保存行或者列的所有排列出现的次数 然后我们再遍历剩余的列或者行，找出有相同排列的数量记录下来 最后返回我们记录的数量即可 Javascript /** * @param {number[][]} grid * @return {number} */ var equalPairs = function (grid) { let res = 0 const len = grid.length const rowMap = new Map() for (const row of grid) { const key = JSON.stringify(row) rowMap.set(key, (rowMap.get(key) || 0) + 1) } for (let i = 0; i "},"medium/2353.html":{"url":"medium/2353.html","title":"2353. Design a Food Rating System(medium)","keywords":"","body":"2353. Design a Food Rating System Leetcode link 题目简介 题目要求我们实现一个食物评分系统，其中包含三个方法 FoodRatings：构造函数，包含 foods, cuisines, ratings 三个参数分别代表食物、菜系、评分，其中食物是唯一的 changeRating：更改评分，接受 food, newRating 两个参数 highestRated：返回当前菜系最高评分的食物，接受 cuisine 一个参数 解题思路 这道题的核心难点在于，要如何在调用 highestRated 时使用最少的时间复杂度 解决方案是使用大顶堆 MaxHeap 首先我们需要几个 Map 来帮助我们保存食物、菜系、评分之间的关系： foodToCuisine：保存食物到菜系之间的映射关系 foodToRating：保存食物到评分间的映射关系 cuisineToHeap：保存菜系到大顶堆之间的映射关系 大顶堆中保存着由评分与食物组成的数组 当调用 FoodRatings 时，我们需要根据参数初始化好三个 Map 的数据 当调用 changeRating 时，我们需要更新 foodToRating 与 cuisineToHeap之中的 heap，但是 heap 中的数据不好删除，所以我们在这一步就先只插入新数据就好 最后当调用 highestRated 时，我们需要将 heap 取得的最大 rating 与当前的 foodToRating 中记录的 rating 做对比，如果不符合我们需要抛弃当前的数据（把 changeRating 时没有删除的数据在这里删除了）直到我们找到符合 foodToRating 记录的 rating leetcode 在 js 环境有提供了 PriorityQueue 的实现，所以也可以不用自己实现一个 MaxHeap Javascript（自己实现 maxHeap） /** * @param {string[]} foods * @param {string[]} cuisines * @param {number[]} ratings */ var FoodRatings = function (foods, cuisines, ratings) { this.foodTocuisine = new Map() this.foodToRating = new Map() this.cuisineToHeap = new Map() for (let i = 0; i parent's rating if (parent >= 0 && this.compare(this.heap[index], this.heap[parent]) > 0) { // swap them [this.heap[index], this.heap[parent]] = [this.heap[parent], this.heap[index]] this.heapifyUp(parent) } } heapifyDown(index) { const left = index * 2 + 1 const right = index * 2 + 2 let largest = index // if left > largest if (left 0) { largest = left } // if right > largest if (right 0) { largest = right } if (largest !== index) { [this.heap[index], this.heap[largest]] = [this.heap[largest], this.heap[index]] this.heapifyDown(largest) } } compare([ratingA, foodA], [ratingB, foodB]) { if (ratingA !== ratingB) { return ratingA - ratingB } return foodB.localeCompare(foodA) } } Javascript（使用 leetcode 提供的 PriorityQueue） /** * @param {string[]} foods * @param {string[]} cuisines * @param {number[]} ratings */ var FoodRatings = function (foods, cuisines, ratings) { this.foodTocuisine = new Map() this.foodToRating = new Map() this.cuisineToQueue = new Map() for (let i = 0; i { if (a[0] !== b[0]) return b[0] - a[0]; return a[1].localeCompare(b[1]); })) } this.cuisineToQueue.get(cuisine).enqueue([ratings[i], foods[i]]) } }; /** * @param {string} food * @param {number} newRating * @return {void} */ FoodRatings.prototype.changeRating = function (food, newRating) { this.foodToRating.set(food, newRating) const cuisine = this.foodTocuisine.get(food) this.cuisineToQueue.get(cuisine).enqueue([newRating, food]) }; /** * @param {string} cuisine * @return {string} */ FoodRatings.prototype.highestRated = function (cuisine) { const queue = this.cuisineToQueue.get(cuisine) while(!queue.isEmpty()){ const [rating, food] = queue.front() if(rating === this.foodToRating.get(food)) { return food } queue.dequeue() } return '' }; "},"medium/2390.html":{"url":"medium/2390.html","title":"2390. Removing Stars From a String(medium)","keywords":"","body":"2390. Removing Stars From a String Leetcode link 题目简介 /** * @param {string} s * @return {string} */ 题目给我们一个字符串 s，s 中包含 * 与普通字母 要求我们把 s 中的 * 与其左侧的最近字母都删掉 最后返回新的字符串 解题思路 这题的思路要使用到栈这个数据结构 我们遍历 s，当遇到 * 的时候，我们把最后一个字符 pop 出去；其他时候都正常 push 字符 最后把栈转换成字符串即可 Javascript /** * @param {string} s * @return {string} */ var removeStars = function(s) { const res = [] for(const char of s) { if(char === '*') { res.pop() } else { res.push(char) } } return res.join('') }; "},"medium/2415.html":{"url":"medium/2415.html","title":"2415. Reverse Odd Levels of Binary Tree(medium)","keywords":"","body":"2415. Reverse Odd Levels of Binary Tree Leetcode link 题目简介 题目给我们一个完美二叉树（所有父节点都有两个子节点且所有叶子节点都在同一层），要求我们将奇数层的所有叶子节点翻转（简单理解成 Array.reverse() 就好 解题思路 其实翻转的本质可以看成，有两个指针分别指向需要交换的层的最左边与最右边的节点，然后将其交换后把指针各自往中间走一步，直到指针相遇 那么我们在树中要怎么样找到当前层最左跟最右的节点呢？答案是 dfs 我们只需要在深度遍历的时候，同时遍历两个节点就好了，所以 dfs 的调用应该是这样的： dfs(node.left, node.right, level) 那么我们接下来要怎么让两个 “指针” 同时往中间走呢？答案是反过来遍历： dfs(node.right, node.left, level) 基于以上，我们可以看代码了 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {TreeNode} */ var reverseOddLevels = function(root) { const dfs = (left, right, level) => { if(left === null || right === null) { return } if(level % 2 === 1) { [left.val, right.val] = [right.val, left.val] } dfs(left.left, right.right, level+1) dfs(left.right, right.left, level+1) } dfs(root.left, root.right, 1) return root }; "},"medium/2471.html":{"url":"medium/2471.html","title":"2471. Minimum Number of Operations to Sort a Binary Tree by Level(medium)","keywords":"","body":"2471. Minimum Number of Operations to Sort a Binary Tree by Level Leetcode link 题目简介 本题给了我们一棵二叉树，并且保证了每个节点都是唯一的 题目要求我们针对每一层对这个树做升序排序，然后返回在排序中所需的最少交换次数 解题思路 首先，针对每一层的遍历，我们优先选用 bfs 来求解 有了 bfs 我们可以很快得到每一层的所有节点，并且我们可以将其升序排序 题目的难点在于要怎么获取最少的交换次数呢？ 我们可以遍历当前层的节点，通过不断把排序好的值与排序前的位置当前值进行交换，并将交换的次数记录下来，这样等到最后还原成原来的值之后，所得到的次数就是最少的次数 我们可以借用一个 map 来保存当前层所有节点的值与原来的位置（下标）的映射 有了这个映射之后，我们只需要遍历当前层，然后对比排序前后，如果不一致，从 map 中获取排序后的值原来的位置，然后做三件事： 交换新位置与原来的位置的值 更新 map 计算次数 然后不断循环对比就好 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var minimumOperations = function (root) { if (!root) return 0 let count = 0 const queue = [root] while (queue.length > 0) { const len = queue.length const curLevel = [] // bfs for (let i = 0; i a-b) // count the operations const map = new Map() for (let i = 0; i "},"medium/2536.html":{"url":"medium/2536.html","title":"2536. Increment Submatrices by One(medium)","keywords":"","body":"2536. Increment Submatrices by One Leetcode link 题目简介 /** * @param {number} n * @param {number[][]} queries * @return {number[][]} */ 本题给我们一个数字 n 代表一个 n*n 的矩阵，初始元素都是 0 还有一个二位数组 queries ，数组的每一项都是 [row1, col1, row2, col2] 代表我们要查询的矩阵范围 如果某个矩阵元素被查询到了，我们需要把该元素 +1 最后需要返回矩阵经过所有查询后的结果 解题思路——模拟 这题可以直接模拟，需要三层循环 Javascript /** * @param {number} n * @param {number[][]} queries * @return {number[][]} */ var rangeAddQueries = function (n, queries) { const matrix = Array.from({ length: n }, _ => new Array(n).fill(0)) for (const [r1, c1, r2, c2] of queries) { for (let i = r1; i 解题思路——辅助矩阵 如果想要减少时间复杂度，我们可以用一个辅助矩阵来帮助我们 如果这个辅助矩阵可以帮我们确定所有 query 的范围，我们后续只需要一次双层遍历就可以完成矩阵更新的操作 假设我们有：n = 3, queries = [[1,1,2,2]] 我们的预期结果是： 0 0 0 0 1 1 0 1 1 我们可以构建一个辅助矩阵 helperMatrix 来划分范围： 0 0 0 0 0 1 0 -1 0 0 0 0 0 -1 0 0 我们给辅助函数加了一行跟一列，这样一来我们可以用来标记 query 的范围边界 有了这个辅助函数，我们在处理矩阵第 1 行与第 1 列的时候只要把 1～-1 之间的元素加一即可： 0 0 0 0 1 1 0 1 x 现在我们要来处理第 3 行第 3 列的 x，x 的值只跟 4 个因素有关： 其左边元素的值 其上方元素的值 其左上方元素的值 辅助矩阵 helperMatrix 对应位置的值 具体公式为：辅助矩阵 helperMatrix 对应位置的值 + 其左边元素的值 + 其上方元素的值 - 其左上方元素的值 最后，我们还需要考虑 x 右下方的矩阵元素的值（如果有的话），我们需要把 x 右下角的位置加一 最后我们的辅助矩阵 helperMatrix 变成了： 0 0 0 0 0 1 0 -1 0 0 0 0 0 -1 0 1 Javascript /** * @param {number} n * @param {number[][]} queries * @return {number[][]} */ var rangeAddQueries = function (n, queries) { const helperMatrix = Array.from({ length: n + 1 }, _ => new Array(n + 1).fill(0)) for (const [r1, c1, r2, c2] of queries) { helperMatrix[r1][c1]++ helperMatrix[r1][c2 + 1]-- helperMatrix[r2 + 1][c1]-- helperMatrix[r2 + 1][c2 + 1]++ } const matrix = Array.from({ length: n }, _ => new Array(n).fill(0)) for (let i = 0; i "},"medium/2598.html":{"url":"medium/2598.html","title":"2598. Smallest Missing Non-negative Integer After Operations(medium)","keywords":"","body":"2598. Smallest Missing Non-negative Integer After Operations Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} value * @return {number} */ 题目给了一个数字数组 nums 以及一个数字 value 我们可以对数组 nums 的任意数字加或减 value 题目要求我们求出经过无限次操作之后的最大的 MEX MEX 代表数组从 0 开始遇到的第一个空缺的正整数（比如 [0, 1, 2, 3, 5] 的 MEX 就是 4 解题思路 不难看出对于任何数组元素 num，我们都可以通过无限次加减 value 得到 [0 ~ value-1] 的整数 对于正数 num，我们可以用 num % value 得到 对于负数 num，我们可以用 (value - (-num % value)) % value 得到 如此一来我们可以将数组 nums 转换成一个元素只在 [0 ~ value-1] 范围内的数组 newNums 我们最关心的其实是 newNums 中每个值的个数，所以我们可以用一个长度为 value 的数组 counts 来计算每一个元素的个数 接下来我们只需要计算出 counts 中值最小且下标最小的元素 count（对应到 newNums 出现次数最少且最小的元素） 找到后我们就可以用 count * value + i （i 代表 count 元素的下标）获得最大的 MEX 了 Javascript /** * @param {number[]} nums * @param {number} value * @return {number} */ var findSmallestInteger = function (nums, value) { const counts = new Array(value).fill(0) nums.forEach(num => { if (num "},"medium/2636.html":{"url":"medium/2636.html","title":"2636. Promise Pool(medium)","keywords":"","body":"2636. Promise Pool Leetcode link 题目简介 /** * @param {Function[]} functions * @param {number} n * @return {Promise} */ 题目要求我们用 promise 实现一个并发控制池 promisePool functions 表示待执行的异步函数 n 代表最大并发数量 promisePool 只有当所有的 functions 都执行完毕之后才能 resolve 解题思路 控制并发数量的题目，一般会需要 worker 来辅助 每一个 worker 控制一个并发任务，题目要求我们最多使用 n 个并发，所以我们可以用 n 个 worker 来实现 对于每个 worker 来说，有两个任务： 判断当前是否有未执行任务 如果有，则选取其中一个未执行任务执行，直到当前任务结束 Javascript /** * @param {Function[]} functions * @param {number} n * @return {Promise} */ var promisePool = async function (functions, n) { let idx = 0 const len = functions.length const worker = async () => { while (idx worker()) await Promise.all(promises) }; "},"medium/2654.html":{"url":"medium/2654.html","title":"2654. Minimum Number of Operations to Make All Array Elements Equal to 1(medium)","keywords":"","body":"2654. Minimum Number of Operations to Make All Array Elements Equal to 1 Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums 要求在进行一系列操作后将数组元素全部变成 1 操作描述：随意抓取相邻的两个元素，计算他们的最大公因数，然后将其中一个转变成求出的最大公因数 题目要求我们返回可能的最少操作数，如果不可能将所有元素都变成 1，则返回 -1 解题思路 根据题意，我们要把整个数组都变成 1，首先必须把其中一个元素变成 1（因为 1 跟其他数字的最大公因数都是 1） 把数组元素变成 1 的情况总共有三种： 元素本身就是 1 两个相邻元素最大公因数是 1 存在一个子数组，其中的所有元素的最大公因数是 1 第一种情况下，我们把所有元素变成 1 所需的最少操作是 nums.length - countOne，其中 countOne 是数组中 1 的个数 第二种情况跟第三种情况类似，我们合并讨论，在这种情况下我们需要的操作分别有： 假设子数组长度是 subNumLen，我们需要 subNumLen - 1 次操作把其中一个元素变为 1 一旦其中一个元素是 1 后，我们需要 nums.length - 1 次操作把剩下的元素变为 1 两者相加，就是 subNumLen - 1 + nums.length - 1 次操作 Javascript /** * @param {number[]} nums * @return {number} */ var minOperations = function (nums) { let allGCD = 0 const len = nums.length let countOne = 0 for (let i = 0; i 0) { return len - countOne } // we cannot change any num to 1 if (allGCD > 1) { return -1 } let subNumLen = len for (let i = 0; i { while (b !== 0) { let temp = b b = a % b a = temp } return a } "},"medium/2749.html":{"url":"medium/2749.html","title":"2749. Minimum Operations to Make the Integer Zero(medium)","keywords":"","body":"2749. Minimum Operations to Make the Integer Zero Leetcode link 题目简介 本题更像是一道数学题，题目给了我们两个数字 num1 与 num2，要求我们用 num1 减去多次 $2^i + num2$ 直到最终结果为 0 其中 i 的范围是 $0 \\le i \\le 60$ 解题思路 要解答这一题我们需要一些数学推导，推导前我们需要一些符号来简化描述： a 代表题目中的 num1 b 代表题目中的 num2 t 代表减去 $2^i + num2$ 的次数 c 代表一连串 2 的次方的和 下面进入推导： 有了 c，我们能很容易得出 2 的次方的个数，只要将 c 转换成二进制然后看看有几个 1 就好，这个个数我们使用 x 来代替 有了上述信息，我们可以给 t 一个范围 $x \\le t$：x 有可能小于 t 是因为会出现类似 $2^0 + 2^0 = 2^1$ 的情况，这种情况下我们只会算一个 1 $t \\le c$：在所有的 i 都为 0 的情况，t === c，否则 c > t 综上，我们得到 $x \\le t \\le c$ 的范围 接下来我们只需要在 0～60 的范围里面由小到大循环 i，直到找到符合上述范围的 i 就是我们的答案了 Javascript /** * @param {number} num1 * @param {number} num2 * @return {number} */ var makeTheIntegerZero = function (num1, num2) { const countOneInBits = num => num.toString(2).replace(/0/g, '').length for (let i = 1; i sumOfTwoPower) { return -1 } if(i >= oneInSumOfTwoPower) { return i } } return -1 }; "},"medium/2785.html":{"url":"medium/2785.html","title":"2785. Sort Vowels in a String(medium)","keywords":"","body":"2785. Sort Vowels in a String Leetcode link 题目简介 题目要求我们在给定的一个字符串中，挑出其中的母音（包括大小写）然后按照 ASC2 排序后放回原来母音的位置，最后返回新的字符串 解题思路 首先我们要准备一个排序好的大小写母音表字符串 sortedVowels（这一步能帮我们省一个排序的时间复杂度） 然后我们再准备一个与上述母音表长度相等的数组 vowelsCount，数组的元素代表同下标 sortedVowels 母音的个数，先给每个元素置 0 接着我们遍历字符串 s，挑出所有的母音字母，并给 vowelsCount 中的对应元素加上母音出现次数 最后我们再遍历一次字符串 s，替换母音字母 Javascript /** * @param {string} s * @return {string} */ var sortVowels = function(s) { const sortedVowels = 'AEIOUaeiou' const vowelsCount = new Array(sortedVowels.length).fill(0) const chars = s.split('') chars.forEach(c=> { const idx = sortedVowels.indexOf(c) if(idx > -1) { vowelsCount[idx]++ } }) let vowelsCountIdx = 0 const res = chars.map(c => { if(sortedVowels.includes(c)) { while(vowelsCount[vowelsCountIdx] === 0) { vowelsCountIdx++ } vowelsCount[vowelsCountIdx]-- return sortedVowels[vowelsCountIdx] } return c }) return res.join('') }; "},"medium/3025.html":{"url":"medium/3025.html","title":"3025. Find the Number of Ways to Place People I(medium)","keywords":"","body":"3025. Find the Number of Ways to Place People I Leetcode link 题目简介 本题会给我们若干个二维的点，要求我们找到由两个点组成的矩形，这个矩形要满足三点要求： 矩形由右下与左上的点组成 矩形的面积内不允许有其他的点 矩形可以是一条水平或垂直直线 题目要求找出符合条件的矩形个数 解题思路 由于题目要求我们找出矩形左上与右下的点，所以我们可以先给所有的点进行一个排序，排序规则如下： 所有的点按照 x 轴升序排列 如果有 x 轴相同的点，则按照 y 轴降序排列 由此排列之后的点会遵循着由左到右，由上到下的顺序 然后，我们需要一个双层的循环，来遍历图中的点 第一层循环中，我们选取第一个点，由此我们可以知道当前矩形 y 轴的上限就是第一个点的 y 坐标，我们记作 upperYLimit 在第二层循环中，我们遍历下一个点，如果遍历的点的 y 坐标小于等于 upperYLimit，那么就表示我们找到了一个符合的矩形，并将当前的 y 坐标标记为 lowerYLimit 接着我们继续在第二层循环中遍历下一个点，这个点是符合的矩形的要求就是在满足 y 坐标小于等于 upperYLimit 的情况下，y 坐标还要大于 lowerYLimit 否则该点就会出现在上一个矩形中 Javascrip /** * @param {number[][]} points * @return {number} */ var numberOfPairs = function (points) { points.sort((a, b) => { if (a[0] === b[0]) { return b[1] - a[1] } return a[0] - b[0] }) let count = 0 const n = points.length for (let i = 0; i lowerYLimit) { count++ lowerYLimit = curY if(curY === upperYLimit) { break } } } } return count }; "},"medium/3100.html":{"url":"medium/3100.html","title":"3100. Water Bottles II(medium)","keywords":"","body":"3100. Water Bottles II Leetcode link 题目简介 本题时 Water Battles 的变形，题目还是给我们两个参数：numBottles, numExchange 分别代表一开始有多少个装满水的瓶子以及多少个空瓶子能换一瓶水 但是本题加了两个条件： 每次用空瓶子换水最多只能换一瓶水 numExchange 的数量会随着交换水的次数增加，每次加一 解题思路 虽然条件修改了，但是我们还是一样用循环来模拟题目 比较容易混淆的是代码第 10 行，我们需要对 numExchange - 1，因为每次 exchange 都会换回来一个装满水的新瓶子，所以变相的，我们每次交换瓶子其实只需要 numExchange - 1 个空瓶子就好 Javascript：O(n^(1/2)) /** * @param {number} numBottles * @param {number} numExchange * @return {number} */ var maxBottlesDrunk = function (numBottles, numExchange) { let res = numBottles let emptyBottle = numBottles while (emptyBottle >= numExchange) { emptyBottle -= numExchange - 1 numExchange++ res++ } return res }; "},"medium/3147.html":{"url":"medium/3147.html","title":"3147. Taking Maximum Energy From the Mystic Dungeon(medium)","keywords":"","body":"3147. Taking Maximum Energy From the Mystic Dungeon Leetcode link 题目简介 本题提供两个参数： energy：数组，代表你经过每一个元素将会得到的能量，能量有可能为负的 k：数字，代表你每次经过元素需要略过的元素数量，假设有一个数组 [1, 2, 3, 4, 5]，而 k = 3，则如果你从第一个元素开始的话，你遍历的数组会是 [1, 4] 题目要求我们可以从数组的任何位置开始遍历，让我们求能够获得的最大能量是多少 解题思路1 从题目描述中我们不难看出，对于数组的最后 k 项，能够获得的能量就是 energy 数组的最后 k 个元素本身 所以我们接下来的关键在于，要怎么找到元素 i 与元素 i+k 之间的关系 假设我们使用数组 dp 来保存从当前元素开始遍历所能获得的能量总和，那么我们不难得出： dp[i] = dp[i+k] + energy[i] 解释：假设 i+k 是 energy 的最后一个元素，则我们从其 k 个元素前开始获取能量，我们可以多获得 energy[i] 个能量 有了这个等式，我们只要从后往前遍历数组，就能够得到所有的 dp 数组元素了，最后只要取最大值返回就是我们的答案了 Javascript /** * @param {number[]} energy * @param {number} k * @return {number} */ var maximumEnergy = function (energy, k) { const dp = [...energy] for (let i = dp.length - 1 - k; i >= 0; i--) { dp[i] = dp[i+k] + energy[i] } return Math.max(...dp) }; 解题思路2 如果仔细看我们的上一个解题思路，我们不难发现数组 dp 其实是可以被优化掉的 我们还是那个关键的等式：dp[i] = dp[i+k] + energy[i] 但是这次我们将一次的数组遍历拆开，拆成 k 次遍历，每次从 dp.length - k - i (0 开始遍历 并且记录遍历过程中的最大值，记录下来，等遍历结束直接返回就好 Javascript /** * @param {number[]} energy * @param {number} k * @return {number} */ var maximumEnergy = function (energy, k) { let res = Number.MIN_SAFE_INTEGER let step = k while (step > 0) { let totalEnergy = 0 for (let i = energy.length - step; i >= 0; i -= k) { totalEnergy += energy[i] res = Math.max(totalEnergy, res) } step-- } return res }; "},"medium/3186.html":{"url":"medium/3186.html","title":"3186. Maximum Total Damage With Spell Casting(medium)","keywords":"","body":"3186. Maximum Total Damage With Spell Casting Leetcode link 题目简介 本题给我们一个数组 power，数组的元素代表能够造成的伤害 题目限制我们如果我们输出了 power[i] 的伤害，则在 power[i]-2 ~ power[i]+2 范围内的其他伤害就无效了（注意如果有 n 个 power[i] 的伤害，我们是可以造成 power[i] * n 的伤害的 题目让我们求出我们所能打出的最高伤害是多少 解题思路 首先我们了解到，是否能打出伤害只跟伤害的值本身有关系，跟顺序无关，所以我们可以先对 power 升序排序 其次，这种累进的题目大多在考我们对于动态规划的理解，我们首先需要知道每个伤害之间的关系 假设我们有个数组 dp，它的元素代表了当前的 power 所能打出的最大伤害 接下来我们需要考虑如何构建这个数组 dp 在伤害最大化的前提，我们首选对最大的伤害 power[max] 分析一波，我们有两种选择：打出该伤害；不打出该伤害 在打出该伤害的情况下： 当前伤害 = power[max] * n（n 为伤害出现的次数） 其余伤害 = dp[j]（j 为小于 power[i]-2 的伤害中最大的那一个） 我们取和：power[max] * n + dp[j] 在不打出该伤害的情况下： 当前伤害 = 0 其余伤害 = dp[max - 1] 取和：dp[max - 1] 如果我们要伤害最大化，则对 max 来说，我们需要 dp[max] = max(dp[max - 1], power[max] * n + dp[j]) 如此一来 dp[dp.length - 1] 就会是我们的答案 但是我们还需要考虑到这个动态规划的入口，也就是我们要求 dp[i] 的时候，dp[i-1] 不能是 undefined 所以我们的 dp 数组长度需要是 power 数组去重之后的长度 + 1 Javascript /** * @param {number[]} power * @return {number} */ var maximumTotalDamage = function (power) { // { power[i]: count(power[i]) } const map = new Map() power.forEach(p => { map.set(p, (map.get(p) || 0) + 1) }) // deduplication the power const uniquePower = Array.from(map.keys()).sort((a, b) => a - b) const len = uniquePower.length const dp = new Array(len + 1).fill(0) for (let i = 0; i { let left = 0 let right = arr.length while (left > 1 if (arr[mid] >= target) { right = mid } else { left = mid + 1 } } return left } "},"medium/3217.html":{"url":"medium/3217.html","title":"3217. Delete Nodes From Linked List Present in Array(medium)","keywords":"","body":"3217. Delete Nodes From Linked List Present in Array Leetcode link 题目简介 /** * @param {number[]} nums * @param {ListNode} head * @return {ListNode} */ 这是一道关于链表的题目，题目首先给我们一个链表头 head 以及一个数组 nums 题目要求我们遍历整个链表，删除链表元素的值在 nums 数组中出现的链表元素 最后返回修改后的链表的头 解题思路 这道题如果我们从 head 出发，会发现情况有两种： head 指向的元素的只在 nums 中存在 反之，不存在 这两种的情况我们需要分开处理，会让逻辑分散 这种情况我们通常需要引入一个 “假” 的链表头来辅助我们，姑且称之为 dummy，它也是该链表的一个元素，只不过它的 next 指针指向 head 现在我们从 dummy 的视角来看这个题目，两种情况及其解决方案： head（也就是 dummy.next）元素的值存在与 nums 中：我们只需要把 dummy.next = dummy.next.next 即可 反之，不存在：我们正常遍历链表下一个元素即可 为了方便遍历，我们用一个指针 cur 来指向 dummy，遍历结束条件为 cur.next === null（也就是当前 cur 指向了链表最后一个元素） Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {number[]} nums * @param {ListNode} head * @return {ListNode} */ var modifiedList = function(nums, head) { const set = new Set(nums) const dummy = new ListNode(0, head) let cur = dummy while(cur.next) { if(set.has(cur.next.val)) { cur.next = cur.next.next } else { cur = cur.next } } return dummy.next }; "},"medium/3227.html":{"url":"medium/3227.html","title":"3227. Vowels Game in a String(medium)","keywords":"","body":"3227. Vowels Game in a String Leetcode link 题目简介 题目给我们一个字符串 s，要求我们配合 Alice 与 Bob 玩一场游戏 首先是 Alice：Alice 需要从字符串中，找出含有奇数个母音字母的子字符串，将其从原有字符串中删除 紧接着是 Bob：Bob 需要从剩下来的字符串中，找出含有偶数个母音字母的子字符串，将其从原有字符串中删除 然后回到 Alice……以此类推 最后谁无法进行下一步则判定其输了，Alice 赢的话返回 true，反之返回 false 解题思路 我们可以用贪婪的思想来思考这道题，分三种可能性： 字符串中一个母音字符都没有：Bob 包赢（因为 Alice 第一步就没法走） 字符串中有奇数个母音字符：Alice 包赢（因为她可以在一开始把整个字符串都删除，导致 Bob 完全没法走） 字符串有偶数个母音字符：Alice 包赢（在第一句 Alice 删除后，字符串会变成奇数母音字符的字符串，此时 Bob 完成他的删除后，字符串仍然只会是含有奇数个母音字符的字符串，此时回到了第二种可能性，所以 Alice 包赢） 结论：除了字符串中一个母音字符都没有的情况下，Alice 包赢 Javascript /** * @param {string} s * @return {boolean} */ var doesAliceWin = function(s) { return [...s].some(c=> ['a', 'e', 'i', 'o', 'u'].includes(c)) }; "},"medium/3228.html":{"url":"medium/3228.html","title":"3228. Maximum Number of Operations to Move Ones to the End(medium)","keywords":"","body":"3228. Maximum Number of Operations to Move Ones to the End Leetcode link 题目简介 /** * @param {string} s * @return {number} */ 题目给我们一个由 0 与 1 组成的字符串 s 要求我们经过一系列操作使得所有的 1 都在字符串的结尾（右边） 操作包含： 寻找 s 中的子字符串 \"10\" 将其中的 1 往右移直到碰到下一个 1 或者字符串结尾 举个例子：s = \"100001\"，我们选取子字符串 \"10\"（s[0] 与 s[1] ），移动后变成 \"000011\" 题目要求我们返回最多需要操作几次才能把所有的 1 都移到结尾 解题思路 根据题意我们不难发现，要想让操作次数最多，我们只需要从字符串的左边往右边找就可以了 我们假设有这么一个字符串 s：\"1001101\" 首先我们遍历第一个元素 s[0] 是 1，所以我们要把它移到下一个 1 的前面，也就是下标为 2 的位置，这个需要一次操作 字符串目前变成了 \"0011101\"，我们接下来要分别把最左边的三个 1 网右移到最后一个 1 前，需要 3 次操作 可以看出一个规律，把一串连续的 1 往右移，需要 1 的个数次操作 所以我们可以用一个变量 countOne 记录到目前为止 1 的个数，然后当我们遇到 0 的时候，我们就进行 countOne 次操作就可以了 Javascript /** * @param {string} s * @return {number} */ var maxOperations = function (s) { const len = s.length let res = 0 let countOne = 0 let i = 0 while (i "},"easy/3264.html":{"url":"easy/3264.html","title":"3264. Final Array State After K Multiplication Operations I(easy)","keywords":"","body":"3264. Final Array State After K Multiplication Operations I Leetcode link 解题思路 本题是简单题，题目说明也很简单 直接按照题目，四个步骤： 找到最小值 确保最小值第一次在数组出现的下标 将数组该下标乘以 multiplier 将上述步骤执行 k 次 Javascript /** * @param {number[]} nums * @param {number} k * @param {number} multiplier * @return {number[]} */ var getFinalState = function(nums, k, multiplier) { while(k-- > 0) { const min = Math.min(...nums) const index = nums.indexOf(min) nums[index] = min* multiplier } return nums }; "},"medium/3346.html":{"url":"medium/3346.html","title":"3346. Maximum Frequency of an Element After Performing Operations I(medium)","keywords":"","body":"3346. Maximum Frequency of an Element After Performing Operations I Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @param {number} numOperations * @return {number} */ 本题给了一个数字数组 nums，要求我们在 numOperations 次操作内，求出数组中相同数字出现最高的频率是多少 一次操作指的是我们在 nums 中选择没有操作过的元素，将其元素与 [-k, k] 范围内的整数求和 解题思路 本题题目需要我们通过操作尽可能将 nums 中的数字变成一样的（让某个数字出现频率最高） 出现频率最高的数字有两种可能： 该数字是原来 nums 中的元素 该数字不是 nums 中的元素 下面我们分开讨论 目标是 nums 中的元素 这个情况下，我们就可以省去给该元素操作的次数，然后将这些次数用来操作别的元素 那么怎么操作呢？ 首先我们需要对数组 nums 升序排序 然后我们需要遍历 nums 中的每一个元素 针对每一个元素，我们有两个指针：left、right left 指针指向的元素是比当前 nums[i] - k 大的最小的元素，也就是：nums[left] >= nums[i] - k right 指针指向的元素是比当前 nums[i] + k 大的最小元素，也就是：nums[right] > nums[i] + k 不难看出 right - left 就是当目标为 nums[i] 时，经过操作后能等于 nums[i] 的元素数量 但是题目还有一个操作限制，所以当目标是 nums[i] 时，出现的频率是：Math.min(right - left, numOperations + count) 其中 count 是 nums[i] 出现的次数 当我们把 nums 所有元素都遍历完了之后得到的最大值就是在目标是 nums 中的元素的情况下出现频率最高元素的出现次数了 目标不是nums 中的元素 在这种情况下，针对每一个 nums[i]，我们只需要看 [nums[i] - 2k, nums[i]] 这个范围内的元素个数就好 接下来我们把两种情况都处理完，得到的就是答案了 Javascript /** * @param {number[]} nums * @param {number} k * @param {number} numOperations * @return {number} */ var maxFrequency = function (nums, k, numOperations) { nums.sort((a, b) => a - b) const len = nums.length let res = 0 // if nums[i] is target let left = 0 let right = 0 // count the current element let count = 0 for (let i = 0; i = nums[i] - k while(nums[left] nums[i] + k while(right = numOperations) { return res } // now, we can handle the situation that nums[i] is not a target left = 0 const BOUNDARY = k*2 for(right = 0;right BOUNDARY) { left++ } const size = right - left + 1 res = Math.max(res, Math.min(numOperations, size)) } return res }; "},"medium/3350.html":{"url":"medium/3350.html","title":"3350. Adjacent Increasing Subarrays Detection II(medium)","keywords":"","body":"3350. Adjacent Increasing Subarrays Detection II Leetcode link 题目简介 本题是 3349 的变体 题目一样给的是数字数组 nums，这次需要我们把 k 求出来 /** * @param {number[]} nums * @return {number} */ 题目要求我们从 nums 中找出两个等长递增子数组，并且要求我们返回这个长度的最大值 k 解题思路 本题的难点有两个： 如何找出递增子数组的长度 如何通过对比计算出最长的子数组长度 第一个难点我们可以用滑动窗口来求解：我们可以定义一个 left 代表窗口的左边界、right 代表窗口的右边界 此时 right 能够增加的条件就是 right+1 nums[right]（right 没有触碰到数组边界且其下一个元素比当前元素大） 当我们确定了 right 之后，我们可以用 right - left + 1 来确定一个递增子数组的长度 为了计算最长子数组长度，我们可以通过一个变量 res 来保存当前的最长子数组长度，一开始为 1 res 的值由两个部份决定： 当前求得的最长子数组长度的一半（将一个递增子数组平均的拆成两个） 当前找到的最长子数组的长度，以及上一次找到最长子数组长度中最小的那一个（为了满足题目条件，长的需要配合短的） 于是我们可以得到 res = max(res, curSubLen >> 1, min(curSubLen, prevSubLen)) 其中 curSubLen 代表当前找到的递增子数组长度，prevSubLen 代表上一次找到的最长子数组长度 Javascript /** * @param {number[]} nums * @return {number} */ var maxIncreasingSubarrays = function (nums) { const len = nums.length let prevSubLen = 1 let left = 0 let res = 0 while (left > 1, Math.min(curSubLen, prevSubLen)) prevSubLen = curSubLen left = right + 1 } return res }; "},"medium/3381.html":{"url":"medium/3381.html","title":"3381. Maximum Subarray Sum With Length Divisible by K(medium)","keywords":"","body":"3381. Maximum Subarray Sum With Length Divisible by K Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {number} */ 题目给我们一个数字数组 nums 以及一个数字 k 要求我们求出和最大且长度可以被 k 整除的 nums 的子数组，并返回其子数组和 解题思路 想要求长度可以被 k 整除的子数组，除了找 k 的倍数长度的数组之外，还可以用两个长度对 k 同余的子数组相减获得 为了达到题目的目的，我们就必须记录余数为 0~k-1 长度的子数组的最小和 kSum 这样一来只要当前子数组长度余数为 i，我们可以用子数组 subArray - kSum[i] 获得当前长度数组的最大和 Javascript /** * @param {number[]} nums * @param {number} k * @return {number} */ var maxSubarraySum = function (nums, k) { let prefixSum = 0 let maxSum = Number.MIN_SAFE_INTEGER const kSum = new Array(k).fill(Number.MAX_SAFE_INTEGER / 2) // kSum[k - 1] stands for the subarray's min sum whose length % k === 0 kSum[k - 1] = 0 for (let i = 0; i "},"medium/3397.html":{"url":"medium/3397.html","title":"3397. Maximum Number of Distinct Elements After Operations(medium)","keywords":"","body":"3397. Maximum Number of Distinct Elements After Operations Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {number} */ 本题给我们一个数字数组 nums 以及一个数字 k 我们可以对 nums 的每一个元素进行一次操作，操作内容是可以任意加 [-k ~ k] 的数字到自身 题目要求我们得出经过操作之后可以得到多少个不重复的数组元素 解题思路 假设我们有一个输入是这样的：nums = [1,2,2,3,3,4], k = 2 那么我们可以得知，要让一个数组重复数字最少的话，就要将每个数字变成允许范围内的最小值 具体来说，我们要执行以下步骤： 将 nums 数组按照升序排序；用 curLimit 表示当前元素经过操作后的最大值；用 count 记录没有重复的元素 遍历数组元素 对于每一个 nums[i] ，求 nums[i]-k（代表当前元素可以变成的最小值） 判断 curLimit+1 与 nums[i]-k 谁大 如果 nums[i]-k 大就表示当前位置没有重复元素，可以将 nums[i] 放在这个位置，此时我们需要更新 curLimit ，然后把 count++ 如果 curLimit+1 大则代表 nums[i]-k 的位置已经被占据了，我们需要进一步判断，curLimit+1 与 nums[i]+k 谁大 如果 nums[i]+k 大，表示 nums[i] 还有放的位置，我们把它放在 curLimit+1 的位置上（更新 curLimit，count++） 如果 curLimit+1 大，表示当前的元素没办法通过操作变成不重复的元素了，我们直接跳过遍历下个元素去了 遍历结束返回 count Javascript /** * @param {number[]} nums * @param {number} k * @return {number} */ var maxDistinctElements = function (nums, k) { let count = 0 let curLimit = -Infinity nums.sort((a, b) => a - b) for (const num of nums) { const minPossibleNum = Math.max(num - k, curLimit + 1) if(minPossibleNum > num + k) { continue; } curLimit = minPossibleNum count++ } return count }; "},"medium/3408.html":{"url":"medium/3408.html","title":"3408. Design Task Manager(medium)","keywords":"","body":"3408. Design Task Manager Leetcode link 题目简介 题目要求我们实现一个 TaskManager 系统用于管理任务，并实现以下方法： add(int userId, int taskId, int priority) edit(int taskId, int newPriority) rmv(int taskId) execTop() 解题思路 这题也是在考我们关于大顶堆的实现 在构造函数的时候，我们需要用 map 来建立 task 跟 user 以及 priority 的映射，以及构建好大顶堆 在实现 add 方法的时候我们只需要将新的映射 add 进 map 中，并且 push 到大顶堆中就好 edit 与 add 相似，只是需要从 map 中将原来的映射覆盖，大顶堆中的数据则先搁置不需要删除 rmv 也是一样的，区别在于要将原来 map 中的 task 删除 execTop 时，我们需要对比当前大顶堆堆顶的数据是否还在 map 中，如果不是需要重新获取堆顶直到获取到了与 map 数据符合的 task，此时我们返回 userId 并将当前 task 使用 rmv 删除就好 Javascript（自己构建 maxHeap） /** * @param {number[][]} tasks */ var TaskManager = function (tasks) { this.taskToUserId = new Map() this.taskToPriority = new Map() this.maxHeap = new MyMaxHeap() for (const [userId, taskId, priority] of tasks) { this.taskToUserId.set(taskId, userId) this.taskToPriority.set(taskId, priority) this.maxHeap.push([taskId, priority]) } }; /** * @param {number} userId * @param {number} taskId * @param {number} priority * @return {void} */ TaskManager.prototype.add = function (userId, taskId, priority) { this.taskToUserId.set(taskId, userId) this.taskToPriority.set(taskId, priority) this.maxHeap.push([taskId, priority]) }; /** * @param {number} taskId * @param {number} newPriority * @return {void} */ TaskManager.prototype.edit = function (taskId, newPriority) { this.taskToPriority.set(taskId, newPriority) this.maxHeap.push([taskId, newPriority]) }; /** * @param {number} taskId * @return {void} */ TaskManager.prototype.rmv = function (taskId) { this.taskToPriority.delete(taskId) this.taskToUserId.delete(taskId) }; /** * @return {number} */ TaskManager.prototype.execTop = function () { while (!this.maxHeap.isEmpty()) { const [taskId, priority] = this.maxHeap.pop() if (this.taskToPriority.has(taskId) && priority === this.taskToPriority.get(taskId)) { const userId = this.taskToUserId.get(taskId) this.rmv(taskId) return userId } } return -1 }; class MyMaxHeap { constructor() { this.heap = [] } isEmpty() { return this.heap.length === 0 } peek() { return this.heap[0] } push(item) { this.heap.push(item) this.heapifyUp(this.heap.length - 1) } pop() { if (this.heap.length = 0 && this.compare(this.heap[parent], this.heap[index]) > 0) { [this.heap[parent], this.heap[index]] = [this.heap[index], this.heap[parent]] this.heapifyUp(parent) } } heapifyDown(index) { const left = index * 2 + 1 const right = index * 2 + 2 let max = index if (left Javascript（使用 PriorityQueue） /** * @param {number[][]} tasks */ var TaskManager = function(tasks) { this.taskToUserId = new Map() this.taskToPriority = new Map() this.queue = new PriorityQueue(([taskA, priorityA], [taskB, priorityB]) => { if(priorityA === priorityB) { return taskB - taskA } return priorityB - priorityA }) for(const [userId, taskId, priority] of tasks) { this.taskToUserId.set(taskId, userId) this.taskToPriority.set(taskId, priority) this.queue.enqueue([taskId, priority]) } }; /** * @param {number} userId * @param {number} taskId * @param {number} priority * @return {void} */ TaskManager.prototype.add = function(userId, taskId, priority) { this.taskToUserId.set(taskId, userId) this.taskToPriority.set(taskId, priority) this.queue.enqueue([taskId, priority]) }; /** * @param {number} taskId * @param {number} newPriority * @return {void} */ TaskManager.prototype.edit = function(taskId, newPriority) { this.taskToPriority.set(taskId, newPriority) this.queue.enqueue([taskId, newPriority]) }; /** * @param {number} taskId * @return {void} */ TaskManager.prototype.rmv = function(taskId) { this.taskToPriority.delete(taskId) this.taskToUserId.delete(taskId) }; /** * @return {number} */ TaskManager.prototype.execTop = function() { while (!this.queue.isEmpty()) { const [taskId, priority] = this.queue.dequeue() if (this.taskToPriority.has(taskId) && priority === this.taskToPriority.get(taskId)) { const userId = this.taskToUserId.get(taskId) this.rmv(taskId) return userId } } return -1 }; /** * Your TaskManager object will be instantiated and called as such: * var obj = new TaskManager(tasks) * obj.add(userId,taskId,priority) * obj.edit(taskId,newPriority) * obj.rmv(taskId) * var param_4 = obj.execTop() */ "},"medium/3484.html":{"url":"medium/3484.html","title":"3484. Design Spreadsheet(medium)","keywords":"","body":"3484. Design Spreadsheet Leetcode link 题目简介 题目要求我们实现一个由 26 列（字母A-Z）rows 行所组成的表格并实现如下功能： void setCell(String cell, int value)：设置特定的格子为 value void resetCell(String cell)：重置特定格子为 0 int getValue(String formula)：使用 =X+Y 公式计算两个格子的和，其中 X 与 Y 可以是格子，也可以是数字 格子的表达方式为字母+数字，比如：A1, B10 解题思路 这题一开始会让人想到用一个二维数组来将表格构建出来，但是其实不用这么麻烦 我们只需要一个 Map 来保存格子与值的对应关系就好，对于没有在 map 中的格子，我们默认置零 需要特别注意的是，公式的字一个字符是 =，且公式有可能包含纯数字，所以需要判断一下 Javascript /** * @param {number} rows */ var Spreadsheet = function(rows) { this.map = new Map() }; /** * @param {string} cell * @param {number} value * @return {void} */ Spreadsheet.prototype.setCell = function(cell, value) { this.map.set(cell, value) }; /** * @param {string} cell * @return {void} */ Spreadsheet.prototype.resetCell = function(cell) { this.map.delete(cell) }; /** * @param {string} formula * @return {number} */ Spreadsheet.prototype.getValue = function(formula) { const [c1, c2] = formula.substring(1).split('+') let v1 = 0 if(!(/^[A-Za-z]$/.test(c1[0]))) { v1 = parseInt(c1) }else if(this.map.has(c1)) { v1 = this.map.get(c1) } let v2 = 0 if(!(/^[A-Za-z]$/.test(c2[0]))) { v2 = parseInt(c2) }else if(this.map.has(c2)) { v2 = this.map.get(c2) } return v1 + v2 }; "},"medium/3508.html":{"url":"medium/3508.html","title":"3508. Implement Router(medium)","keywords":"","body":"3508. Implement Router Leetcode link 题目简介 本题要求我们实现一个基于 FIFO 的网络路由，并实现一下功能 Route：构造函数，接受一个 memoryLimit 参数来表示能够缓存的网络包，如果超过会把最先缓存的包丢弃 addPacket：添加缓存包，接受 source, destination, timestamp 三个参数，分别代表数据来源、数据目的地、到达路由的时间戳；如果当前添加的缓存包数量超过了 memoryLimit，需要把最先进入路由的包丢弃；如果到达的包与当前缓存的包一致（冗余），需要丢弃到达的包并返回 false，否则返回 true forwardPacket：转发包，将最先进入路由的包转发出去，如果当前缓存为空，则返回空数组 getCount：接受 destination, startTime, endTime 三个参数，表示从当前缓存中寻找目的地为 destination 且到达时间戳在 [startTime, endTime] 的包数量 解题思路 本题主要考察的是二分搜索，难点在于要如何快速的从同样的 destination 中找出符合时间范围的包数量 为了满足题意，我们需要以下数据结构： packets：缓存队列，满足 FIFO 诉求 destToTime：由目的地到所有该目的地的数据包到达时间戳的映射（destination => [time1, time2, time3, ...]） packetKeySet：标识当前数据包的唯一标识符，用 \"source#destination#timestamp\" 构成 Javascript /** * @param {number} memoryLimit */ var Router = function (memoryLimit) { this.sizeLimit = memoryLimit this.packets = [] // map destination to timeStamp array this.destToTime = new Map() // use \"source#destination#timestamp\" as key this.packetKeySet = new Set() }; /** * @param {number} source * @param {number} destination * @param {number} timestamp * @return {boolean} */ Router.prototype.addPacket = function (source, destination, timestamp) { const key = makeKey(source, destination, timestamp) if (this.packetKeySet.has(key)) { return false } this.packetKeySet.add(key) if (this.packets.length >= this.sizeLimit) { this.forwardPacket() } this.packets.push([source, destination, timestamp]) if (!this.destToTime.has(destination)) { this.destToTime.set(destination, []) } this.destToTime.get(destination).push(timestamp) return true }; /** * @return {number[]} */ Router.prototype.forwardPacket = function () { if (this.packets.length === 0) { return [] } const [source, destination, timestamp] = this.packets.shift() const key = makeKey(source, destination, timestamp) this.packetKeySet.delete(key) this.destToTime.get(destination).shift() return [source, destination, timestamp] }; /** * @param {number} destination * @param {number} startTime * @param {number} endTime * @return {number} */ Router.prototype.getCount = function (destination, startTime, endTime) { if (!this.destToTime.has(destination)) { return 0 } const timeArr = this.destToTime.get(destination) const upperIdx = upperBound(timeArr, endTime) const lowerIdx = lowerBound(timeArr, startTime) return upperIdx - lowerIdx - 1 }; const makeKey = (source, destination, timestamp) => { return `${source}#${destination}#${timestamp}` } const upperBound = (arr, target) => { let left = 0 let right = arr.length - 1 let bound = arr.length while (left { let left = 0 let right = arr.length - 1 let bound = -1 while (left "},"medium/3542.html":{"url":"medium/3542.html","title":"3542. Minimum Operations to Convert All Elements to Zero(medium)","keywords":"","body":"3542. Minimum Operations to Convert All Elements to Zero Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 本题给我们一个数字数组 nums，要求我们经过一系列操作之后，把 nums 数组全部元素变为 0 题目要求我们求最少要多少次操作 每次操作我们都需要选择任意子数组，然后将子数组中最小的元素置为 0 解题思路 根据题目所述，我们的最优解法就是： 把整个数组当成子数组，然后把最小的元素全部置为 0 把剩下的数组从 0 的位置分为多个子数组，然后分别执行第一步 如果整个数组都为 0 了就终止操作 根据上述思路，我们可以再进一步思考一下，该如何简化 我们使用 [1, 2, 3, 2, 3] 这个例子来解释： 首先考虑单调递增的情况，也就是开头的 [1, 2, 3] 这种情况我们不难看出需要三次的操作 紧接着我们多考虑一位：[1, 2, 3, 2] 这种情况依然需要三次操作 下一步：[1, 2, 3, 2, 3] 这次需要四次操作 看出区别了吗？只要是后面一位比前一位大，我们都是需要进行额外的操作的 那么问题就变成了，我们要如何记录上一位的数字大小呢？ 我们可以使用一个栈 stack ，以下是步骤说明： 由于前三位是递增，我们将其依序入栈，此时 stack = [1, 2, 3]，需要的操作为 3 次 第四位出现了 2，比当前的栈顶 3 小，所以我们需要把当前栈顶依序出栈直到当前栈顶小于等于 2，操作次数不变 第五位出现了 3，此时栈顶为 2，我们需要把 3 入栈，操作数也需要加一，此时为 4 数组遍历完毕，返回操作数 4 Javascript /** * @param {number[]} nums * @return {number} */ var minOperations = function(nums) { const stack = [] let res = 0 for(const num of nums) { while(stack.length && stack[stack.length - 1] > num) { stack.pop() } // if the num is already 0, then do nothing if(num === 0) { continue } // if current number is larger than stack top, we must apply 1 extra op to make it 0 if(stack.length === 0 || stack[stack.length - 1] "},"medium/3607.html":{"url":"medium/3607.html","title":"3607. Power Grid Maintenance(medium)","keywords":"","body":"3607. Power Grid Maintenance Leetcode link 题目简介 /** * @param {number} c * @param {number[][]} connections * @param {number[][]} queries * @return {number[]} */ 题目给了一个数字 c 表示有 c 个电站，电站默认是上线状态 connections 表示两两电站之间的联通关系 queries 表示操作，有两种： [1, x]：表示查找 x 电站，如果 x 电站在线上则返回 x，否则返回与其联通的 id 最小的电站，如果找不到则返回 -1 [2, x]：表示将 x 电站下线 解题思路 根据题目描述，我们自然而然的能够把一个个电站归类为一个个的集合，集合内的电站要么直接要么间接的有联通关系 当我们要查找某个电站的时候，我们要经过以下步骤： 判断该电站是否是上线状态，如果是直接返回电站的 id 如果不是我们需要找到该电站所属的集合，然后查找其中最小的上线电站 id 返回 我们可以用一个数组来保存 c 个电站的上线状态 找到所属集合以及查找最小的电站 id 我们有两种方法来做：小顶堆以及并查集 下面我们展示小顶堆的方法： Javascript /** * @param {number} c * @param {number[][]} connections * @param {number[][]} queries * @return {number[]} */ var processQueries = function (c, connections, queries) { const online = new Array(c + 1).fill(true) const belongs = new Array(c + 1).fill(-1) // use to keep wvery minHeap const heaps = [] const connectionMap = new Map() // a dfs helper function to update belongs and heaps const helper = (station, heap) => { belongs[station] = heaps.length heap.enqueue(station) for (const s of (connectionMap.get(station) || [])) { if (belongs[s] = 0) { continue } const minHeap = new PriorityQueue((a, b) => a - b) helper(i, minHeap) heaps.push(minHeap) } const res = [] // handles the ops for (const [op, station] of queries) { if (op === 2) { online[station] = false continue } if (online[station]) { res.push(station) } else { // get the target heap const heap = heaps[belongs[station]] while (!heap.isEmpty() && !online[heap.front()]) { heap.dequeue() } res.push(heap.isEmpty() ? -1 : heap.front()) } } return res }; "},"hard/":{"url":"hard/","title":"Hard","keywords":"","body":"Hard "},"hard/23.html":{"url":"hard/23.html","title":"23. Merge k Sorted Lists(hard)","keywords":"","body":"23. Merge k Sorted Lists Leetcode link 题目简介 /** * @param {ListNode[]} lists * @return {ListNode} */ 题目给我们一个由链表组成的数组 lists，其中的每一个链表都是升序排序 要求我们把 lists 中的所有链表组合成一个升序排序的链表 解题思路 这道题其实是 21. Merge Two Sorted Lists 的复杂版本，但是思路也是一样的 我们只要从 lists 中选出链表两两通过 21 题的算法合并，最后合并到只剩一个链表即可 Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode[]} lists * @return {ListNode} */ var mergeKLists = function (lists) { if(!Array.isArray(lists) || lists.length === 0) { return null } while (lists.length > 1) { let arr = [] for (let i = 0; i "},"hard/25.html":{"url":"hard/25.html","title":"25. Reverse Nodes in k-Group(hard)","keywords":"","body":"25. Reverse Nodes in k-Group Leetcode link 题目简介 /** * @param {ListNode} head * @param {number} k * @return {ListNode} */ 题目给我们一个链表头 head 以及一个数字 k 要求我们把链表中连续的 k 个元素翻转，并最终返回新链表头 解题思路 这题是 24 的扩展版，如果 k = 2，这题就是 24 题 这题一样可以用递归或者循环来做，我们只讲解递归部份 递归的思路是：我们每次找到 k 个元素，将其翻转，然后把剩下的链表交给当前方法递归，最后返回翻转完的链表头 Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} k * @return {ListNode} */ var reverseKGroup = function(head, k) { if(!head) { return null } let tail = head let i=0 while(i++ { let prev = end while(head !== end) { let next = head.next head.next = prev prev = head head = next } return prev } "},"hard/32.html":{"url":"hard/32.html","title":"32. Longest Valid Parentheses(hard)","keywords":"","body":"32. Longest Valid Parentheses Leetcode link 解题思路——DP TC：O(n) SC：O(n) 题目要求我们求出最长且可以左右配对的括号子字符串长度 求极值的问题可以用动态规划来解，我们需要一个一维数组 dp，dp[i] 表示以下标 i 字符结尾的最长有效括号子字符串长度 首先，以 ( 结尾的子串它的 dp 数组对应值肯定是 0 所以我们只需要判断以 ) 结尾的部分就好，总共有两种可能性： s[i-1] == '(' && s[i] == ')'：也就是最后两位是有效括号，这个时候 dp[i] = dp[i - 2] + 2 s[i-1] == ')' && s[i] == ')'：也就是最后两位都是右括号，这个时候需要往左边找第一个未匹配的左括号 如果 s[i - dp[i - 1] - 1] == '(' 成立的话，我们可以推导出这种情况的状态转移方程为 dp[i] = dp[i - 1] + 2 + dp[i - d[i - 1] - 2] 举个例子：有个字符串 () ( () ) 首先建立一个数组 dp，初始化为 0 遍历字符串，找出上述两种情况 当 i == 1，为第一种情况，用 dp[i] = dp[i - 2] + 2 更新 dp 当 i == 4 ，为第一种情况，用 dp[i] = dp[i - 2] + 2 更新 dp 当 i == 5，为第二种情况，这个时候找到最近为匹配左括号的方法是，用自己的下标减去左边 dp 数组的匹配数量，再减去 1 如果有找到，则 i == 2 到 i == 5 这一段的 dp 可以用dp[i] = dp[i - 2] + 2 来更新 但是考虑到之前也有可能出现匹配的子串，比如这里的 s[0] 跟 s[1]，所以需要加上 dp[i - d[i - 1] - 2]，也就是 dp[1] 的值 s[0] = ( s[1] = ) s[2] = ( s[3] = ( s[4] = ) s[5] = ) 初始值 0 0 0 0 0 0 i == 1 更新后 0 2 0 0 0 0 i == 4 更新后 0 2 0 0 2 0 i == 5 更新后 0 2 0 0 2 6 C++ class Solution { public: int longestValidParentheses(string s) { vector dp(s.size(), 0); int res = 0; for(int i = 1;i=2 ? dp[i-2] : 0) + 2; } else if((i-dp[i-1]-1 >= 0) && (s[i - dp[i - 1] - 1] == '(')) { // ...)) 的情况，除了要判断最后的有效子串长度还要加上前面的子串 dp[i] = dp[i-1] + 2 + ((i - 2 - dp[i - 1] >=0) ? dp[i - 2 - dp[i - 1]] : 0); } } res = max(res, dp[i]); } return res; } }; Javascript var longestValidParentheses = function(s) { let res = 0; let dp = new Array(s.length).fill(0); for(let i=1;i=2 ? dp[i-2] : 0) + 2; } else if((i-1-dp[i-1] >= 0) && s[i-1-dp[i-1]] === '(') { dp[i] = dp[i-1] + 2 + (i-dp[i-1]>=2 ? dp[i-dp[i-1] - 2] : 0); } } res = Math.max(dp[i], res); } return res; }; 解题思路——双向遍历 TC: O(n) SC: O(1) 还有另一种方法是双向遍历，首先我们先考虑一种方法：用两个计数器 left 跟 right 分别计算左括号跟右括号出现的次数 具体步骤如下： 从左往右遍历字符串 如果遇到左括号，left++；如果遇到右括号，right++ 当 left == right 的时候，表示当前遍历的字符串是有效的，保存结果 当 right > left 的时候，表示右括号大于左括号，而单独的右括号不能组成有效字符串，所以重置 left = right = 0 上述步骤可以处理大部分的问题，但是还有一种组合会被忽略：(() 所以我们需要从右往左再遍历一次，只是这次重置条件就变成 left > right了 C++ class Solution { public: int longestValidParentheses(string s) { int res = 0; int left = 0, right = 0; for(int i=0;i left) { left = right = 0; } } left = right = 0; for(int i = s.size()-1;i>=0;i--) { if(s[i] == '(') { left++; }else { right++; } if(left == right) { res = max(res, right * 2); } if(left > right) { left = right = 0; } } return res; } }; Javascript var longestValidParentheses = function(s) { let right = 0, left = 0, res = 0; for(let i=0;i left) { right = left = 0; } } right = left = 0; for(let i = s.length-1;i>=0;i--) { if(s[i] == '(') { left++; } else { right++; } if(left === right) { res = Math.max(res, 2 * right); } else if(left > right) { right = left = 0; } } return res; }; "},"hard/41.html":{"url":"hard/41.html","title":"41. First Missing Positive(hard)","keywords":"","body":"41. First Missing Positive Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums，里面包含正数，负数，与 0 要求我们求出 nums 中没出现的最小正整数是多少 要求使用 O(n) 时间复杂度与 O(1) 空间复杂度 解题思路 这题最大的难点就是如何在题目要求的复杂度中得出解答 核心的解题思路就是，我们通过数组的下标位置标记在当前数组中出现了哪些正整数 一旦我们完成了标记，后面只需要一次遍历看哪个下标没有标记即可 解题步骤分为三步： 1. 清洗数组 遍历数组，筛选出不符合范围条件的数字：nums[i] len（因为一个长度为 len 的数组最多有 1~len 总共 len 个正整数所以超出这个范围的我们不考虑） 我们将超出这个范围的数字赋值成 len+1 2. 标记位置 遍历数组，找出符合范围的数字，并且将该数字对应的下标值为负（标记） 3. 寻找位置 遍历数组，寻找第一个不为负的元素对应下标（元素为正代表没有出现过） 如果遍历完数组都为负，则返回 len+1 Javascript /** * @param {number[]} nums * @return {number} */ var firstMissingPositive = function (nums) { const len = nums.length for (let i = 0; i len) { // use dummy number to replace original one which is out of range nums[i] = len + 1 } } for (let i = 0; i 0) { // we find the first number that is positive(positive means no appearance) return i + 1 } } // if every number in range [1, len] shows up, we return len+1 return len + 1 }; "},"hard/42.html":{"url":"hard/42.html","title":"42. Trapping Rain Water(hard)","keywords":"","body":"42. Trapping Rain Water Leetcode link 题目简介 /** * @param {number[]} height * @return {number} */ 题目给我们一个数字数组 height 表示连续柱子的高度 要求我们求出，这些柱子最多能装多少体积的水 解题思路 核心思路：任意一个柱子上方能装多少水取决于其左右两边各自最高柱子中比较低的柱子与当前柱子高度的差 举个例子： 有一个 height 为 [1, 0, 10]，其中下标为 1 的柱子最多能装 1 单位的水（其左边最高柱子高度为 1，右边最高柱子高度为 10，其中左边柱子比较低，所以用左边柱子高度减去当前柱子高度，也就是 1-0=1） 我们把这个思想带到题目中，我们需要两个指针 left，right 分别指向当前的最左与最右元素 以及两个指针 leftMax 与 rightMax 分别记录两边最高的柱子 每次操作中，我们需要把高度较低的指针往中间移一格： 如果当前的柱子高度比原来的低，则我们记录高度差 如果当前的柱子高度比原来的高，我们更新 leftMax 或 rightMax 我们持续上述操作直到 left >= right 则循环终止，此时返回我们所有记录的高度差之和即为答案 Javascript /** * @param {number[]} height * @return {number} */ var trap = function(height) { let left = 0 let right = height.length - 1 let leftMax = height[left] let rightMax = height[right] let res = 0 while(left "},"hard/51.html":{"url":"hard/51.html","title":"51. N-Queens(hard)","keywords":"","body":"51. N-Queens Leetcode link 前言 这是一道经典的 hard 题目 题目给我们一个整数 n，表示一个 n * n 的棋盘，我们的目标在于将 n 个皇后放进这个棋盘中 放置的规则就是：皇不见皇（皇后不能在彼此的同一行、同一列、同一斜线上） 暴力破解显然是不可行的，我们考虑回溯的办法 首先我们需要一个数组 queens 来记录皇后在每一行的坐标 然后我们依次在每一行放一个皇后，每个皇后的位置都要符合皇不见皇的原则 直到放到最后一行的时候，我们就能找出其中一个解了 为了要让放置的每一个皇后都能快速判断是否符合皇不见皇原则，我们有两种方法 详情见下方解题思路 解题思路——集合 TC: O(n!) SC: O(n)，其中保存皇后信息的空间复杂度是 O(n) 对每一个新行来说，有三种可能会不符合皇不见皇原则： 跟之前的皇后在同一列上 跟之前的皇后在同一斜线（右上 - 左下）上 跟之前的皇后在同一反斜线（左上 - 右下）上 所以我们可以通过三个集合来记录这三种可能： col：记录之前皇后放置的列 slash：记录之前皇后放置的行减列的差（因为在同一斜线上这个值是一样的） backslash：记录之前皇后放置的行与列的和（同理，在同一反斜线上这个值是一样的） C++ class Solution { public: vector> solveNQueens(int n) { // 存放最后的所有结果 vector> result; // 存放其中一种结果 vector queens(n, -1); // 存放已经被其他 queen 占用的列 unordered_set col; // 存放已经被其他 queen 占用的斜线（右上 - 左下） unordered_set slash; // 存放已经被其他 queen 占用的反斜线（左上 - 右下） unordered_set backslash; backtrack(n, 0, result, queens, col, slash, backslash); return result; } // 回溯法找到可以符合要求的排列 void backtrack(int n, int row, vector> &result, vector &queens, unordered_set &col, unordered_set &slash, unordered_set &backslash) { if(row == n) { // 表示找到了其中一种 vector board = generateBoard(queens, n); result.push_back(board); } else { // 遍历第 row 行的所有列 for(int i=0;i generateBoard(vector &queens, int n) { vector board; for(int i=0;i 解题思路——位运算 TC: O(n!) SC: O(n)，其中保存皇后信息的空间复杂度是 O(1) 上一个解法使用了三个集合，用了 O(n) 的空间复杂度，这个解法我们用位运算来把这部分复杂度减少到 O(1) 我们这次使用三个整数 col、slash、backslash，这三个整数的 n 个二进制位代表了可不可以放置新的皇后 如果可以放置皇后则为 0，不可以则为 1. 举个例子： 假设我们今天在第 i 行把皇后放在了第 j 列，那么这个时候我们可以先将这三个整数的第 j 位设为1 然后进入到第 i + 1 行，我们要先做三件事： col 不变 slash 左移一位 backslash 右移一位 这样我们要放置新皇后的时候，就可以用 来获取可用的位置 C++ class Solution { public: vector> solveNQueens(int n) { // 存放最后的所有结果 vector> result; // 存放其中一种结果 vector queens(n, -1); backtrack(n, 0, result, queens, 0, 0, 0); return result; } void backtrack(int n, int row, vector> &result, vector &queens, int col, int slash, int backslash) { if(n == row) { vector board = generateBoard(queens, n); result.push_back(board); } else { int available =((1 >1); queens[row] = -1; } } } // 根据找到的排列构造返回结果 vector generateBoard(vector &queens, int n) { vector board; for(int i=0;i "},"hard/52.html":{"url":"hard/52.html","title":"52. N-Queens II(hard)","keywords":"","body":"52. N-Queens II Leetcode link 解题思路 本题本质上跟 51 题的 N-Queens 是一个题，区别在于这题只需要计算个数就好 详细思路见 N-Queens，这里就选了一种方法实现了一下 C++ class Solution { public: int res = 0; int totalNQueens(int n) { vector queens(n, -1); backtrack(n, 0, queens, 0, 0, 0); return res; } void backtrack(int n, int row, vector &queens, int col, int slash, int backslash) { if(row == n) { res++; } else { int available = ((1> 1); queens[row] = -1; } } } }; "},"hard/76.html":{"url":"hard/76.html","title":"76. Minimum Window Substring(hard)","keywords":"","body":"76. Minimum Window Substring Leetcode link 题目简介 /** * @param {string} s * @param {string} t * @return {string} */ 题目给我们两个字符串 s 与 t 要求我们在 s 中找到包含 t 所有字符的最短子字符串 如果没有找到，则返回空字符串 要求时间复杂度是 O(m+n)，其中 m 与 n 分别代表 s 与 t 的字符串长度 解题思路 我们的思路是使用滑动窗口，需要两个指针 left 与 right，我们使用 s = \"ADOBECODEBANC\", t = \"ABC\" 作为例子 初始化：left = right = 0 移动 right 指针直到包含所有 t 中的字符，此时 left = 0, right = 5，子字符串为 'ADOBEC' 将 left 向右移动，直到遇到第一个在 t 中的字符，在这个例子中 left 不需要移动 我们记录当前的子字符串下标 [0, 5] 将 left 向右移动，直到越过第一个在 t 中的字符，此时 left = 1，子字符串为 'DOBEC' 重复步骤 2，继续移动 right，直到找到下一个符合条件的子字符串，此时 left = 1, right = 10，子字符串为 'DOBECODEBA' 重复步骤 3，left 移动至 3，此时 left = 3, right = 10，字符串为 'BECODEBA' 重复步骤 4，由于当前范围 [3, 10] 比 [0, 5] 大，所以维持原纪录 （以此类推） Javascript /** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function (s, t) { if (s.length 0) { remainingChars-- } // handle redundant char which is in t if (map.has(char)) { map.set(char, map.get(char) - 1) } if (remainingChars === 0) { while (true) { const leftChar = s[left] if (map.has(leftChar) && map.get(leftChar) === 0) { // we find the leftmost char which is in t // update window if (window[1] - window[0] > right - left) { window[0] = left window[1] = right } // update map and remainingChars remainingChars++ map.set(leftChar, 1) left++ break } // handle redundant char which is in t if(map.has(leftChar)) { map.set(leftChar, map.get(leftChar) + 1) } left++ } } } return window[1] >= s.length ? '' : s.slice(window[0], window[1] + 1) }; "},"hard/84.html":{"url":"hard/84.html","title":"84. Largest Rectangle in Histogram(hard)","keywords":"","body":"84. Largest Rectangle in Histogram Leetcode link 题目简介 /** * @param {number[]} heights * @return {number} */ 本题给我们一个数字数组 heights，代表连续长方形的高度，每个长方形的宽度都是 1 题目要求我们求出这些长方形能够组成的最大长方形面积是多少 解题思路 本题是一道 hard，所以会有多个难点需要我们一一解决 首先是，我们需要明确一点，能够组成最大长方形面积的高一定是 heights 中存在的高 其次，我们需要解决的问题是，我们要怎么求 heights 中任意高度 height[i] 能组成长方形的面积？ 长方形的高度我们确认了，就是 height[i] 本身，那么宽度呢？ 我们拿题目中的例子一的图来解释： 假设我们需要求高度为 5 的长方形最大的宽度，我们需要找到左右第一个比当前高度低的元素 在上面的例子中，左边第一个比 5 低的元素是 1（下标 1），右边第一个比 5 低的元素是 2（下标 4） 我们可以通过右边下标 - 左边下标 - 1 来求出高度为 5 能组成的最大长方形的宽，也就是 4 - 1 - 1 = 2 于是，面积就是 2 * 5 = 10 解决了如何计算所有高度的最大面积后，我们很自然的可以遍历所有高度，然后针对每一个高度遍历出第一个左右比当前低的下标求面积 但是为了进一步降低复杂度，我们需要再进一步思考，我们是否可以在一次遍历中同时求出左右下标？ 答案是可以的，我们可以用一个单调栈来实现，这个栈是单调递增的，会按顺序保存所有比当前元素低的元素 我们用单调栈的视角来过一次上面的例子： 下标 高度 stack 0 2 [-1, 0] 1 1 [-1, 1] 2 5 [-1, 1, 2] 3 6 [-1, 1, 2, 3] 4 2 [-1, 1, 4] 5 3 [-1, 1, 4, 5] 首先，我们需要给单调栈一个 “哨兵”（-1），这个哨兵的作用是让我们上面的 右边下标 - 左边下标 - 1 公式在 heights 左边界时也能持续生效 其次，我们需要遍历 heights，在遍历中比较当前 stack 栈顶元素与当前 heights[i] 的高度： 如果当前高度比栈顶高，直接把当前的下标入栈（选择下标是因为计算 width 只需要下标，而且高度可以通过下标获得） 如果当前高度比栈顶低（或者相等），我们需要把栈中比当前高度高的元素全部出栈 在元素出栈的时候，我们要顺势计算出栈高度能组成的最大长方形面积，怎么计算呢？ 还是刚刚的思路，首先高度就是可以通过出栈的下标去 heights 中找到；其次宽度我们需要找到左右下标 而当前出栈元素的左下标就是它在栈中的上一个元素；右下标就是当前遍历元素 通过刚刚的思路遍历完所有元素后，我们还需要写另外一个循环把栈中剩下元素清空 或者，我们可以给 height push 一个非常低的高度，让它在最后一次循环中把栈清空，比如 -1 至此，我们就可以在一次循环中结束所有计算 Javascript /** * @param {number[]} heights * @return {number} */ var largestRectangleArea = function (heights) { // monotonous stack(increasing) const stack = [-1] // a little tricky, this can avoid another loop heights.push(-1) let res = 0 for (let i = 0; i 1 && heights[stack[stack.length - 1]] >= heights[i]) { const idx = stack.pop() // 2. calculate the area const height = heights[idx] const width = i - stack[stack.length - 1] - 1 res = Math.max(res, height * width) } // 3. push current height's index to the stack stack.push(i) } return res }; "},"hard/124.html":{"url":"hard/124.html","title":"124. Binary Tree Maximum Path Sum(hard)","keywords":"","body":"124. Binary Tree Maximum Path Sum Leetcode link 题目简介 /** * @param {TreeNode} root * @return {number} */ 题目给我们一颗二叉树的根节点 root，要求我们找出二叉树中的一条路径使得该路径所有节点之和最大 路径的定义：路径之间两两节点必须有边连接，且相同的节点不允许经过两次 举个例子： a | b | \\ c d a->b->c，a->b->d，c->b->d 都是路径；a->b->c->d 不是路径（因为 c 跟 d 不存在边连接） 解题思路 求二叉树节点之和最大，我们优先考虑使用 DFS 来遍历该二叉树 当我们遍历到每一个节点的时候，我们有两件事需要做： 我们需要计算以当前节点为根的子树所有路径之和最大的值是多少（对应到我们上述例子的 c->b->d 这种情况） 我们需要计算如果当前节点能向上传递的最大路径之和是多少（对应 a->b->c，a->b->d 二选一的情况） 第一种情况，站在 b 的视角，我们要考虑的是 max(b, b+c, b+d, b+c+d c, d) 第二种情况，站在 b 的视角，我们要考虑的是 max(b, b+c, b+d) 对于每次 dfs ，我们都要用变量记录第一种情况；返回第二种情况 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var maxPathSum = function (root) { let max = root.val const dfs = (node, sum) => { if (!node) { return sum } const leftBranchSum = dfs(node.left, sum) const rightBranchSum = dfs(node.right, sum) const maxSingleBranchSum = Math.max(leftBranchSum + node.val, rightBranchSum + node.val, node.val) max = Math.max(max, leftBranchSum + rightBranchSum + node.val, maxSingleBranchSum) return maxSingleBranchSum } dfs(root, 0) return max }; "},"hard/135.html":{"url":"hard/135.html","title":"135. Candy(hard)","keywords":"","body":"135. Candy Leetcode link 解题思路 本题要求我们给一排有排名的小朋友发糖果，规则有二： 每个小朋友至少要给一颗糖 相邻的小朋友如果有一方排名较高，则应该多给糖果 题目要求我们求出最少要给多少个糖果 我们可以拆分一下题目规则： 当我们从左边往右边发糖果的时候，如果右边的小孩比左边排名高，则多给一颗糖，否则就给一颗糖 当我们从右边网左边发糖果的时候，如果左边的小孩比右边的排名高，则多给一颗糖，否则就给一颗糖 所以我们只需要用两次遍历，然后在两种发糖果的方法中找出比较少的糖果组合返回就好 Javascript var candy = function(ratings) { const len = ratings.length; const left = new Array(len).fill(1); let res = 0; for(let i = 0;i 0 && ratings[i] > ratings[i - 1]) { left[i] = left[i - 1] + 1; } } let right = 1; for(let i = len - 1;i >= 0;i--) { if(i ratings[i + 1]) { right++; } else { right = 1; } res += Math.max(right, left[i]); } return res; }; "},"hard/239.html":{"url":"hard/239.html","title":"239. Sliding Window Maximum(hard)","keywords":"","body":"239. Sliding Window Maximum Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {number[]} */ 题目给我们一个数字数组 nums，以及一个长度为 k 的滑动窗口，滑动窗口会从数组左边滑动到最右边 要求我们返回窗口每次滑动过程中能看到的最大元素 例子： Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 解题思路 我们如果直接用模拟窗口滑动计算窗口内元素最大值的方式，复杂度会变成 O(nk)，其中 n 是 nums 的长度，k 是滑动窗口的长度 所以这题的核心就是想办法把查找窗口中最大值的复杂度从 k 变成 1 要做到这点，我们要从窗口的移动入手，窗口移动时，其左边界 left 有两种可能： nums[left] 不是上一个窗口的最大值 nums[left] 是上一个窗口的最大值 第一种可能好处理，直接忽略即可；第二种可能我们需要重新在新的滑动窗口中找到最大值 所以我们需要维护一个单调递减队列 维护方式就是，当滑动窗口右移的时候，弹出所有比新加入滑动窗口的元素小的元素后，再把新元素加入队列中 拿上面的例子来说： Window position Max Queue --------------- ----- ----- [1 3 -1] -3 5 3 6 7 3 [3, -1] 1 [3 -1 -3] 5 3 6 7 3 [3, -1, -3] 1 3 [-1 -3 5] 3 6 7 5 [5] 1 3 -1 [-3 5 3] 6 7 5 [5, 3] 1 3 -1 -3 [5 3 6] 7 6 [6] 1 3 -1 -3 5 [3 6 7] 7 [7] 可以看到，Queue 中的第一个值，就等于我们要求的最大值 Javascript /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var maxSlidingWindow = function (nums, k) { // monotonic decreasing queue const queue = [] const res = [] for (let right = 0; right 0 && nums[queue[queue.length - 1]] queue[0]) { queue.shift() } if(left >=0) { res.push(nums[queue[0]]) } console.log(queue) } return res }; "},"hard/295.html":{"url":"hard/295.html","title":"295. Find Median from Data Stream(hard)","keywords":"","body":"295. Find Median from Data Stream Leetcode link 题目简介 var MedianFinder = function() {}; /** * @param {number} num * @return {void} */ MedianFinder.prototype.addNum = function(num) {}; /** * @return {number} */ MedianFinder.prototype.findMedian = function() {}; 题目要求我们实现三个方法，来随时取出一个数据流中的中位数 解题思路 中位数的本质是我们要找到一个地方其左右两边的数个数相等 第一种想法是我们可以用两个数组来保存 “比当前中位数小的数” 以及 “比当前中位数大的数” 但是这种想法会导致我们在插入过程需要大量的排序操作 所以我们换一种数据结构，使用堆来做 具体来说就是用大顶堆来保存比当前中位数小的元素；用小顶堆来表示比当前中位数大的元素 只要我们维持好两个堆的元素数量相差小于 2，我们就可以断定：中位数必在大顶堆或者小顶堆堆顶之间产生 Javascript var MedianFinder = function () { this.maxHeap = new PriorityQueue((a, b) => b - a) this.minHeap = new PriorityQueue((a, b) => a - b) }; /** * @param {number} num * @return {void} */ MedianFinder.prototype.addNum = function (num) { const peak = this.maxHeap.front() if(peak && num > peak) { this.minHeap.enqueue(num) } else { this.maxHeap.enqueue(num) } const maxHeapSize = this.maxHeap.size() const minHeapSize = this.minHeap.size() if(minHeapSize - maxHeapSize > 1) { this.maxHeap.enqueue(this.minHeap.dequeue()) } else if(maxHeapSize - minHeapSize > 1) { this.minHeap.enqueue(this.maxHeap.dequeue()) } }; /** * @return {number} */ MedianFinder.prototype.findMedian = function () { const maxHeapSize = this.maxHeap.size() const minHeapSize = this.minHeap.size() if(maxHeapSize === minHeapSize) { return (this.maxHeap.front() + this.minHeap.front()) / 2 } else if(maxHeapSize > minHeapSize){ return this.maxHeap.front() } else { return this.minHeap.front() } }; /** * Your MedianFinder object will be instantiated and called as such: * var obj = new MedianFinder() * obj.addNum(num) * var param_2 = obj.findMedian() */ "},"hard/329.html":{"url":"hard/329.html","title":"329. Longest Increasing Path in a Matrix(hard)","keywords":"","body":"329. Longest Increasing Path in a Matrix Leetcode link 解题思路 题目要求我们在 m * n 的矩阵中找出最长连续递增路径长度，且只能往上下左右走 这道题咋看之下只能用 dfs 针对每一个矩阵元素分别进行遍历，想当然这么做肯定 TLE 经过仔细观察我们不难发现，当前节点的最长连续递增路径长度（以下简称路径），等于它上下左右四个元素的最长路径 + 1 于是我们就可以用一个数组 dp 来保存计算过的元素路径，之后遇到直接返回就完事了 以下是代码思路： 对矩阵的每一个元素都进行一次 dfs，将每次 dfs 的结果与当前结果比较，保留比较大的那个 在 dfs 中，首先判断当前的元素在 dp 数组中是否存在路径，存在的话直接返回 不存在的话则需要对它的上下左右四个方向节点进行判断： 是否越界 是否比当前元素大 如果没有越界且比当前元素大，则对其进行 dfs 最后将 dfs 的结果 +1 与当前路径做比较，保存比较长的路径 更新 dp C++ class Solution { public: vector> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; int longestIncreasingPath(vector>& matrix) { int m = matrix[0].size(), n = matrix.size(); vector> dp(n, vector(m, 0)); int res = 0; for(int i = 0;i > &dp, vector> &matrix) { if(dp[i][j]) { return dp[i][j]; } int m = matrix[0].size(), n = matrix.size(); int path = 1; for(vector dir: dirs) { int x = i + dir[0], y = j + dir[1]; if(x = n || y = m || matrix[x][y] Javascript const dirs = [[0,1], [0,-1], [1,0], [-1,0]]; var longestIncreasingPath = function(matrix) { // dp[i][j]: 从 [i, j] 开始的最长递增路径 let dp = new Array(matrix.length) for(let i=0;i= n || x = m || matrix[x][y] "},"hard/330.html":{"url":"hard/330.html","title":"330. Patching Array(hard)","keywords":"","body":"330. Patching Array Leetcode link 解题思路 本题是个 hard。 题目给了我们两个参数：数组、一个数字 n。题目要求我们在给定数组中插入最少的数字让这个数组的元素能组合出 1～n 的数字 我们可以直接用一个例子来讲解：nums=[3, 5, 20]， n = 30 首先，我们需要一个变量来表示当前缺少的数，我们取名为 miss 并且初始值为 1 接着我们需要挨个比较 miss 与当前数组中的数字（用 i 作为数组遍历的下标），此时有两种情况： miss ：这种情况表示当前缺失的数字无法被数组中最小的数字补充，此时为了插入最少的数（最大化插入每个数的表示范围），我们应该插入一个 miss，此时的表达范围来到了 [0, miss*2) miss >= nums[i]：这种情况表示当前数组中有比当前缺失数字小的数，如果把它加进来，我们的表达范围变成了 [0, miss+nums[i]) 接下来我们需要做的就是遍历整个数组，直到 miss > n ，因为此时的可表示范围已经超过了 n（可表示范围来到了 [0, miss) ） 介绍完原理我们来过一次这个逻辑： 一开始我们的 miss = 1，小于 n，于是我们遍历数组第一个元素 3，发现 miss （情况 1），于是我们需要插入 1 到数组，此时我们的表示范围为 [0, 2) （2 代表 miss 2）（*注意右侧为开区间） 此时 miss = 2，我们依然比较第一个元素 3，发现 miss （情况 1），于是我们需要插入数字 2 到数组，此时我们的表示范围来到了 [0, 4) （4 代表 miss * 2） 此时 miss = 4，我们依然比较第一个元素 3 ，发现 miss > 3（情况 2），于是我们把数组元素 3 加进来，此时我们的表示范围来到了 [0, 7) （7 代表 miss + 3） 此时 miss = 7，我们比较数组的下一个元素 5，发现 miss > 5（情况 2），于是我们把数组元素 5 加进来，此时我们的表示范围来到了 [0, 12) （7 代表 miss + 5） 此时 miss = 12，我们比较数组的下一个元素 20，发现 miss （情况 1），于是我们需要插入 12 到数组，此时我们的表示范围为 [0, 24) （24 代表 miss * 2） 此时 miss = 24，我们比较数组的当前元素 20，发现 miss > 20（情况 2），于是我们把数组元素 20 加进来，此时我们的表示范围来到了 [0, 44) （44 代表 miss + 20） 此时我们数组能表示的范围已经超过了题目的 n，所以循环结束，回顾我们循环，发现只有情况 1 之下会需要插入新的数字到数组，而情况 1 出现了 3 次，所以我们的答案是 3 Javascript /** * @param {number[]} nums * @param {number} n * @return {number} */ var minPatches = function(nums, n) { let i = 0; let miss = 1; let result = 0; while(miss "},"hard/354.html":{"url":"hard/354.html","title":"354. Russian Doll Envelopes(hard)","keywords":"","body":"354. Russian Doll Envelopes Leetcode link 解题思路 本题给了我们一个二维数组，数组的每一个项代表信封的长跟宽，要求我们求出这些信封最多能套几层娃 一个简单的暴力思路是将二维数组元素依照进行升序排序，如果第一位相等则对第二位升序排序 这样一来我们只需要用两个 for 循环再加上一个 dp 数组就能够穷举出所有的可能性，最后选择最大的就好了 代码如下，只是会 TLE： C++ class Solution { public: int maxEnvelopes(vector>& envelopes) { int len = envelopes.size(); int res = 0; vector dp(len, 1); sort(envelopes.begin(), envelopes.end()); for(int i=0;i envelopes[j][0] && envelopes[i][1] > envelopes[j][1]) { dp[i] = max(dp[i], dp[j] + 1); } } res = max(dp[i], res); } return res; } }; Javascript /** * @param {number[][]} envelopes * @return {number} */ var maxEnvelopes = function(envelopes) { let len = envelopes.length; let dp = new Array(len).fill(1); envelopes.sort((a, b) => { if(a[0] === b[0]) { return a[1] - b[1]; } return a[0] - b[0]; }) for(let i=0;i envelopes[j][0] && envelopes[i][1] > envelopes[j][1] ){ dp[i] = Math.max(dp[i], dp[j]+1); } } } return Math.max(...dp); }; 既然会 TLE，为什么还要写出来呢？因为上述的解法有优化的空间 具体来说，我们可以基于上述的思路，加上一点二分搜索的操作降低复杂度： 首先对二维数组元素的排序规则改为：先对第一位进行升序，如果第一位相等，则对第二位进行降序 这样一来，我们就可以保证当数组元素第二位是升序的时候，前面的信封可以被放到后面的信封里 说明：因为元素第一位相同的情况下，第二位为降序；所以如果元素经过排序后的第二位是升序的话，则只可能是因为第一位是越来越大的，这个条件恰好符合可以放进去的约束 如此一来，我们就可以把问题简化成：求排序后的数组元素第二位的最长升序子数组长度 求最长升序子数组，我们可以用二分查找的方法： 首先维护一个一维数组 dp，把首元素先放进数组中 然后遍历比较之后的元素，如果之后的元素比首元素小，则将新元素替换旧的首元素 如果新的元素比 dp 数组中末尾元素还大的话，则 push 新元素进 dp 末尾 如果新元素介于首元素与尾元素之间，则用二分搜索找到第一个不小于新元素的元素，且用新元素替换掉它 最后我们只需要查看 dp 数组的长度就能够得出最长升序子数组的长度了 具体看代码： C++ class Solution { public: int maxEnvelopes(vector>& envelopes) { vector dp; sort(envelopes.begin(), envelopes.end(), [](const vector &a,const vector &b) { if(a[0] == b[0]) { return a[1] > b[1]; } return a[0] =dp.size()) { dp.push_back(value); }else { dp[right] = value; } } return dp.size(); } }; Javascript /** * @param {number[][]} envelopes * @return {number} */ var maxEnvelopes = function(envelopes) { let dp = []; envelopes.sort((a, b)=>{ if(a[0] === b[0]) { return b[1] - a[1]; } return a[0] - b[0]; }); for(let i=0;i dp[mid]) { left = mid + 1; }else { right = mid; } } if(right >= dp.length) { dp.push(value); }else { dp[right] = value; } } return dp.length; }; "},"hard/407.html":{"url":"hard/407.html","title":"407. Trapping Rain Water II(hard)","keywords":"","body":"407. Trapping Rain Water II Leetcode link 题目简介 本题是一道困难题，题目只给我们一个参数 heightMap 代表一个有 m*n 个格子的矩阵，每个矩阵上有 heightMap[m][n] 个格子 题目要我们求如果下雨的话，这个矩阵上面的格子最多能留下多少格的雨水 解题思路 这题我们需要先从格子的边缘开始寻找思路 我们知道一个桶最多能接多少水取决于桶子的短板，所以我们第一步要先找到矩阵边缘最低的格子，然后将其与相邻的格子对比高度： 如果相邻格子比边缘最低的格子低，那么相邻格子就可以留下 边缘最低格子高度 - 相邻格子高度 的水 如果相邻格子比边缘最低的格子高，那么我们就再找到边缘第二低的格子……以此类推 换成算法的思路的话，我们要重复如下步骤： 创建一个与 heightMap 大小相同的数组 visited 来保存已经访问过的位置 创建一个小顶堆 minHeap 并且将所有的边缘格子放进其中，将 visited 数组中边缘格子的位置设置为 true 表示已经访问过了（因为边缘的格子之间已经在小顶堆中比较过了，不需要加入相邻的比较中） 取出 minHeap 的堆顶元素，将其与相邻且还没访问过的格子比较 如果当前格子比相邻格子高，把高度加到结果 res 中，然后将当前相邻格子加到 minHeap 中，并且相邻格子的高度要取当前格子与相邻格子中较高的高度 如果当前格子比相邻格子低，则跳过 重复步骤 3，直到 minHeap 为空 返回结果 res Javascript /** * @param {number[][]} heightMap * @return {number} */ var trapRainWater = function (heightMap) { const len = heightMap.length const width = heightMap[0].length const visited = new Array(len).fill().map(item => new Array(width).fill(false)) // [height, x, y] const minHeap = new PriorityQueue((a, b) => a[0] - b[0]) // push all the edge to the minHeap and mark visited as true for (let i = 0; i = 0 && nx = 0 && ny "},"hard/410.html":{"url":"hard/410.html","title":"410. Split Array Largest Sum(hard)","keywords":"","body":"410. Split Array Largest Sum Leetcode link 解题思路——Dynamic Programming TC: SC: 本题要求我们将一个数组切割为 m 个非空子数组。考虑到切割为 m 个数组与需要参考切割为 m - 1 个数组的结果，所以可以使用动态规划来做，具体思考如下： 首先我们需要一个二维数组来保存切割数组前 i 个数为 j 个子数组的全局最小值，把它命名为 dp]i][j] 接着我们思考一下，当 j 为 1 的时候的情况：dp[i][1] 表示将数组前 i 个数切割为一组的最小值，也就是数组前 i 个数的加总，我们记为 sum[i] 接下来我们考虑 j > 1 的情况，这种情况我们可以简化一下： 首先把划分为 j 个组看成，对于前 k 个数，划分为 j - 1 个组，最后从 k + 1 到 i 划分为一组，对单个 k 计算出来的结果取最大值就是符合题目要求的一种可能性了。 我们可以对 k 做遍历之后，对所有计算出来的 dp[i][j] 取最小值就是全局最优解了 动态规划公式： C++ class Solution { public: int splitArray(vector& nums, int m) { int len = nums.size(); // sum[i]：记录前 i 个数的总和（下标从 1 开始） vector sum(len + 1, 0); // dp[i][j]：记录前 i 个数倍分割为 j 个组的全局最小值（下标从 1 开始） vector> dp(len + 1, vector(m + 1, UINT_MAX)); // 计算 sum 数组的值 for (int i = 1; i Javascript var splitArray = function(nums, m) { const len = nums.length; // sum[i]：记录前 i 个数的总和（下标从 1 开始） const sum = new Array(len +1).fill(0); // dp[i][j]：记录前 i 个数倍分割为 j 个组的全局最小值（下标从 1 开始） const dp = new Array(len + 1); for(let i = 0;i 解题思路——二分法 TC: ，sum 表示数组元素加总， maxNum 表示数组最大的元素 SC: 首先我们要先说明一下什么情况能用二分法求解：能用二分法求解的问题一定是连续且能被判断出边距的。 拿本题为例，本题要求的是所有子数组和的最大值的最小值。 接下来我们来探讨一下子数组和最大与最小的情况： 最大：当只有一个子数组的情况下，也就是 m = 1，且这个最大值为所有数组元素的加总 最小：当数组的每个元素都是一个子数组时，也就是 m = nums.size()，且这个时候最小值为数组元素的最大值 综上所述，我们的答案将会落在 [数组元素的最大值, 所有数组元素的加总] 这个范围之间。 有了边距之后，我们需要一个方法来判断结果会落在哪一边，所以我们分别讨论一下当目标太大或太小会有什么结果： 目标太大：如果我们二分的落点比较大，那么数组必须拆分的子数组就比较少（ 子数组数量 ），符合题意但需要继续缩小范围，所以我们会把右边界 right 移到二分落点 mid 上 目标太小：如果二分落点太小，数组必须拆分更多子数组，将导致 子数组数量 > m，不符合题意，所以需要将左边界 left 移到 mid + 1 C++ class Solution { public: // 检查当前的 target 是否可以实现 bool isValid(vector& nums, int m, unsigned int target) { // group 记录为了满足当前的 target 需要拆分的子数组数量 int group = 1, sum = 0; for (int i = 0; i target) { sum = nums[i]; group++; } else { sum += nums[i]; } } return group & nums, int m) { // 二分左边界应该是数组的最大值，右边界应该是数组所有元素的加总 unsigned int left = 0, right = 0, mid; for (unsigned int num : nums) { if (num > left) left = num; right += num; } while (left Javascript /** * @param {number[]} nums * @param {number} m * @return {number} */ var splitArray = function(nums, m) { // 二分左边界应该是数组的最大值，右边界应该是数组所有元素的加总 let left = 0, right = 0, mid; for (let num of nums) { if (num > left) left = num; right += num; } while (left target) { sum = nums[i]; group++; } else { sum += nums[i]; } } return group Reference 小旭讲解 LeetCode 410. 分割数组的最大值 - EP34 "},"hard/726.html":{"url":"hard/726.html","title":"726. Number of Atoms(hard)","keywords":"","body":"726. Number of Atoms Leetcode link 解题思路 本题是一道 hard 的题目 这道题第一眼看感觉还蛮简单的，但是仔细研究之后发现其中还是有蛮多坑的，我们先来研究一下题目本身： 首先本题只有一个参数，就是 formula，他代表一个化学表达式，它包含三个部分： element：元素名称，可能是一个大写的字母（比如 O），也可能是一个大写字母跟着小写字母的组合（比如 He） count：原子的个数，如果没写就是一个（比如 O2 代表两个氧原子，O 代表一个） ()：括号，代表一组元素，如果括号后面有数字，则代表有多少组括号内的元素（比如 (HO)3 代表有 3 个氢、1 个氧） 题目要求我们把括号去除掉，按照字母顺序返回所有元素及其对应的个数（比如：Mg(OH)2 变成 H2MgO2，元素按照字母顺序排列，元素的个数紧跟其后） 一般解决这种字符串嵌套有两种思路：递归、堆栈 因为递归比较好理解，我们这里使用递归的思路来去做讲解 首先我们还是要正常的去遍历题目给到的字符串，在遍历的时候会出现三种可能： 遇到字母 & 数字：持续遍历字符串，并且把对应的元素与数量保存到一个对象中 遇到 (：需要遍历到下一个字符，然后递归调用分析函数 遇到 )：需要找到后面的数字，并且将其乘到当前括号的元素内，最后需要返回当前保存的对象 等到最后递归函数处理完成后，我们需要把对象返回给原函数，原函数会对对象数据进行排序、字符串化后返回结果 Javascript /** * @param {string} formula * @return {string} */ var countOfAtoms = function (formula) { let result = []; const { res: resultMap } = parse(formula, 0); // 将对象数据整理成期望的格式 for (const [element, count] of Object.entries(resultMap)) { result.push(element + (count === 1 ? \"\" : count)); } // 记得排序后字符串化解答 return result.sort().join(''); }; const parse = (formula, i) => { let res = {}; while (i "},"hard/778.html":{"url":"hard/778.html","title":"778. Swim in Rising Water(hard)","keywords":"","body":"778. Swim in Rising Water Leetcode link 解题思路 这道题有两个解决思路，一个是用 DFS+binary search；一个是用 dijkstra + priority queue DFS+binary search 题目要求我们从左上角游到右下角，并且要求路线上最高的那个点最小的路线 从点 A 到点 B 的路线我们可以用 dfs 来搜索，但是 dfs 在找到点 B 之前无法判断当前路径是否是最优路径 所以我们可以用 grid[i][j] 这个因素来限制 dfs，其范围是：0 所以我们可以用二分法来缩小 dfs 找到最优路径的范围 步骤如下： 首先划定答案范围：max(grid[0][0], grid[n - 1][n - 1]) ～ n*n - 1，其中 n === grid.length === grid[0].length 取得范围的中间值 mid，然后从 grid[0][0] 开始进行 dfs 一旦 dfs 过程中发现所需时间大于 mid，则终止 dfs，并且将范围改为 mid ～ n*n-1 如果该 dfs 成功到达了 grid[n - 1][n - 1]，则将范围改为 max(grid[0][0], grid[n - 1][n - 1]) ～ mid 不断缩小范围直到找到最小的时间 其中二分法的复杂度是 O(logn)、dfs 的复杂度是 O(n^2) 所以这个方法的时间复杂度就是 O(n^2 logn) Javascript /** * @param {number[][]} grid * @return {number} */ var swimInWater = function (grid) { const len = grid.length const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]] const canReachInTime = (time) => { const visited = Array.from({ length: len }, _ => Array(len).fill(false)) const dfs = (x, y) => { if (x === len - 1 && y === len - 1) { return true } visited[x][y] = true for (const [dx, dy] of dirs) { const nx = x + dx const ny = y + dy if (nx >= 0 && nx = 0 && ny > 1 if (canReachInTime(mid)) { right = mid } else { left = mid + 1 } } return left }; dijkstra + priority queue 第二个方法我们用 dijkstra 来找图上两点的最短路径 dijkstra 算法的思想就是每次从已到达的点中选择它们与未到达的点的边中最小的边来搜索 所以我们要借用小顶堆来辅助 算法步骤如下： 我们先将 grid[0][0] 放入 minHeap 中 然后我们对 minHeap 进行遍历 每次遍历都取出当前堆顶元素（同时该元素也是当前堆里面最小的元素） 如果当前元素已经经过了，则忽略当前元素，返回步骤 3 如果当前元素已经到达了 grid[n - 1][n - 1]，则直接返回当前所需时间 否则将当前元素的相邻元素全部放入堆中，返回步骤 3 其中小顶堆每次入栈或出栈的复杂度是 O(logn)、对 grid 遍历的复杂度是 O(n^2) 所以这个方法的时间复杂度就是 O(n^2 logn) Javascript /** * @param {number[][]} grid * @return {number} */ var swimInWater = function (grid) { const len = grid.length // [time, x, y] const minHeap = new PriorityQueue((a, b) => a[0] - b[0]) const visited = Array.from({ length: len }, _ => Array(len).fill(false)) const dirs =[[0, 1], [0, -1], [1, 0], [-1, 0]] minHeap.enqueue([grid[0][0], 0, 0]) while(!minHeap.isEmpty()) { const [time, x, y] = minHeap.dequeue() if(visited[x][y]) { continue } visited[x][y] = true if(x === len - 1 && y === len - 1) { return time } for(const [dx, dy] of dirs) { const nx = x + dx const ny = y + dy if(nx >=0 && nx =0 && ny "},"hard/968.html":{"url":"hard/968.html","title":"968. Binary Tree Cameras(hard)","keywords":"","body":"968. Binary Tree Cameras Leetcode link 解题思路 题目让我们在一棵二叉树上安装摄像头，摄像头可以观察相邻的节点，要求我们求出能观察到完整的二叉树所需的最少摄像头个数 首先，要想让摄像头个数最少，必须让每一个摄像头的观察范围最大，这就表示我们应该尽可能的在叶子节点的父节点上安装摄像头 为了达到这个目的，我们考虑一种从下晚上遍历整个树的方法，后序遍历（左子树 -> 右子树 -> 根节点） 我们观察到，加入摄像头之后，二叉树的节点会有三种情况： 未覆盖，我们记为 0 有摄像头： 我们记为 1 已覆盖： 我们记为 2 接下来，我们的目的就是在后序遍历二叉树的时候，为每个节点判断状态： 首先是空节点，空节点肯定不能放摄像头，所以不会是状态 1；其次，如果我们把空节点记为状态 0 未覆盖的话，遍历到叶子节点的时候就必须放摄像头了，这个与我们的原则不符。所以空节点都记为状态 2，已覆盖 其次，当我们更新到中间任意节点的时候，会有四种可能： 左节点跟右节点都有覆盖了 left == 2 && right == 2：这种情况我们就把当前节点设置为 0，未覆盖 左节点跟右节点有一个是未覆盖 left == 0 || right == 0：这种情况我们必须把当前节点设置为 1，放一个摄像头 左节点跟有节点至少有一个放了摄像头 left == 1 || right == 1：我们把当前节点设置为 2，已覆盖 最后，当我们遍历到根节点的时候，如果根节点的状态是 0，则需要为根节点再加一个摄像头 C++ class Solution { public: int res = 0; int minCameraCover(TreeNode* root) { // 0: 无覆盖 // 1: 有摄像头 // 2: 有覆盖 if(traversal(root) == 0) { res++; } return res; } int traversal(TreeNode* root) { if(root == nullptr) { return 2; } int left = traversal(root->left); int right = traversal(root->right); // 如果两个都有覆盖了 if(left == 2 && right == 2) { return 0; } // 如果其中一个子节点没有覆盖，在当前节点放一个摄像头 if(left == 0 || right == 0) { res++; return 1; } // 如果至少一个子节点有摄像头 if(left = 1 || right == 1) { return 2; } // 这里永远不会走到 return -1; } }; Javascript var minCameraCover = function(root) { // 摄像头个数 let res = 0; // 0: 无覆盖 // 1: 有摄像头 // 2: 有覆盖 let traversal = (node) => { // 空节点：有覆盖 if(node == null) { return 2; } // 左子树 -> 右子树 -> 父节点 let left = traversal(node.left); let right = traversal(node.right); // 如果左右节点都覆盖了，表示当前节点还没被覆盖 if(left === 2 && right === 2) { return 0; } // 如果其中一个子节点还没被覆盖，则在当前节点加一个摄像头 if(left === 0 || right === 0) { res++; return 1; } // 如果其中一个子节点有摄像头，当前节点就是有覆盖状态 if(left === 1 || right === 1) { return 2; } } // 如果遍历到根节点发现根节点是没覆盖的，要加一个摄像头在根节点上 if(traversal(root) === 0) { res++; } return res; }; Reference https://leetcode.cn/problems/binary-tree-cameras/solution/968-jian-kong-er-cha-shu-di-gui-shang-de-zhuang-ta/ "},"hard/1192.html":{"url":"hard/1192.html","title":"1192. Critical Connections in a Network(hard)","keywords":"","body":"1192. Critical Connections in a Network Leetcode link 解题思路 本题是个 hard。 题目要求我们找出关键链接，所谓关键链接就是如果去掉的话，会导致本来连通的节点不连通了 观察题目给出的图示，我们不难看出，关键链接就是不在环上的链接（因为只要有多个节点成环了，那么环内的每个节点至少会有两条边） 有了上述结论，我们可以把问题抽象为：找出图中所有的环，并忽略环上的边，剩下的边就是关键链接 比如题目中的 Example 1 可以看成： 这样一来，问题就变成了两个： Q：如何标记一个环？ ​ A：我们给每一个每一个节点一个独一无二 id，如果成环了，则环内节点 id 全部设置为当前环内节点 id 的最小值 Q：如何在图中找出环？ ​ A：使用 dfs，只要遍历过程中遇到了遍历过的节点，就表示遇到环了，dfs 返回当前节点的 id 接下来，我们来理一下算法的思路： 首先我们需要建立一个表 map，保存所有节点的邻接节点 然后我们需要一个数组 groupId，保存每个节点的 id，初始化为 -1 任选一个节点为根节点，对其进行 dfs，将根节点的 id 置为 0 在 dfs 中，然后遍历当前节点的邻接节点，此时会有三种可能性： 邻接节点为当前节点的父节点：直接 continue 邻接节点还没遍历过 id == -1：对邻接节点进行 dfs，设置其 id 为当前 id+1，如果 dfs 返回的 id 比当前 id 小，更新当前 id 邻接节点遍历过了 id != -1：表示遇到环了，更新 id 为环内最小的 id 遍历并更新完邻接节点之后，我们判断一下一开始传入的 id 与更新后的 id 是否相同 如果相同则表示当前节点的子节点无法遍历到父节点（因为如果可以的话 id 应该比传入 id 更小），当前节点与父节点的链接就是关键链接 判断完之后返回当前节点的最终 id 结束 dfs 之后，返回关键链接的集合就好 C++ class Solution { public: vector> criticalConnections(int n, vector> &connections) { // 构造一个节点与其邻接节点的映射表 unordered_map> map; buildMap(map, connections); // id 用来表示节点是否属于同一个组（是否成环） vector groupId(n, -1); // 存放 critical connections vector> res; dfs(0, -1, 0, groupId, map, res); return res; } void buildMap(unordered_map> &map, vector> &connections) { for (auto connection : connections) { map[connection[0]].push_back(connection[1]); map[connection[1]].push_back(connection[0]); } } int dfs(int cur, int parent, int id, vector &groupId, unordered_map> &map, vector> &res) { groupId[cur] = id; // 遍历当前的邻接节点 for (int node : map[cur]) { if (node == parent) { // 邻接节点是父节点直接略过 continue; } else if (groupId[node] == -1) { // 如果子节点没有遍历过，对其 dfs 计算子节点的 id // 如果子节点的 id 小于当前 id，表示成环了，要更新当前 id groupId[cur] = min(groupId[cur], dfs(node, cur, id + 1, groupId, map, res)); } else { // 如果邻接节点有遍历过且 id 比较小，表示成环，需要更新当前 id groupId[cur] = min(groupId[cur], groupId[node]); } } // 如果传入的 id 跟计算之后的 id 相等，表示当前节点跟父节点不在同一个环内，两者之间的链接就是 critical connection if (id == groupId[cur] && cur != 0) { res.push_back({parent, cur}); } return groupId[cur]; } }; Javascript /** * @param {number} n * @param {number[][]} connections * @return {number[][]} */ var criticalConnections = function(n, connections) { // 构造一个节点与其邻接节点的映射表 let map = {}; buildMap(map, connections); // id 用来表示节点是否属于同一个组（是否成环） let groupId = new Array(n).fill(-1); // 存放 critical connections let res = []; dfs(0, -1, 0, groupId, map, res); return res; }; var buildMap = function(map, connections) { for(let connection of connections) { map[connection[0]] ? map[connection[0]].push(connection[1]) : map[connection[0]] = [connection[1]]; map[connection[1]] ? map[connection[1]].push(connection[0]) : map[connection[1]] = [connection[0]]; } } /** * @param cur 当前遍历节点 * @param parent 当前遍历节点的父节点 * @param id 当前节点的默认 id * @param groupId 存放所有节点 id 的数组 * @param map 存放所有节点与其邻接节点的映射表 * @param res 用来放 critical connections * @return id 当前节点计算后的 id */ var dfs = function(cur, parent, id, groupId, map, res) { groupId[cur] = id; // 遍历当前的邻接节点 for(let node of map[cur]) { if(node == parent) { // 邻接节点是父节点直接略过 continue; } else if(groupId[node] === -1) { // 如果子节点没有遍历过，对其 dfs 计算子节点的 id // 如果子节点的 id 小于当前 id，表示成环了，要更新当前 id groupId[cur] = Math.min(groupId[cur], dfs(node, cur, id+1, groupId, map, res)); } else { // 如果邻接节点有遍历过且 id 比较小，表示成环，需要更新当前 id groupId[cur] = Math.min(groupId[cur], groupId[node]); } } // 如果传入的 id 跟计算之后的 id 相等，表示当前节点跟父节点不在同一个环内，两者之间的链接就是 critical connection if(groupId[cur] === id && cur!= 0) { res.push([parent, cur]); } return groupId[cur]; } Reference https://www.bilibili.com/video/BV15t4y197eq?spm_id_from=333.337.search-card.all.click "},"hard/1526.html":{"url":"hard/1526.html","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array(hard)","keywords":"","body":"1526. Minimum Number of Increments on Subarrays to Form a Target Array Leetcode link 题目简介 /** * @param {number[]} target * @return {number} */ 题目在一开始给我们一个长度为 target.length 的全 0 数组，要求我们每次选择其中的一个子数组给子数组每个元素 +1，使其最后变成 target 数组 题目要求我们返回最少的选择步骤需要多少步 解题思路 这题乍看是一道 hard，其实要比想像中简单 我们从数组的第一个元素开始看： 要将 0 变成 target[0] 需要 target[0] 步 如果 target[1] 比 target[0] 小（或相等），我们可以把 target[1] 跟 target[0] 划分到同一个子数组中，在这种情况下将 0 变成 target[1] 也只需要 target[0] 步 反之如果 target[1] 比 target[0] 大，则我们还需要 target[1] - target[0] 步才能将 0 也变成 target[1] 结合上面三点，我们只需要一次遍历就可以搞定 Javascript /** * @param {number[]} target * @return {number} */ var minNumberOperations = function (target) { let res = target[0] for (let i = 1; i target[i - 1]) { res += target[i] - target[i - 1] } } return res }; "},"hard/1912.html":{"url":"hard/1912.html","title":"1912. Design Movie Rental System(hard)","keywords":"","body":"1912. Design Movie Rental System Leetcode link 题目简介 这是一道困难题，而且是比较有意思的系统设计题 题目要求我们设计一个电影租赁系统，题目要求我们实现以下方法： MovieRentingSystem(int n, int[][] entries)：构造函数，参数 n 代表我们有 n 家店、参数 entries 代表 [shop, movie, price] 三元组，表示在 shop 中有 movie 可以租借，价格为 money List search(int movie)：搜索所有有 movie 且还未出租的店家，找到 price 最低的前 5 家店返回，如果 price 一样，则 shop 低的优先返回 void rent(int shop, int movie)：将 movie 从 shop 中租出去 void drop(int shop, int movie)：把 movie 还到 shop（只能还回原 shop） List> report()：从所有租出去的电影中，返回最便宜的前五个电影的 [shop, movie] 二元组，如果 price 一致，返回 shop 低的，如果 shop 也一致，返回 movie 低的 解题思路 这题的思路有两个： 排序数组 小顶堆 前者在数据量大的情况下性能表现不如后者，但是在 leetcode 的测试 case 中性能会比后者好一些，我直接放代码，不赘述，后面主要讲解小顶堆的思路 这道题的关键在于 search 与 report 方法，要想办法减少这两个方法的复杂度 search 方法我们可以用一个 movie => heap 的 movieHeap 来保存从 map 到小顶堆的映射，此处的 heap 只需要保存 [shop, price] 就好；除了 map 之外，我们还需要一个 Set unRentedMovie 来保存还未出租的 movie，用来筛选 map 返回 report 方法我们可以直接维护一个小顶堆 rentedHeap 来保存所有已经出租出去的电影，这个 heap 我们保存 [shop, movie, price] 最后在 rent 的时候，题目给的参数没有给 price，所以我们还需要一个 map priceMap 来保存从 [shop, movie] 到 price 的映射 Javascript（小顶堆） /** * @param {number} n * @param {number[][]} entries */ var MovieRentingSystem = function (n, entries) { this.resultLimit = 5 // movie => Heap([shop, price]) for search this.movieHeap = new Map() // shop#movie this.unRentedMovie = new Set() // Heap([shop, movie, price]) for report this.rentedHeap = new MyHeap(([sA, mA, pA], [sB, mB, pB]) => { return pA - pB || sA - sB || mA - mB }) // shop#movie => price this.priceMap = new Map() for (const [shop, movie, price] of entries) { const key = getKey(shop, movie) this.unRentedMovie.add(key) this.priceMap.set(key, price) if (!this.movieHeap.has(movie)) { this.movieHeap.set(movie, new MyHeap(([sA, pA], [sB, pB]) => { return pA - pB || sA - sB })) } this.movieHeap.get(movie).push([shop, price]) } }; /** * @param {number} movie * @return {number[]} */ MovieRentingSystem.prototype.search = function (movie) { if (!this.movieHeap.has(movie)) { return [] } const res = [] const retain = [] const heap = this.movieHeap.get(movie) const seen = new Set() while (!heap.isEmpty() && res.length heap.push(item)) return res }; /** * @param {number} shop * @param {number} movie * @return {void} */ MovieRentingSystem.prototype.rent = function (shop, movie) { const key = getKey(shop, movie) if (this.unRentedMovie.has(key)) { this.unRentedMovie.delete(key) } // test case ensure to have shop and movie in shop's unrent list const price = this.priceMap.get(key) this.rentedHeap.push([shop, movie, price]) }; /** * @param {number} shop * @param {number} movie * @return {void} */ MovieRentingSystem.prototype.drop = function (shop, movie) { const key = getKey(shop, movie) this.unRentedMovie.add(key) if (!this.movieHeap.has(movie)) { this.movieHeap.set(movie, new MyHeap(([sA, pA], [sB, pB]) => { return pA - pB || sA - sB })) } const price = this.priceMap.get(key) this.movieHeap.get(movie).push([shop, price]) // we will adjust the rentedHeap later }; /** * @return {number[][]} */ MovieRentingSystem.prototype.report = function () { const res = [] const retain = [] // prevent duplicate data const seen = new Set() while (!this.rentedHeap.isEmpty() && res.length this.rentedHeap.push(item)) return res }; const getKey = (shop, movie) => { return `${shop}#${movie}` } class MyHeap { constructor(compare) { this.heap = [] this.compare = compare } peek() { return this.heap[0] } isEmpty() { return this.heap.length === 0 } push(item) { this.heap.push(item) this.heapifyUp(this.heap.length - 1) } pop() { if (this.heap.length > 1 if (parent >= 0 && this.compare(this.heap[index], this.heap[parent]) Javascript（排序数组） /** * @param {number} n * @param {number[][]} entries */ var MovieRentingSystem = function (_n, entries) { this.maxNumSearchResults = 5; let sorted = [...entries] .sort(([shop1, _1, price1], [shop2, _2, price2]) => { let priceDiff = price1 - price2; return priceDiff? priceDiff: shop1 - shop2; }); //{ movie: [ [shop1, priceLowest] ... [shopN, priceHighest] ] } this.movies = sorted .reduce((movies, [shop, movie]) => { let shops = movies[movie]; if(shops == undefined) shops = movies[movie] = []; shops.push(shop); return movies; }, {}); /* { shop: { movie: { price } } } */ this.shops = sorted .reduce((shops, [shop, movie, price]) => { let data = shops[shop]; if(data == undefined) data = shops[shop] = {}; data[movie] = {price}; return shops; }, {}); //i = [shop, movie] this.rented = []; }; /** * @param {number} movie * @return {number[]} */ MovieRentingSystem.prototype.search = function (movie) { let results = [], shops = this.movies[movie]; if (shops) { for (let i = 0, l = shops.length; results.length { let priceDiff = this.shops[shop1][movie1].price - this.shops[shop2][movie2].price; if(!priceDiff) return shop1 == shop2? movie1 - movie2 : shop1 - shop2; return priceDiff; }) .slice(0, this.maxNumSearchResults); }; /** * Your MovieRentingSystem object will be instantiated and called as such: * var obj = new MovieRentingSystem(n, entries) * var param_1 = obj.search(movie) * obj.rent(shop,movie) * obj.drop(shop,movie) * var param_4 = obj.report() */ "},"hard/2197.html":{"url":"hard/2197.html","title":"2197. Replace Non-Coprime Numbers in Array(hard)","keywords":"","body":"2197. Replace Non-Coprime Numbers in Array Leetcode link 题目简介 这是一道 hard，题目会给一个数字组成的数组 nums 要求我们按照以下步骤求出新的数组： 寻找连续两个相邻的互质数（也就是最大公因数 GCD 为 1） 将这两个相邻的互质数用两数的最小公倍数 LCM 替代 回到第一步继续寻找直到没有互质数则直接结束返回数组 解题思路 这题的难点其实有三个： 最大公因数 GCD 怎么求 最小公倍数 LCM 怎么求 如何处理好数组替换的操作 第一个难点，GCD 可以通过欧几里得算法来求解：gcd(a, b) = gcd(a, a mod b)，复杂度为 O(logM), M = min(a, b) 第二个难点，LCM 可以通过以下等式来获得：lcm(a, b) * gcd(a, b) = a * b => lcm(a, b) = a * b / gcd(a, b) 最后一个难点，我们只要维护一个栈，在遍历 nums 的时候只需要取栈顶元素与其对比后 push 对应的数字进栈即可 最后算法复杂度为 O(nlogM) Javascript /** * @param {number[]} nums * @return {number[]} */ var replaceNonCoprimes = function (nums) { const stack = [] // gcd(a, b) = gcd(a, a mod b) const gcd = (a, b) => { while (b !== 0) { let temp = b b = a % b a = temp } return a } for(let num of nums) { while(stack.length > 0) { const top = stack[stack.length-1] const g = gcd(top, num) // if coprime if(g === 1) { break } stack.pop(top) // gcd(a, b) * lcm(a, b) = a * b => lcm(a, b) = a * b / gcd(a, b) num = num * top / g } stack.push(num) } return stack }; "},"hard/2751.html":{"url":"hard/2751.html","title":"2751. Robot Collisions(hard)","keywords":"","body":"2751. Robot Collisions Leetcode link 解题思路 这是一道久违的 hard！ 题目会给我们若干机器人，每个机器人都有各自的三个属性：位置 position、生命值 health、行走方向 direction 因为机器人有不同的行走方向，所以有些机器人可能会发生碰撞，发生碰撞后有三个结果： 往右走的机器人生命值高于往左走的机器人：往右走的机器人生命值 -1；往左走的机器人生命值归 0 往右走的机器人生命值低于往左走的机器人：往右走的机器人生命值归 0；往左走的机器人生命值 -1 两个机器人生命值相同：同归于尽，两个机器人生命值都归 0 题目要我们求最后的均衡状态（不会在发生碰撞了）下，还活着的机器人的生命值（需要按照一开始的顺序） 题目在我看来有两个难点： 要怎么去模拟碰撞情况 要怎么保证记住一开始机器人的位置 我们先关注第一个难点，要模拟碰撞，我们需要以下几步： 我们需要先把机器人按照位置顺序排序出来 我们从左往右遍历位置，会有两种情况： 遇到了向右走的机器人，这个时候先保存起来（由于碰撞本质上是一种按照先进后出的消耗，所以使用栈来保存） 遇到了向左走的机器人，此时取出栈顶机器人去碰撞（因为栈顶一定是最靠近的向右走机器人） 发生碰撞无非就是上述的三个结果，我们分别进行判断 等到遍历结束，我们把最后生命值大于 0 的机器人收集起来返回 这个步骤中，最难的一步是，我们要怎么保证前期按照位置排序后，后面收集的生命值的顺序呢？ 第一步：我们可以引入一个辅助数组 indices，它保存着原来机器人顺序的下标 第二步：我们把 indices 按照 positions 同下标的值从小到大排序，这样我们遍历 indices 就相当于遍历了排序后的 positions, healths, directions Javascript /** * @param {number[]} positions * @param {number[]} healths * @param {string} directions * @return {number[]} */ var survivedRobotsHealths = function(positions, healths, directions) { // 辅助数组，用于维持 positions, healths, directions 之间的联系 const indices = Array.from({length: positions.length}, (_, i) => i); // 把辅助函数按照位置从左到右排序 indices.sort((a, b) => positions[a] - positions[b]); // 我们把往右走的 robot 用一个栈维护起来 const stack = []; const result = []; for(const i of indices) { // 从位置的左到右遍历，如果遇到往右走的 robot 先存起来 if(directions[i] === 'R') { stack.push(i); continue; } // 遇到了往左走的 robot 需要处理一下 while(healths[i] > 0 && stack.length > 0) { const top = stack.pop(); // 处理发生碰撞的情况 if(healths[top] > healths[i]) { // 情况1: 栈顶往右走的 robot 生命值大于当前往左走的 robot healths[top]--; healths[i] = 0; if(healths[top] > 0) { stack.push(top); } } else if(healths[top] 0) { result.push(health); } } return result; }; "},"hard/2872.html":{"url":"hard/2872.html","title":"2872. Maximum Number of K-Divisible Components(hard)","keywords":"","body":"2872. Maximum Number of K-Divisible Components Leetcode link 题目简介 本题是个 hard，而且题目特别长，看的人晕头转向的，我这边先简单描述一下题目给的参数都是干嘛的： n：代表题目给的树有几个节点 edges：是一个二维数组，数组的每一项有两个节点，代表这两个节点之间有边 values：是一个数组，每一项代表当前下标对应的节点的值 k：一个 number，作用后面会将 通过前三个参数，我们可以画出一棵树出来，题目要求我们可以任意斩断树节点之间的连接，但是前提是斩断的两边的节点只和，都要能够被 k 整除，并且题目要求我们求出最多能够切成多少个 解题思路 这种要把树分开的题目，一般都需要遍历树，这题主要有两个难点： 如何根据前三个参数把树构建出来 如何根据自己构建的树，通过遍历将其拆分成尽可能多的树枝 首先第一个难点，我们可以通过自己构建一个简单的二维数组来表示一棵树，这个二维数组的长度是 n，而二维数组内部储存的数组则表示与当前数组下标节点有存在边的节点 举个例子：[[1,2], [0], [0]] 表示节点 0 有两条边，分别连接到了节点 1 与节点 2，而节点 1 只与节点 0 相连；同理节点 2 也只与节点 0 相连 0 | \\ 1 2 然后，第二步就是要看要如何遍历这颗树 我们可以从叶子节点开始思考，有两种可能： 如果当前叶子节点能够被 k 整除，那么我们就可以将其与其父节点的连接斩断 如果当前叶子节点不能被 k 整除，那么我们要将它的值往其父节点累加，直到累加的值可以被 k 整除，再将整棵子树与其他树的连接切断 这种往父节点累加的遍历，自然而然就想到了 dfs 于是我们就得到了代码： Javascript /** * @param {number} n * @param {number[][]} edges * @param {number[]} values * @param {number} k * @return {number} */ var maxKDivisibleComponents = function (n, edges, values, k) { let result = 0 // first step: create the tree const tree = Array.from(new Array(n), () => new Array()) edges.forEach(([n1, n2])=>{ tree[n1].push(n2) tree[n2].push(n1) }) // second step: dfs const dfs = (node, parent) => { let sum = values[node] for(const pair of tree[node]) { if(pair === parent) { continue } sum+= dfs(pair, node) } if(sum % k === 0) { result++ } return sum } // Each node can be the root, we use 0 just for convenience dfs(0) return result }; "},"hard/3027.html":{"url":"hard/3027.html","title":"3027. Find the Number of Ways to Place People II(hard)","keywords":"","body":"3027. Find the Number of Ways to Place People II Leetcode link 题目简介 这一题跟 3025 唯一的差别就是把参数的范围提高了，所以对算法复杂度的要求理论上会更高，但我们之前的算法复杂度已经是 O(n^2) 了，所以直接套用就好 解题思路 直接套用 3025 的代码 Javascript /** * @param {number[][]} points * @return {number} */ var numberOfPairs = function(points) { points.sort((a, b) => { if (a[0] === b[0]) { return b[1] - a[1] } return a[0] - b[0] }) let count = 0 const n = points.length for (let i = 0; i lowerYLimit) { count++ lowerYLimit = curY if(curY === upperYLimit) { break } } } } return count }; "},"hard/3347.html":{"url":"hard/3347.html","title":"3347. Maximum Frequency of an Element After Performing Operations II(hard)","keywords":"","body":"3347. Maximum Frequency of an Element After Performing Operations II Leetcode link 题目简介 这题跟 3346 的唯一区别就是 nums[i] 跟 k 的范围更大了，所以对算法复杂度的要求会更高，但是解法直接用 3346 的就行 解题思路 见 3346 Javascript /** * @param {number[]} nums * @param {number} k * @param {number} numOperations * @return {number} */ var maxFrequency = function (nums, k, numOperations) { nums.sort((a, b) => a - b) const len = nums.length let res = 0 // if nums[i] is target let left = 0 let right = 0 // count the current element let count = 0 for (let i = 0; i = nums[i] - k while(nums[left] nums[i] + k while(right = numOperations) { return res } // now, we can handle the situation that nums[i] is not a target left = 0 const BOUNDARY = k*2 for(right = 0;right BOUNDARY) { left++ } const size = right - left + 1 res = Math.max(res, Math.min(numOperations, size)) } return res }; "},"hard/3495.html":{"url":"hard/3495.html","title":"3495. Minimum Operations to Make Array Elements Zero(hard)","keywords":"","body":"3495. Minimum Operations to Make Array Elements Zero Leetcode link 题目简介 这是一道 hard，题目给我们一个二维数组，数组中包含多个 [left, right] 形式的数组，代表从 left 到 right 的正整数 题目要求我们每次操作都从 l 到 r 中任意选择两个数字，并将其处以 4 后向下取整，直到数组中所有数字都变为 0 最后返回所有数组需要的操作次数 解题思路 这道题有两种解法，但是都服务于一个相同的思路，下面我们先聊聊解题思路 首先我们先来分析一下，任意一个数字被 4 整除之后向下取整需要几步： 对于 1, 2, 3 来说，只需要一步，因为他们小于 $4^1$ 对于 4, 5, ..., 15 来说，需要两步，因为他们小于 $4^2$ 对于 16, 17, ..., 63 来说，需要三步，因为他们小于 $4^3$ 以此类推 知道了这个规律之后，我们不难想到可以针对 l 到 r 的正整数序列进行分堆，然后针对每一堆的数量乘以他们需要的步骤之后相加，就可以求得任意一个 [left, right] 组合中每一个数字变为 0 需要的步骤了，最后再将其除以 2 之后向上取整，就能得到题目所求的操作次数了 举个例子：有一个数组是 [3, 17] 我们可以将其分为三组： 3 自己一组，因为它只需要一次除法 4~15 一组，因为他们需要两次除法 16, 17 一组，因为需要三次除法 我们可以得到需要 31 (1*1 + (15-4+1) * 2 + 2 * 3) 次除法才能够将所有数字变为 0，那么题目需要的操作次数就是 Ceil(31/2) = 16 了解了这个思路之后，接下来有两种解决方案： 用数字来寻找相同组 遍历所有组，并找到各组内的数字 用数字寻找组 用数字寻找范围的精髓在于，通过题目给出的数字，来判断他们分别属于哪些范围，然后再进行求和计算 为了算法的通用性，我们可以设计一个能够计算 [1, n] 这个范围的算法，这样一来如果题目要求是 [left, right]，我们可以用 [1, right] 需要的除法计算减去 [1, left-1]需要的除法次数，然后再除以 2 向上取整就可以计算出题目所需的操作数量了 Javascript /** * @param {number[][]} queries * @return {number} */ var minOperations = function (queries) { let result = 0n queries.forEach(([l, r]) => { const leftOpCount = totalNeedOfOpsToNum(l - 1) const rightOpCount = totalNeedOfOpsToNum(r) result += (rightOpCount - leftOpCount + 1n) / 2n }) return Number(result) }; // 将数字分组，最后加总所需除法次数 const totalNeedOfOpsToNum = num => { let res = 0n; let needOfOps = 1; let base = 1; while (base 用组寻找数字 换一个角度来思考题目，如果我们可以知道总共有多少组，我们是不是就可以通过遍历所有的组来寻找各自组别有的数字了呢？ 我们可以看到题目对 left 跟 right 的 $1 \\le l \\lt r \\le 10^9$ 题目要求的除数是 4，所以我们可以知道这个组最多不超过 $log_{4}10^9 \\lt 15$ 于是我们就可以针对每一组 [l, r]，进行一次循环，从而找出所需要进行除法的次数 Javascript /** * @param {number[][]} queries * @return {number} */ var minOperations = function (queries) { let res = 0; queries.forEach(([left, right]) => { let needOfOps = 0 for (let i = 1; i "}}