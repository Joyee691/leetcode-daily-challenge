{"./":{"url":"./","title":"Introduction","keywords":"","body":"LeetCode Daily Challenge 一个记录 leetcode 每日一题的仓库 汇总（按题目序号排列） 1. Two Sum(easy) 2. Add Two Numbers(medium) 3. Longest Substring Without Repeating Characters(medium) 5. Longest Palindromic Substring(medium) 6. Zigzag Conversion(medium) 7. Reverse Integer(medium) 8. String to Integer (atoi)(medium) 9. Palindrome Number(easy) 11. Container With Most Water(medium) 12. Integer to Roman(medium) 14. Longest Common Prefix(easy) 15. 3Sum(medium) 16. 3Sum Closest(medium) 17. Letter Combinations of a Phone Number(medium) 18. 4Sum(medium) 19. Remove Nth Node From End of List(medium) 20. Valid Parentheses(easy) 29. Divide Two Integers(medium) 31. Next Permutation(medium) 32. Longest Valid Parentheses(hard) 46. Permutations(medium) 47. Permutations II(medium) 51. N-Queens(hard) 52. N-Queens II(hard) 59. Spiral Matrix II(medium) 61. Rotate List(medium) 63. Unique Paths II(medium) 74. Search a 2D Matrix(medium) 81. Search in Rotated Sorted Array II(medium) 88. Merge Sorted Array(easy) 99. Recover Binary Search Tree(medium) 117. Populating Next Right Pointers in Each Node II(medium) 119. Pascal's Triangle II(easy) 120. Triangle(medium) 128. Longest Consecutive Sequence(medium) 135. Candy(hard) 138. Copy List with Random Pointer(medium) 152. Maximum Product Subarray(medium) 160. Intersection of Two Linked Lists(easy) 165. Compare Version Numbers(medium) 166. Fraction to Recurring Decimal(medium) 167. Two Sum II - Input Array Is Sorted(medium) 173. Binary Search Tree Iterator(medium) 191. Number of 1 Bits(easy) 215. Kth Largest Element in an Array(medium) 216. Combination Sum III(medium) 225. Implement Stack using Queues(easy) 230. Kth Smallest Element in a BST(medium) 268. Missing Number(easy) 284. Peeking Iterator(medium) 287. Find the Duplicate Number(medium) 289. Game of Life(medium) 304. Range Sum Query 2D - Immutable(medium) 318. Maximum Product of Word Lengths(medium) 322. Coin Change(medium) 329. Longest Increasing Path in a Matrix(hard) 330. Patching Array(hard) 341. Flatten Nested List Iterator(medium) 344. Reverse String(easy) 347. Top K Frequent Elements(medium) 354. Russian Doll Envelopes(hard) 376. Wiggle Subsequence(medium) 399. Evaluate Division(medium) 406. Queue Reconstruction by Height(medium) 407. Trapping Rain Water II(hard) 410. Split Array Largest Sum(hard) 417. Pacific Atlantic Water Flow(medium) 456. 132 Pattern(medium) 462. Minimum Moves to Equal Array Elements II(medium) 474. Ones and Zeroes(medium) 535. Encode and Decode TinyURL(medium) 538. Convert BST to Greater Tree(medium) 581. Shortest Unsorted Continuous Subarray(medium) 583. Delete Operation for Two Strings(medium) 611. Valid Triangle Number(medium) 633. Sum of Square Numbers(medium) 647. Palindromic Substrings(medium) 665. Non-decreasing Array(medium) 669. Trim a Binary Search Tree(medium) 680. Valid Palindrome II(easy) 682. Baseball Game(easy) 700. Search in a Binary Search Tree(easy) 703. Kth Largest Element in a Stream(easy) 704. Binary Search(easy) 705. Design HashSet(easy) 706. Design HashMap(easy) 726. Number of Atoms(hard) 769. Max Chunks To Make Sorted(medium) 778. Swim in Rising Water(hard) 785. Is Graph Bipartite?(medium) 812. Largest Triangle Area(easy) 820. Short Encoding of Words(medium) 826. Most Profit Assigning Work(medium) 844. Backspace String Compare(easy) 867. Transpose Matrix(easy) 897. Increasing Order Search Tree(easy) 905. Sort Array By Parity(easy) 912. Sort an Array(medium) 923. 3Sum With Multiplicity(medium) 966. Vowel Spellchecker(medium) 968. Binary Tree Cameras(hard) 976. Largest Perimeter Triangle(easy) 1029. Two City Scheduling(medium) 1039. Minimum Score Triangulation of Polygon(medium) 1046. Last Stone Weight(easy) 1048. Longest String Chain(medium) 1052. Grumpy Bookstore Owner(medium) 1091. Shortest Path in Binary Matrix(medium) 1110. Delete Nodes And Return Forest(medium) 1190. Reverse Substrings Between Each Pair of Parentheses(medium) 1192. Critical Connections in a Network(hard) 1202. Smallest String With Swaps(medium) 1209. Remove All Adjacent Duplicates in String II(medium) 1260. Shift 2D Grid(easy) 1268. Search Suggestions System(medium) 1302. Deepest Leaves Sum(medium) 1304. Find N Unique Integers Sum up to Zero(easy) 1317. Convert Integer to the Sum of Two No-Zero Integers(easy) 1332. Remove Palindromic Subsequences(easy) 1337. The K Weakest Rows in a Matrix(easy) 1342. Number of Steps to Reduce a Number to Zero(easy) 1352. Product of the Last K Numbers(medium) 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree(medium) 1380. Lucky Numbers in a Matrix(easy) 1396. Design Underground System(medium) 1423. Maximum Points You Can Obtain from Cards(medium) 1461. Check If a String Contains All Binary Codes of Size K(medium) 1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts(medium) 1475. Final Prices With a Special Discount in a Shop(easy) 1482. Minimum Number of Days to Make m Bouquets(medium) 1488. Avoid Flood in The City(medium) 1518. Water Bottles(easy) 1526. Minimum Number of Increments on Subarrays to Form a Target Array(hard) 1530. Number of Good Leaf Nodes Pairs(medium) 1552. Magnetic Force Between Two Balls(medium) 1584. Min Cost to Connect All Points(medium) 1598. Crawler Log Folder(easy) 1625. Lexicographically Smallest String After Applying Operations(medium) 1631. Path With Minimum Effort(medium) 1636. Sort Array by Increasing Frequency(easy) 1641. Count Sorted Vowel Strings(medium) 1642. Furthest Building You Can Reach(medium) 1653. Minimum Deletions to Make String Balanced(medium) 1658. Minimum Operations to Reduce X to Zero(medium) 1679. Max Number of K-Sum Pairs(medium) 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers(medium) 1695. Maximum Erasure Value(medium) 1710. Maximum Units on a Truck(easy) 1716. Calculate Money in Leetcode Bank(easy) 1717. Maximum Score From Removing Substrings(medium) 1721. Swapping Nodes in a Linked List(medium) 1733. Minimum Number of People to Teach(medium) 1912. Design Movie Rental System(hard) 1935. Maximum Number of Words You Can Type(easy) 2011. Final Value of Variable After Performing Operations(easy) 2043. Simple Bank System(medium) 2048. Next Greater Numerically Balanced Number(medium) 2096. Step-By-Step Directions From a Binary Tree Node to Another(medium) 2125. Number of Laser Beams in a Bank(medium) 2191. Sort the Jumbled Numbers(medium) 2196. Create Binary Tree From Descriptions(medium) 2197. Replace Non-Coprime Numbers in Array(hard) 2221. Find Triangular Sum of an Array(medium) 2273. Find Resultant Array After Removing Anagrams(easy) 2300. Successful Pairs of Spells and Potions(medium) 2327. Number of People Aware of a Secret(medium) 2353. Design a Food Rating System(medium) 2415. Reverse Odd Levels of Binary Tree(medium) 2418. Sort the People(easy) 2471. Minimum Number of Operations to Sort a Binary Tree by Level(medium) 2598. Smallest Missing Non-negative Integer After Operations(medium) 2749. Minimum Operations to Make the Integer Zero(medium) 2751. Robot Collisions(hard) 2785. Sort Vowels in a String(medium) 2872. Maximum Number of K-Divisible Components(hard) 3005. Count Elements With Maximum Frequency(easy) 3025. Find the Number of Ways to Place People I(medium) 3027. Find the Number of Ways to Place People II(hard) 3100. Water Bottles II(medium) 3147. Taking Maximum Energy From the Mystic Dungeon(medium) 3186. Maximum Total Damage With Spell Casting(medium) 3227. Vowels Game in a String(medium) 3264. Final Array State After K Multiplication Operations I(easy) 3289. The Two Sneaky Numbers of Digitville(easy) 3346. Maximum Frequency of an Element After Performing Operations I(medium) 3347. Maximum Frequency of an Element After Performing Operations II(hard) 3349. Adjacent Increasing Subarrays Detection I(easy) 3350. Adjacent Increasing Subarrays Detection II(medium) 3354. Make Array Elements Equal to Zero(easy) 3370. Smallest Number With All Set Bits(easy) 3397. Maximum Number of Distinct Elements After Operations(medium) 3408. Design Task Manager(medium) 3461. Check If Digits Are Equal in String After Operations I(easy) 3484. Design Spreadsheet(medium) 3495. Minimum Operations to Make Array Elements Zero(hard) 3508. Implement Router(medium) 3516. Find Closest Person(easy) 3541. Find Most Frequent Vowel and Consonant(easy) "},"easy/":{"url":"easy/","title":"Easy","keywords":"","body":"Easy "},"easy/1.html":{"url":"easy/1.html","title":"1. Two Sum(easy)","keywords":"","body":"1. Two Sum Leetcode link 解题思路——O(n^2) 这是一道简单题，一个最直接的解题思路就是用双循环：外侧循环输入数组，内侧循环寻找target - nums[i]的差，如果找到就把两个下标装到一个数组中返回出去。 注：在 JS 中的 indexOf 本质上也是用了遍历O(n) C++ class Solution { public: vector twoSum(vector& nums, int target) { vector result; for (int i = 0; i Javascript var twoSum = function(nums, target) { for(let i=0;i 解题思路——O(n) 想当然尔，一个简单题用了 O(n^2)的算法复杂度，不只是题目最下面的 Follow-up 不满意，面试官也肯定不满意&#x1F436; 所以就有了空间换时间的思路：用一个 map 来保存之前出现过的值以及对应的下标，之后直接用 O(1) 在 map 里找就完事了。 注：JS用了另一种思路，保存了当前下标及当前的值与target的差，但是本质是一样的。 C++ class Solution { public: vector twoSum(vector& nums, int target) { unordered_map map; for (int i = 0; i Javascript var twoSum = function(nums, target) { let cache = {}; for(let i=0;i "},"easy/9.html":{"url":"easy/9.html","title":"9. Palindrome Number(easy)","keywords":"","body":"9. Palindrome Number Leetcode link 解题思路 本题要求我们检查出一个数字是否是回文的，因为比较数字的首尾比较麻烦，所以我们可以先把它转换成字符串的形式，转换成字符串口有两种思路： 夹紧法：写一个 for 循环并且用两个指针分别从首尾取出数字比较 反转法：创建另一个与题目给的数字相反的字符串，然后比较两个字符串 Javascript 1. 夹紧法 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { const str = x.toString(); const len = str.length; for(let i=0, j=len-1;i 2. 反转法 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { const str = x.toString(); const reversedStr = str.split(\"\").reverse().join(\"\"); return reversedStr === str; }; "},"easy/14.html":{"url":"easy/14.html","title":"14. Longest Common Prefix(easy)","keywords":"","body":"14. Longest Common Prefix Leetcode link 题目简介 /** * @param {string[]} strs * @return {string} */ 本题给我们一个字符串数组 strs，要求我们找出 strs 中所有字符串的共同前缀 解题思路 找字符串前缀我们可以用 String.startsWith 方法判断一个字符串是否为另外一个字符串前缀 Javascript /** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function(strs) { let prefix = strs[0] for(let i=1;i "},"easy/20.html":{"url":"easy/20.html","title":"20. Valid Parentheses(easy)","keywords":"","body":"20. Valid Parentheses Leetcode link 解题思路 看到这种有对称性并且对输入输出顺序有的题目，第一个想到的就是先进先出的栈了。 我们可以设计这样一个栈：当遇到左括号时，就把他们压入栈，而当遇到右括号时，只需确定两件事： 当前栈是否为空？ 如果是直接返回 false 当前栈顶是否是相对应的括号？ 如果不是直接返回 false 如果上述两个校验都通过了，那么只需要把当前的栈顶弹出去继续对比就好了。 最后，当输入的 字符串比对完了之后，我们需要检查当前的栈是否为空，如果为空表示所有左右括号是对称的，可以返回 true 了。如果不是则表示左括号多于右括号，返回 false C++ class Solution { public: bool isValid(string s) { stack stack; for (char c : s) { switch (c) { case '(': case '{': case '[': stack.push(c); break; case ')': if (stack.empty() || stack.top() != '(') return false; stack.pop(); break; case '}': if (stack.empty() || stack.top() != '{') return false; stack.pop(); break; case ']': if (stack.empty() || stack.top() != '[') return false; stack.pop(); break; } } return stack.empty(); } }; Javascript var isValid = function(s) { const stack = []; for(let c of s) { if(c === '(' || c === '{' || c === '['){ stack.push(c); } else { if(stack.length === 0) return false if(c === ')' && stack[stack.length-1] !== '(') return false; if(c === '}' && stack[stack.length-1] !== '{') return false; if(c === ']' && stack[stack.length-1] !== '[') return false; stack.pop() } } return stack.length === 0; }; "},"easy/88.html":{"url":"easy/88.html","title":"88. Merge Sorted Array(easy)","keywords":"","body":"88. Merge Sorted Array Leetcode link 解题思路 题目要求我们将两个升序的数组按照升序合并到第一个数组中 由于第一个数组的多余空间是在后面，所以我们考虑一种由后往前遍历的方法 首先我们需要定义一个变量 k，表示数组 1 的真实长度的最后一位 然后我们从数组 1 与数组 2 的有效位 m-1 与 n-1 由后往前遍历 如果数组 1 的数比数组 2 的大，则将其放到 k 的位置……以此类推 最后我们只需要再检查一次数组 2 有没有漏网之鱼就好，因为数组 1 剩下的部分恰好在排列好应该在的位置 C++ class Solution { public: void merge(vector& nums1, int m, vector& nums2, int n) { int k = m+n-1; m--; n--; while(m >= 0 && n >= 0) { if(nums1[m]>=nums2[n]) { nums1[k--] = nums1[m--]; } else { nums1[k--] = nums2[n--]; } } while(n>=0) { nums1[k--] = nums2[n--]; } } }; Javascript /** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */ var merge = function(nums1, m, nums2, n) { let k = m+n-1; m--; n--; while(m>=0 && n>=0) { if(nums1[m]>=nums2[n]) { nums1[k--] = nums1[m--]; } else { nums1[k--] = nums2[n--]; } } while(n>=0) { nums1[k--] = nums2[n--]; } }; "},"easy/119.html":{"url":"easy/119.html","title":"119. Pascal's Triangle II(easy)","keywords":"","body":"119. Pascal's Triangle II Leetcode link 解题思路 TC: O(n) SC: O(n) 这是一道简单题，只要求我们求得 Pascal's triangle 中的某一行的所有数字 这道题有挑战的点在于题目要求我们只能使用 O(rowIndex) 的空间，也就是说，我们应该直接计算出对应的行，而非把整个三角形都算出来 有了这个思路之后我们还需要三个信息： Pascal's triangle 的第 n 行第 r 个值可以用 $\\tbinom{n}{r}$ 来表示（其中 n 跟 r 都是 0-index 的） 承上，$\\tbinom{n}{r + 1} = \\tbinom{n}{r} \\times \\frac{n-r}{r+1}$ （具体推导过程省略，可以用组合数公式自己算一下就有了） 每一行的第一个数都是 1 综合上述三个信息，我们就可以直接计算出任意一行的 Pascal's triangle 了，具体代码如下 Javascript /** * @param {number} rowIndex * @return {number[]} */ var getRow = function(rowIndex) { const res = [1]; for(let i=0;i "},"easy/160.html":{"url":"easy/160.html","title":"160. Intersection of Two Linked Lists(easy)","keywords":"","body":"160. Intersection of Two Linked Lists Leetcode link 解题思路——拼接 题目要求我们找出两个链表 A、B 第一个相交的节点 第一个思路就是拼接，我们需要做三个操作： 把链表 A 的尾巴拼接上链表 B 得到链表 C 把链表 B 的尾巴拼接上链表 A 得到链表 D 从头到尾同时遍历链表 C 和 D，找到第一个相同的元素就是链表 A、B 第一个相交的节点 C++ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *p=headA; ListNode *q=headB; // flag 表示还没经过拼接，在遍历到链表尾的时候需要做一下拼接 bool flagA = true; bool flagB = true; while(p != q) { if(p == nullptr && flagA) { // 只需要拼接一次，不然如果没有交点的话会一直循环下去 flagA = false; p = headB; } else { p = p->next; } if(q == nullptr && flagB) { flagB = false; q = headA; } else { q = q->next; } } // 找到第一个相同的就是所求节点，如果没有就是 nullptr return p; } }; 解题思路——计算长度 这个思路也挺有意思的 我们知道两个有相交节点的相交部分长度是一样的，所以我们只需要计算两个链表的长度差 diff 然后将较长的那个链表先遍历 diff 个元素，这样一来两个链表剩下的长度就想等了 最后我们只需要同时遍历两个链表的剩余部分比较是否相同就好 C++ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *p=headA; ListNode *q=headB; int lenA = 0; int lenB = 0; // 计算两个链表长度 while(p != nullptr) { lenA++; p = p->next; } while(q != nullptr) { lenB++; q = q->next; } int diff; // 把 p 指向比较长的链表 if(lenA > lenB) { diff = lenA - lenB; p = headA; q = headB; } else { diff = lenB - lenA; p = headB; q = headA; } // 将比较长的那个链表先遍历一点 while(diff-- > 0) { p = p->next; } // 这个时候两个链表剩余部分长度相同，直接一起遍历就好 while(p != q) { p = p->next; q = q->next; } return p; } }; "},"easy/191.html":{"url":"easy/191.html","title":"191. Number of 1 Bits(easy)","keywords":"","body":"191. Number of 1 Bits Leetcode link 解题思路 本题要求我们计算一个 32 位 unsigned int 中 1 的个数 主要考察点事位运算，我们可以用 n &= n - 1 来减少最后一位的 1 只需要不断的减少直到 n 最后为 0，减少的次数就是 1 的次数 C++ class Solution { public: int hammingWeight(uint32_t n) { int res = 0; while(n != 0) { n &= n - 1; res++; } return res; } }; "},"easy/225.html":{"url":"easy/225.html","title":"225. Implement Stack using Queues(easy)","keywords":"","body":"225. Implement Stack using Queues Leetcode link 这个题目用 JS 做就没意义了，我只写了 C++ 的三个版本 解题思路——两个 queue，对 push 做手脚 push 操作时间复杂度：O(n) 维护两个队列，在 push 元素的时候首先把元素 push 到辅助队列 p2，然后把 p1 的元素逐个丢到 p2 ，最后把两个队列交换 C++ class MyStack { private: queue q1; queue q2; public: MyStack() {} void push(int x) { q2.push(x); while (q1.size() > 0) { q2.push(q1.front()); q1.pop(); } swap(q1, q2); } int pop() { int res = q1.front(); q1.pop(); return res; } int top() { return q1.front(); } bool empty() { return q1.size() == 0; } }; 解题思路——两个 queue，对 pop 做手脚 pop 操作时间复杂度：O(n) 在做 pop 操作的时候，首先把队列 p1 除了最后一个元素之外都往 p2 丢，丢到最后一个元素的时候记得保存一下，然后先交换两个队列，最后再返回最后一个元素。 C++ class MyStack { private: queue q1; queue q2; public: MyStack() {} void push(int x) { q1.push(x); } int pop() { // 除了最后一个元素之外其他都往 q2 丢 while (q1.size() > 1) { q2.push(q1.front()); q1.pop(); } // 把最后一个元素保存一下 int res = q1.front(); q1.pop(); // 把 q2 的元素丢回来 while (q2.size() > 0) { q1.push(q2.front()); q2.pop(); } return res; } int top() { return q1.back(); } bool empty() { return q1.size() == 0; } }; 解题思路—— 一个 queue push 操作时间复杂度：O(n) 只有一个队列的时候情况有些不同了，考虑在 push 元素的时候，需要多出以下步骤 先正常往队列尾部 push 元素 把队列尾部之前的元素都从头部弹出之后插入尾部 这样以来，队列之后 pop 操作弹出的就是最后加进来的元素了 C++ class MyStack { private: queue q; public: MyStack() {} void push(int x) { q.push(x); int size = q.size(); // 把最后一个元素以外的元素全部往队列尾部丢 while (size > 1) { q.push(q.front()); q.pop(); size--; } } int pop() { int res = q.front(); q.pop(); return res; } int top() { return q.front(); } bool empty() { return q.size() == 0; } }; "},"easy/268.html":{"url":"easy/268.html","title":"268. Missing Number(easy)","keywords":"","body":"268. Missing Number Leetcode link 解题思路——加总 本题要我们求一个值由 0 ~ n 组成的长度为 n 的数组里缺失的数字 总共有两种方法来求解，第一种思路是： 用 0 ~ n 的加总减去数组元素的加总 C++ class Solution { public: int missingNumber(vector& nums) { int res = nums.size(); for(int i=0;i Javascript /** * @param {number[]} nums * @return {number} */ var missingNumber = function(nums) { let len = nums.length; let sum = nums.reduce((prev, cur)=>prev + cur, 0); return len * (len + 1) / 2 - sum; }; 解题思路——亦或 另一种思路则是用到了亦或的操作： 我们把所有数组元素进行亦或 然后把 0 ~ n 的数字也进行亦或 最后把上述两个结果亦或就是答案了 C++ class Solution { public: int missingNumber(vector& nums) { int res = nums.size(); int i = 0; for(int num : nums) { res ^= num ^ i++; } return res; } }; JavaScript /** * @param {number[]} nums * @return {number} */ var missingNumber = function(nums) { let res = nums.length, cur = 0; for(let num of nums) { res ^= num ^ cur; cur++; } return res; }; "},"easy/344.html":{"url":"easy/344.html","title":"344. Reverse String(easy)","keywords":"","body":"344. Reverse String Leetcode link 解题思路 TC: O(n) SC: O(1) 本题要求逆转一个字符数组，一个简单的思路就是用两个指针分别从数组头与尾前进，并依次交换直到指针相遇。 C++ // for 版本 class Solution { public: void reverseString(vector& s) { int len = s.size(); for (int i = 0; i & s) { int left = 0, right = s.size() - 1; while (left Javascript var reverseString = function(s) { let left = 0, right = s.length - 1; while (left "},"easy/680.html":{"url":"easy/680.html","title":"680. Valid Palindrome II(easy)","keywords":"","body":"680. Valid Palindrome II Leetcode link 解题思路 本题要求我们检测回文字符串，并且可以最多丢弃任一字符。 检测回文的其中一个方法就是用双指针往中间遍历，由于我们可以丢弃任一字符，我们需要考虑遇到不匹配的情况下要删除哪一边的字符。 解决方法是两边都试一下，只要有一边成功了，就表示这个字符是符合要求的。 C++ class Solution { public: bool isValid(string s, int left, int right) { while (left Javascript var validPalindrome = function(s) { let left = 0, right = s.length - 1; while (left "},"easy/682.html":{"url":"easy/682.html","title":"682. Baseball Game(easy)","keywords":"","body":"682. Baseball Game Leetcode link 解题思路 这题跟棒球没有半毛钱关系。。。。 本题给了我们一些字符串形式的数字，还有三个不同的运算符，自然而然的就能想到可以用栈这个数据结构先进先出的特性来处理 要注意的点在于变量的类型转换。 C++ class Solution { public: int calPoints(vector& ops) { stack stack; int res = 0; for (string ele : ops) { if (ele == \"C\") { stack.pop(); } else if (ele == \"D\") { // 对字符串用乘法会自动转成数字 stack.push(stack.top() * 2); } else if (ele == \"+\") { int value1 = stack.top(); stack.pop(); int value2 = stack.top(); stack.push(value1); // 加法也是 stack.push(value1 + value2); } else { // 需要显式转换为数字 stack.push(stoi(ele)); } } while (!stack.empty()) { res += stack.top(); stack.pop(); } return res; } }; Javascript /** * @param {string[]} ops * @return {number} */ var calPoints = function(ops) { let res = 0; let stack = []; for(let ele of ops) { switch (ele) { case \"C\": stack.pop(); break; case \"D\": // js 对数字形式的字符串用乘法会类型转换为数字 stack.push(stack[stack.length-1] * 2); break; case \"+\": let value1 = stack[stack.length-1]; let value2 = stack[stack.length-2]; // 必须显式类型转换，不然会字符串拼接 stack.push(Number(value1) + Number(value2)); break; default : // 显式转换 stack.push(Number(ele)); } } for(let num of stack) { res+=num; } return res; }; "},"easy/700.html":{"url":"easy/700.html","title":"700. Search in a Binary Search Tree(easy)","keywords":"","body":"700. Search in a Binary Search Tree Leetcode link 解题思路 这题非常简单，我们用 BST 左小右大的特性，循环查找就可以了。 C++ class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { while (root != nullptr && root->val != val) { root = (val > root->val) ? root->right : root->left; } return root; } }; Javascript var searchBST = function(root, val) { while(root!== null && root.val!== val) { root = root.val > val ? root.left : root.right; } return root; }; "},"easy/703.html":{"url":"easy/703.html","title":"703. Kth Largest Element in a Stream(easy)","keywords":"","body":"703. Kth Largest Element in a Stream Leetcode link 解题思路 本题要求我们给出流的第 k 大数字。 本题的核心思路在于，我们维护一个大小为 k 的排序数组，始终让它保存着前 k 大的数字。 有了数组之后，当流再次来数据的时候，有两种可能： 来的数据比第 k 大的数字小，则直接丢弃，返回原来的第 k 大的数字 来的数据比第 k 大的数字，把原来第 k 大的数字丢弃，之后把新数据在插入数组相应位置保持排序 只要处理好这两种状态这题就结束了 C++ class KthLargest { private: int size = 0; // 用了一个优先队列来封装插入的操作 priority_queue, greater> pq; public: KthLargest(int k, vector& nums) { size = k; for (int num : nums) { add(num); } } int add(int val) { // 始终保持队列只有 k 个数字 if (pq.size() pq.top()) { pq.pop(); pq.push(val); } } return pq.top(); } }; Javascript /** * @param {number} k * @param {number[]} nums */ var KthLargest = function(k, nums) { this.size = k; this.stream = nums.sort((a,b)=>b-a).slice(0,k); }; /** * @param {number} val * @return {number} */ KthLargest.prototype.add = function(val) { if(this.stream.length === 0 || val > this.stream[0]) { this.stream.unshift(val); }else if(val = val && this.stream[i + 1] "},"easy/704.html":{"url":"easy/704.html","title":"704. Binary Search(easy)","keywords":"","body":"704. Binary Search Leetcode link 解题思路 题目要求我们从一个升序数组中找出一个特定的数，这种情况下二分法肯定是不二之选了，所以接下来的问题是怎么构造呢？ 首先我们需要三个点：left, right, mid left 用来确定二分范围的左边界 right 用来确定二分范围的右边界 mid 是本次二分范围的中心，用来确定下一次二分的区域 每次循环我们用 nums[mid] 的值做判断，如果 target 比较大，那么表示它如果存在必定在右边的区域，反之则一定在左边的区域 我们只需要通过调整二分的范围，然后重复上述步骤就可以不断缩小范围了，最后如果 left 超过了 right 则表示不存在这个数，直接返回 -1 就好 C++ class Solution { public: int search(vector& nums, int target) { int left = 0, right = nums.size() - 1; while (left nums[mid]) left = mid + 1; // 如果 target 比当前的数小，那我们可以将范围移到左边区域 else if (target Javascript var search = function(nums, target) { let left = 0, right = nums.length-1; while(left nums[mid]) left = mid + 1; } return -1; }; "},"easy/705.html":{"url":"easy/705.html","title":"705. Design HashSet(easy)","keywords":"","body":"705. Design HashSet Leetcode link 解题思路 本题要求我们实现一个简单的 hashSet 的 add、contains、remove 方法 一个最简单的想法就是用一个 map 去建立所有新增进来的 key 的映射，这样就会非常简单，下面我用 JS 实现了这个思路 另一个想法就是用 N 个 “桶” 来 “分类” 一下要新增的 key，具体而言，我们用 key % N 来做分类。这样可以降低空间使用。下面我用 C++ 实现这种思路。 C++ class MyHashSet { private: // 由于题目说 key 的范围大概在 10^6，所以取个 10^2 就差不多了，当然可以随意调整 const int BUCKET_SIZE = 100; vector bucket[100]; public: MyHashSet() {} void add(int key) { int index = key % BUCKET_SIZE; if (!contains(key)) { bucket[index].push_back(key); } } void remove(int key) { int index = key % BUCKET_SIZE; auto it = find(bucket[index].begin(), bucket[index].end(), key); if (it != bucket[index].end()) { bucket[index].erase(it); } } bool contains(int key) { int index = key % BUCKET_SIZE; if (find(bucket[index].begin(), bucket[index].end(), key) != bucket[index].end()) { return true; } else { return false; } } }; Javascript var MyHashSet = function() { this.set = {}; }; /** * @param {number} key * @return {void} */ MyHashSet.prototype.add = function(key) { this.set[key] = key; }; /** * @param {number} key * @return {void} */ MyHashSet.prototype.remove = function(key) { delete this.set[key]; }; /** * @param {number} key * @return {boolean} */ MyHashSet.prototype.contains = function(key) { return key in this.set }; "},"easy/706.html":{"url":"easy/706.html","title":"706. Design HashMap(easy)","keywords":"","body":"706. Design HashMap Leetcode link 解题思路 本题跟 705 的思路基本相同，区别在于这题的 map 在添加已经存在的 key 的时候需要覆盖原来的值；而 705 的 set 是直接不处理。 在 JS 中，因为已经有天然的 map 了，我就直接用了。 C++ 的话我还是选择用多个桶，来降低空间的使用。 C++ class MyHashMap { private: const int BUCKET_SIZE = 100; vector> bucket[100]; public: MyHashMap() {} void put(int key, int value) { for (auto& [k, v] : bucket[key % BUCKET_SIZE]) { if (key == k) { v = value; return; } } bucket[key % BUCKET_SIZE].push_back({key, value}); } int get(int key) { for (auto& [k, v] : bucket[key % BUCKET_SIZE]) { if (key == k) { return v; } } return -1; } void remove(int key) { int i = 0; auto& target = bucket[key % BUCKET_SIZE]; for (auto& [k, v] : target) { if (key == k) { target.erase(target.begin() + i); } i++; } } }; Javascript var MyHashSet = function() { this.set = {}; }; /** * @param {number} key * @return {void} */ MyHashSet.prototype.add = function(key) { this.set[key] = key; }; /** * @param {number} key * @return {void} */ MyHashSet.prototype.remove = function(key) { delete this.set[key]; }; /** * @param {number} key * @return {boolean} */ MyHashSet.prototype.contains = function(key) { return key in this.set }; "},"easy/812.html":{"url":"easy/812.html","title":"812. Largest Triangle Area(easy)","keywords":"","body":"812. Largest Triangle Area Leetcode link 题目简介 这题是一道纯数学的简单题 题目给我们一个参数 points 代表直角坐标上的若干个点，要求我们求出这些点能够构成的最大三角形面积 解题思路 这道题需要用到一个公式：https://en.wikipedia.org/wiki/Shoelace_formula 简单来说，平面直角坐标系的三角形面积可以通过：$\\frac{1}{2}|(x_1y_2 - y_1x_2) + (x_2y_3 - y_2x_3) + (x_3y_1 - x_1y_3)|$ 来计算 然后我们用三个循环依次遍历所有的点就可以得到最大的面积了 Javascript /** * @param {number[][]} points * @return {number} */ var largestTriangleArea = function (points) { let maxArea = 0 const len = points.length for (let i = 0; i "},"easy/844.html":{"url":"easy/844.html","title":"844. Backspace String Compare(easy)","keywords":"","body":"844. Backspace String Compare Leetcode link 解题思路——栈 这个题目还是比较简单的，用两个栈分别存放两个字符串，只要遇到 # 就把当前栈顶弹出去就好 C++ class Solution { private: string convert(string &S) { string res; for (char c : S) { if (c == '#') { if (!res.empty()) { res.pop_back(); } } else { res += c; } } return res; } public: bool backspaceCompare(string s, string t) { return convert(s) == convert(t); } }; Javascript var backspaceCompare = function(s, t) { return convert(s) === convert(t); }; function convert(S) { let res = []; for (let i = 0;i 解题思路——SC: O(1) 如果不使用栈的话可以用两个变量来 “模拟” 一下 class Solution { public: bool backspaceCompare(string s, string t) { int k = 0, l = 0; for (int i = 0; i "},"easy/867.html":{"url":"easy/867.html","title":"867. Transpose Matrix(easy)","keywords":"","body":"867. Transpose Matrix Leetcode link 解题思路 题目要求一个沿着主轴转置的矩阵 一个简单的思路就是创建一个新的矩阵，但是长跟宽要跟原来的相反 之后遍历旧的矩阵，将行与列的下标呼唤赋值到新的矩阵就好 C++ class Solution { public: vector> transpose(vector>& matrix) { int m = matrix.size(); int n = matrix[0].size(); vector> res(n, vector(m, 0)); for(int i=0;i Javascript /** * @param {number[][]} matrix * @return {number[][]} */ var transpose = function(matrix) { let m = matrix.length; let n = matrix[0].length; let res = new Array(n); for(let i=0;i "},"easy/897.html":{"url":"easy/897.html","title":"897. Increasing Order Search Tree(easy)","keywords":"","body":"897. Increasing Order Search Tree Leetcode link 解题思路 要把一个 BST 转变为单边递增的树，第一个想到的方法就是深度优先遍历的中序遍历，为了提高效率，最好是利用题目给的节点去做原地修改。 C++ class Solution { public: TreeNode* cur; void dfs(TreeNode* node) { if (node == nullptr) { return; } dfs(node->left); node->left = nullptr; cur->right = node; cur = cur->right; dfs(node->right); } TreeNode* increasingBST(TreeNode* root) { TreeNode* res = new TreeNode(); cur = res; dfs(root); return res->right; } }; Javascript var increasingBST = function(root) { let res = new TreeNode(); let cur = res; let dfs = (node)=>{ if(!node) { return; } dfs(node.left); node.left = null; cur.right = node; cur = cur.right; dfs(node.right); } dfs(root); return res.right; }; "},"easy/905.html":{"url":"easy/905.html","title":"905. Sort Array By Parity(easy)","keywords":"","body":"905. Sort Array By Parity Leetcode link 解题思路 简单题，说白了就是把偶数往前丢，然后剩下的奇数往后放就好，直接看代码 C++ class Solution { public: vector sortArrayByParity(vector& nums) { int left = 0, right = nums.size() - 1; while (left Javascript var sortArrayByParity = function(nums) { let left = 0, right = nums.length-1; while(left "},"easy/976.html":{"url":"easy/976.html","title":"976. Largest Perimeter Triangle(easy)","keywords":"","body":"976. Largest Perimeter Triangle Leetcode link 题目简介 这是道简单，题目给我们一个数组 nums，数组元素代表线段的长度，题目要求我们从中找出三条边组成三角形，并且要求返回组成三角形中边长最长的三角形的边长，如果不能组成三角形则返回 0 解题思路 三角形能组成的条件是两边之和要大于第三边 为了减少计算量，我们可以先对数组 nums 进行降序排序 接下来，我们只需要找连续的三个长度是否符合三角形组成条件即可 Javascript /** * @param {number[]} nums * @return {number} */ var largestPerimeter = function (nums) { const sortedNums = nums.toSorted((a, b) => b - a) for (let i = 0; i "},"easy/1046.html":{"url":"easy/1046.html","title":"1046. Last Stone Weight(easy)","keywords":"","body":"1046. Last Stone Weight Leetcode link 解题思路 本题一直要求我们重复取最大的两个石头，所以第一个想到的就是优先队列了。 我们只需要在石头数量大于 1 颗的时候，重复 “取两个石头，相撞，把剩下的放进优先队列” 这几个步骤就好。 最后判断一下如果还有石头就输出石头的重量，如果没有就输出 0。 C++ class Solution { public: int lastStoneWeight(vector& stones) { priority_queue pq(stones.begin(), stones.end()); while (pq.size() > 1) { int y = pq.top(); pq.pop(); int x = pq.top(); pq.pop(); if (x != y) { pq.push(y - x); } } return pq.empty() ? 0 : pq.top(); } }; Javascript /** * @param {number[]} stones * @return {number} */ var lastStoneWeight = function (stones) { let pq = new PriorityQueue(stones); while (pq.size() > 1) { let y = pq.top(); pq.pop(); let x = pq.top(); pq.pop(); if (x !== y) { pq.push(y - x); } } return pq.size() > 0 ? pq.top() : 0; }; // 简单的优先队列类 class PriorityQueue { constructor(arr) { if (Array.isArray(arr) && arr.length > 0) { this.queue = arr.sort((a, b) => b - a); return; } this.queue = []; } top() { return this.queue[0]; } pop() { this.queue.shift(); } push(num) { if (this.queue.length === 0 || num > this.queue[0]) { this.queue.unshift(num); return; } else if (num = num && this.queue[i + 1] "},"easy/1260.html":{"url":"easy/1260.html","title":"1260. Shift 2D Grid(easy)","keywords":"","body":"1260. Shift 2D Grid Leetcode link 解题思路 本题要求我们移动二维数组，有两种方法可以简单实现： 构建一个新的数组，把旧数组的元素位置根据 k 重新计算之后放到新数组中 把数组摊平之后平移，之后再重新构建成二维数组 C++ // 第一种方法 class Solution { public: vector> shiftGrid(vector>& grid, int k) { int col = grid.size(); int row = grid[0].size(); vector> res(col, vector(row, 0)); for (int i = 0; i Javascript /** * @desc 第二种方法 * @param {number[][]} grid * @param {number} k * @return {number[][]} */ var shiftGrid = function(grid, k) { const row = grid[0].length; // 摊平数组 const arr = grid.flat(); // 减少计算量，且保证 splice 可以正常运作 k = k % arr.length; // 把后 k 个元素移到前面 arr.unshift(...arr.splice(arr.length-k, k)); const res = []; while(arr.length) { // 数组升维 res.push(arr.splice(0,row)); } return res; }; "},"easy/1304.html":{"url":"easy/1304.html","title":"1304. Find N Unique Integers Sum up to Zero(easy)","keywords":"","body":"1304. Find N Unique Integers Sum up to Zero Leetcode link 题目简介 这是一道简单，题目给一个正整数参数 n，并要求我们返回一个长度为 n 的数组，使其所有元素之和为 0，并且元素不能重复 解题思路 将所有数字之和置为 0 最简单的方法就是用绝对值相同的一正一负两个数相加 但是我们需要分成两种情况： n 是奇数：这种情况我们需要插入一个 0 n 是偶数：这种情况我们只需要正常插入指定数量的正负数就好 Javascript /** * @param {number} n * @return {number[]} */ var sumZero = function (n) { let i = 1 const res = [] if (n % 2 !== 0) { res.push(0) n-- } while (n > 0) { res.push(i, -i) i++ n -= 2 } return res }; "},"easy/1317.html":{"url":"easy/1317.html","title":"1317. Convert Integer to the Sum of Two No-Zero Integers(easy)","keywords":"","body":"1317. Convert Integer to the Sum of Two No-Zero Integers Leetcode link 题目简介 这是道简单 题目给我们一个正整数 n，要求我们返回两个正整数组成的数组，这两个正整数之和等于 n，并且数组内的两个整数中都不能有 0 解题思路 直接一个循环判断就好 Javascript /** * @param {number} n * @return {number[]} */ var getNoZeroIntegers = function(n) { const isZeroInside = num => num.toString().includes('0') for(let i=1;i "},"easy/1332.html":{"url":"easy/1332.html","title":"1332. Remove Palindromic Subsequences(easy)","keywords":"","body":"1332. Remove Palindromic Subsequences Leetcode link 解题思路 本题要求我们给出删除一个由 a 与 b 构成的字符串的步骤，其中每一步只能删除一个回文子序列 这道题是简单题，所以题目给出了字符串只有 a 跟 b 的限制 由于字符串只有 a 跟 b，而每次只能删除回文子序列（注意不是子串，这里是可以是不连续的） 而相同的字符组成的子序列一定是回文子序列，所以最多只要删除 2 次就能删除所有的字符串 我们可以根据字符串是否为回文判断：如果是，则只需要删除一次；如果不是，则需要删除两次 C++ class Solution { public: int removePalindromeSub(string s) { int len = s.size(); for(int i = 0;i Javascript var removePalindromeSub = function(s) { let len = s.length; for(let i = 0;i "},"easy/1337.html":{"url":"easy/1337.html","title":"1337. The K Weakest Rows in a Matrix(easy)","keywords":"","body":"1337. The K Weakest Rows in a Matrix Leetcode link 解题思路 本题给了我们一个二维数组，要求我们返回前 k 弱的数组下标，对于 “弱” 题目的定义是： 数组中 “1” 的个数越少越弱 如果 “1” 的个数相同，那么下标越小的越弱 明白了题目之后，我们只需要做两件事就可以了： 计算每个数组的 “1” 的个数，然后将他们依据上述规则排序 按照排序结果，输出头 k 个的下标 C++ class Solution { public: // 排序规则 struct cmp { bool operator()(pair& a, pair& b) { if (a.second == b.second) { return a.first > b.first; } else { return a.second > b.second; } } }; vector kWeakestRows(vector>& mat, int k) { priority_queue, vector>, cmp> pq; for (int i = 0; i result; // 看题目要几个就给他几个 for (int i = 0; i Javascript var kWeakestRows = function(mat, k) { const arr = []; for(let i=0;ia+b)]) } // 先按照规则排序，之后取得前 k 个之后把他们的下标组合为一个数组 return arr.sort((a,b)=>a[1] === b[1] ? a[0] - b[0] : a[1] - b[1] ).slice(0,k).map(row=>row[0]) }; "},"easy/1342.html":{"url":"easy/1342.html","title":"1342. Number of Steps to Reduce a Number to Zero(easy)","keywords":"","body":"1342. Number of Steps to Reduce a Number to Zero Leetcode link 解题思路 题目要求我们计算将一个数减少到 0 的步骤，减少的规则为：如果二进制末位为 0 就除 2；如果为 1 就减 1。 C++ class Solution { public: int numberOfSteps(int num) { int res = 0; while(num !=0) { if(num & 1 == 1) { num -= 1; } else { num >>= 1; } res++; } return res; } }; "},"easy/1380.html":{"url":"easy/1380.html","title":"1380. Lucky Numbers in a Matrix(easy)","keywords":"","body":"1380. Lucky Numbers in a Matrix Leetcode link 题目简介 本题是一道简单题，但是其中还是有比较有趣的点值得思考的 题目给了我们一个二维数组，要求我们找到数组中的 Lucky number（定义为当前行最小且当前列最大） 解题思路1——模拟 第一种解法非常简单粗暴，我们遍历数组两次，第一次找出每一行的最小值，并且将其值记录下来 第二次找出每一列的最大值，如果在记录的最小值中有这个数，把它放进数组 res 保存起来 最后返回数组 res 复杂度分析： 时间复杂度是 $O(n^2)$ 空间复杂度是 $O(n)$ Javascript /** * @param {number[][]} matrix * @return {number[]} */ var luckyNumbers = function(matrix) { const minIndex = []; const res = []; // find minimum number in each row for(let i=0;i 解题思路2——进一步分析 这道题最鸡贼的点在于，它要求我们返回一个数组，且题目跟我们说的是找到 lucky numbers 这两点疯狂暗示我们 lucky number 有多个，但是实际上是如此吗？ 我们来简单分析一下： 首先我们假设有多个 lucky numbers，那么这些 lucky numbers 一定是在斜对角上，举个例子： [[x, A], [B, y]] 我们有一个包含有 4 个元素的二维数组，我们假设其中的 A 跟 B 都是 lucky number，根据题目定义得知： A = y B = x 我们把上述两个条件联立起来，可以得到下面的结论： B >= x >= A A >= y >= B 我们再把这两个式子简化一下可得： B >= A A >= B 至此，可以得到：A === B 由此可知，如果二维数组要存在多个 lucky numbers，多个 lucky numbers 必须相等 题目给出了另外一点要求：Given an m x n matrix of distinct numbers 由此可知，本题的答案是唯一的 废了这么大劲得到了这个结论，可以做什么呢？ 我们可以借由这个结论去减少空间复杂度 具体思路：既然只有一个答案，我们可以在遍历找到当前行的最小值的当下，遍历一下最小值的列，如果这个行最小值同时是列最大值，直接返回就好，如果不是继续遍历，知道最后如果都没有找到这个值，返回空数组 [] Javascript /** * @param {number[][]} matrix * @return {number[]} */ var luckyNumbers = function(matrix) { for(let i = 0;i row[colIndex] "},"easy/1475.html":{"url":"easy/1475.html","title":"1475. Final Prices With a Special Discount in a Shop(easy)","keywords":"","body":"1475. Final Prices With a Special Discount in a Shop Leetcode link 解题思路 这是一道简单题 我们只需要简单用两层遍历，在内层遍历找到第一个比外层遍历元素小的价格并将其相减就行，详见代码 Javascript /** * @param {number[]} prices * @return {number[]} */ var finalPrices = function (prices) { const res = [...prices] for (let i = 0; i "},"easy/1518.html":{"url":"easy/1518.html","title":"1518. Water Bottles(easy)","keywords":"","body":"1518. Water Bottles Leetcode link 题目简介 题目给我们两个参数： numBottles：代表初始状态下有几瓶装满水的瓶子 numExchange：代表几个空瓶子可以换一个装满水的瓶子 题目要求我们在给定的参数下，求得我们最后最多能喝几瓶水 解题思路 题目要求我们能喝几瓶水，所以我们只需要关注我们一开始有几瓶水 + 我们能换几瓶水就好 在每一轮喝完水之后，我们最多能换：拥有空瓶子的数量 / numExchange 取整数部份的瓶子 其中拥有空瓶子的数量 = 上一轮 numBottles / numExchange 取整数部份 + 上一轮 numBottles % numExchange 我们就这样一轮一轮的喝下去，直到拥有空瓶子的数量 numExchange 为止 Javascript /** * @param {number} numBottles * @param {number} numExchange * @return {number} */ var numWaterBottles = function (numBottles, numExchange) { let res = numBottles while (numBottles >= numExchange) { const remains = numBottles % numExchange const newBottle = Math.floor(numBottles / numExchange) res += newBottle numBottles = newBottle + remains } return res }; "},"easy/1598.html":{"url":"easy/1598.html","title":"1598. Crawler Log Folder(easy)","keywords":"","body":"1598. Crawler Log Folder Leetcode link 题目简介 题目给了一连串的文件操作，最后要求我们从 main 文件出发，经过题目的文件操作后，从最后的文件返回到 main 文件需要几步 文件操作有三种类型： ./：呆在原地 ../：返回上级文件 x/：进入特定下级文件 解题思路 这是一个简单题，我们只要顺着他们给的三种方式分别判断就好 我们使用 result 来记录当前文件距离 main 有多远，然后我们分别处理三种情况： ./：什么都不做 ../：距离减一（注意最小为 0，不能为负） x/：距离加一 Javascript /** * @param {string[]} logs * @return {number} */ var minOperations = function(logs) { let result = 0; logs.forEach(item => { if(item === \"../\") { result = --result "},"easy/1636.html":{"url":"easy/1636.html","title":"1636. Sort Array by Increasing Frequency(easy)","keywords":"","body":"1636. Sort Array by Increasing Frequency Leetcode link 题目简介 本题要求我们对数组排序，但是排序的规则有两个： 数组中出现次数少的数要排在出现次数多的数后面 如果两数出现次数相同，则按照降序排序 解题思路 为了记录每个数字的出现次数，我们需要建立一个数字与出现次数的映射 在 js 中，我们选用 Map 这个数据结构 统计完了出现次数之后，我们只需要按照题目的要求自定义排序方法就好，详见代码 Javascript /** * @param {number[]} nums * @return {number[]} */ var frequencySort = function(nums) { const map = new Map(); // 建立映射 for(const num of nums) { if(map.has(num)) { map.set(num, map.get(num) + 1) } else { map.set(num, 1) } } // 自定义排序规则：先按照出现次数升序；如果出现次数相同则降序排列 return nums.sort((a, b) => map.get(a) - map.get(b) || b-a) }; "},"easy/1710.html":{"url":"easy/1710.html","title":"1710. Maximum Units on a Truck(easy)","keywords":"","body":"1710. Maximum Units on a Truck Leetcode link 解题思路 本题要求我们放入最大单元的箱子进去卡车 这一题完全可以用贪心的思路去做，主要思路就是先放大的再放小的： 首先先针对箱子的大小排序，箱子大的放前面 再来遍历排序好的数组，一次放入卡车中直到再也放不下为止 Javascript /** * @param {number[][]} boxTypes * @param {number} truckSize * @return {number} */ var maximumUnits = function(boxTypes, truckSize) { boxTypes.sort((a, b) => b[1] - a[1]); let res = 0; for(let i=0;i 0;i++) { let num = Math.min(truckSize, boxTypes[i][0]); truckSize -= num; res += boxTypes[i][1] * num; } return res; }; "},"easy/1716.html":{"url":"easy/1716.html","title":"1716. Calculate Money in Leetcode Bank(easy)","keywords":"","body":"1716. Calculate Money in Leetcode Bank Leetcode link 题目简介 /** * @param {number} n * @return {number} */ 题目给我们一个参数 n，代表存了多少天的钱 题目要求我门根据 n 求出当前银行存款有多少了 存钱的规则如下： 在每个星期中，下一天的存款金额比上一天+1 如果当前是第 n 周，则当周星期一的存款金额是 n 块钱 第一个星期星期一存入 1 块钱 解题思路 这题比较简单，我们只需要判断当前的 n 是在第几周的第几天就可以了 根据题目描述，每一周都会比上一周多存 5 块钱 而每一天会比前一天多存 1 块钱 计算出结果即可 Javascript /** * @param {number} n * @return {number} */ var totalMoney = function (n) { let res = 0 const FIRST_WEEK_SAVING = (1 + 7) * 7 / 2 const weeks = Math.floor(n / 7) const restDays = n % 7 for (let i = 0; i "},"easy/1935.html":{"url":"easy/1935.html","title":"1935. Maximum Number of Words You Can Type(easy)","keywords":"","body":"1935. Maximum Number of Words You Can Type Leetcode link 题目简介 这是一道简单，题目给了我们一个 text 参数代表一个句子一个句子由空格与多个单词组成；一个 brokenLetters 代表打字机损坏的字母 题目要求我们求出这个打字机能够打出 text 这个句子中的几个单词 解题思路 要解题的话，我们只需要用到两个循环，在每一个单词中间寻找是否有损坏的单词就可以 Javascript /** * @param {string} text * @param {string} brokenLetters * @return {number} */ var canBeTypedWords = function (text, brokenLetters) { const words = text.split(' ') const letters = brokenLetters.split('') let res = 0 for (const word of words) { let hasBrokenLetter = false for (const letter of letters) { if (word.indexOf(letter) > -1) { hasBrokenLetter = true break; } } if (!hasBrokenLetter) { res++ } } return res }; "},"easy/2011.html":{"url":"easy/2011.html","title":"2011. Final Value of Variable After Performing Operations(easy)","keywords":"","body":"2011. Final Value of Variable After Performing Operations Leetcode link 题目简介 /** * @param {string[]} operations * @return {number} */ 本题参数 operations 包含四种操作：\"++X\", \"X++\", \"--X\", \"X--\" X 的初始值为 0，要求我们求出在经过所有 operations 之后 X 的值 解题思路 直接一个循环解了 Javascript /** * @param {string[]} operations * @return {number} */ var finalValueAfterOperations = function(operations) { let res = 0 for(const op of operations) { if(op[1] === '+') { res++ } else { res-- } } return res }; "},"easy/2273.html":{"url":"easy/2273.html","title":"2273. Find Resultant Array After Removing Anagrams(easy)","keywords":"","body":"2273. Find Resultant Array After Removing Anagrams Leetcode link 题目简介 题目给我们一个参数 words，代表一个由字符串组成的数组 题目要求我们进行筛选：如果相邻的字符串的字符是回文（由相同字母不同顺序）组成的话，则只保留下标小的那个字符 解题思路 检测回文我们可以用数组的 sort 来进行检测，剩下的只需要模拟题意从下标 1 开始遍历即可 Javascript /** * @param {string[]} words * @return {string[]} */ var removeAnagrams = function (words) { const ans = [words[0]] let lastSortedWord = words[0].split('').sort().join('') for (let i = 1; i "},"easy/2418.html":{"url":"easy/2418.html","title":"2418. Sort the People(easy)","keywords":"","body":"2418. Sort the People Leetcode link 题目简介 题目给了我们两个数组 names, heights 要求我们把人物的名字根据身高排序 解题思路 这是一个简单题，关键的卡点在于我们要怎么在排序的时候维持两个数组元素的一致性 在 js 中，我们可以简单的用一个 map 来保存两者的映射关系，这样只要我们把 heights 排序好之后根据映射关系以此找回 names 就好 Javascript /** * @param {string[]} names * @param {number[]} heights * @return {string[]} */ var sortPeople = function(names, heights) { const map = {}; // 建立映射关系 names.forEach((item, index) => { map[heights[index]] = item; }) // 排序 heights.sort((a, b) => b-a); // 根据映射关系取回名字 heights.forEach((item, index) => { names[index] = map[item]; }) return names; }; "},"easy/3005.html":{"url":"easy/3005.html","title":"3005. Count Elements With Maximum Frequency(easy)","keywords":"","body":"3005. Count Elements With Maximum Frequency Leetcode link 题目简介 这是道简单，题目给我们一个数组 nums 要求我们返回数组中出现频率最高的所有数字的个数 解题思路 这题的限制 1 让我们可以使用一个长度为 101 的数组 frequency 来保存所有可能出现数字的频率 然后我们遍历这个 frequency 找出出现频率最高的所有数字，将其出现的频率与个数相乘就是答案了 Javascript /** * @param {number[]} nums * @return {number} */ var maxFrequencyElements = function(nums) { const frequency = new Array(101).fill(0) nums.forEach(num => { frequency[num]++ }) // highest frequency let max = -1 let count = 0 frequency.forEach(f => { if(f > max) { max = f count = 1 } else if(f === max) { count++ } }) return count * max }; "},"easy/3289.html":{"url":"easy/3289.html","title":"3289. The Two Sneaky Numbers of Digitville(easy)","keywords":"","body":"3289. The Two Sneaky Numbers of Digitville Leetcode link 题目简介 /** * @param {number[]} nums * @return {number[]} */ 题目给我们一个数组 nums，并且知道其中有两个重复元素，要求我们返回两个重复元素组成的数组 解题思路 用一个 set 保存遍历过的元素，如果后续遍历中遇到了已经存在 set 的元素则将其放入需返回的数组中 Javascript /** * @param {number[]} nums * @return {number[]} */ var getSneakyNumbers = function(nums) { const set = new Set() const res = [] nums.forEach(num => { if(set.has(num)) { res.push(num) } else { set.add(num) } }) return res }; "},"easy/3349.html":{"url":"easy/3349.html","title":"3349. Adjacent Increasing Subarrays Detection I(easy)","keywords":"","body":"3349. Adjacent Increasing Subarrays Detection I Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {boolean} */ 本题给我们一个数组 nums 以及一个数字 k，要求我们在 nums 中找出两个长度为 k 的递增数组（不能有相同数字的递增） 如果能找到就返回 true，否则返回 false 解题思路 既然题目要求是找出两个，那么我们可以用两个变量 prevSubStrLen，curSubStrLen 来分别代表上一个递增数组的长度，以及当前递增数组的长度 如果当前递增数组的长度到达 k，并且上一个递增数组的长度大于等于 k，我们就可以认为找到了符合条件的两个递增数组 计算子数组的长度我们可以从下标 1 遍历数组 nums，如果当前下标元素比上一个下标元素大，我们就把 curSubStrLen++ 反之，如果比上一个下标元素小或者相等，则 prevSubStrLen = curSubStrLen，然后 curSubStrLen = 1 此外还需要注意一种情况就是单调递增子数组的长度大于 k*2，这种情况子数组本身可以被拆成两个长度为 k 的子数组，所以也是符合要求的 Javascript /** * @param {number[]} nums * @param {number} k * @return {boolean} */ var hasIncreasingSubarrays = function (nums, k) { if(k === 1) { return true } let prevSubStrLen = 1 let curSubStrLen = 1 for (let i = 1; i nums[i - 1]) { curSubStrLen++ } else { prevSubStrLen = curSubStrLen curSubStrLen = 1 } if(curSubStrLen === k && prevSubStrLen >= k || curSubStrLen >= k*2) { return true } } return false }; "},"easy/3354.html":{"url":"easy/3354.html","title":"3354. Make Array Elements Equal to Zero(easy)","keywords":"","body":"3354. Make Array Elements Equal to Zero Leetcode link 题目简介 /** * @param {number[]} nums * @return {number} */ 题目给我们一个数字数组 nums，并且要求我们做一系列的操作： 我们在 nums 中选择一个值为 0 的元素下标，然后选择一个方向（右移下标或者左移下标） 如果该下标移动超出数组边界，则该操作结束 如果移动过程中遇到 nums[i] === 0，则继续同方向移动 如果移动过程遇到 nums[i] > 0，则将该元素减一并反方向移动 我们最后的目标是找到合适的 [下标, 方向] 组合使得整个 nums 元素在操作后均为 0 题目要求我们判断当前 nums 数组中有多少个合适的 [下标, 方向] 组合 解题思路 根据题目我们不难看出想要使数组为 0 的关键在于我们选中的下标左右两边元素和的关系 有两种可能： 选中下标左右的元素之和相等：有两个可能的组合（因为此时一开始往左或者往右都可以） 选中下标左右元素之和差一：只有一个可能的组合（因为此时一开始只能往比较大的那边走） Javascript /** * @param {number[]} nums * @return {number} */ var countValidSelections = function (nums) { let res = 0 const sum = nums.reduce((acc, cur) => acc + cur, 0) let left = 0 let right = sum for (let i = 0; i "},"easy/3370.html":{"url":"easy/3370.html","title":"3370. Smallest Number With All Set Bits(easy)","keywords":"","body":"3370. Smallest Number With All Set Bits Leetcode link 题目简介 /** * @param {number} n * @return {number} */ 题目给我们一个数字 n，要求我们求出一个大于等于 n 的数，使其所有置位都是 1（也就是该数字二进制的表示都是 1） 解题思路 由于题目要我们求大于等于 n 且二进制表示全为 1 的数 那我们只需要先知道 n 的二进制表示的长度，然后把 1 左移该长度之后减一即可 Javascript /** * @param {number} n * @return {number} */ var smallestNumber = function(n) { return (1 "},"easy/3461.html":{"url":"easy/3461.html","title":"3461. Check If Digits Are Equal in String After Operations I(easy)","keywords":"","body":"3461. Check If Digits Are Equal in String After Operations I Leetcode link 题目简介 /** * @param {string} s * @return {boolean} */ 题目给了一个字符串 s，要求我们对字符串进行一系列操作，直到字符串剩下两个字符，最后返回这两个字符是否相等 一系列操作： 遍历字符串，取出下标为 i 与 i+1 的字符 将两者以数字形式相加之后 mod 10 将结果放到下标 i 的位置 遍历结束后丢弃 s.length - 1 下标的字符 解题思路 按照题目意思模拟即可 Javascript /** * @param {string} s * @return {boolean} */ var hasSameDigits = function (s) { let str = s let nextStr while (str.length > 2) { nextStr = '' for (let i = 1; i "},"easy/3516.html":{"url":"easy/3516.html","title":"3516. Find Closest Person(easy)","keywords":"","body":"3516. Find Closest Person Leetcode link 题目简介 本题是一道简单题，题目给了我们三个参数，分别代表三个人所在的位置，题目要求计算在前两个人匀速前进的情况下，谁能先到第三个人的位置 解题思路 匀速情况下，到达的时间只跟距离有关，所以我们分别计算两人与第三个人的距离，距离最短的就是最先到达的 Javascript /** * @param {number} x * @param {number} y * @param {number} z * @return {number} */ var findClosest = function (x, y, z) { const distanceXZ = Math.abs(x - z) const distanceYZ = Math.abs(y - z) if (distanceXZ === distanceYZ) { return 0 } else if (distanceXZ > distanceYZ) { return 2 } else { return 1 } }; "},"easy/3541.html":{"url":"easy/3541.html","title":"3541. Find Most Frequent Vowel and Consonant(easy)","keywords":"","body":"3541. Find Most Frequent Vowel and Consonant Leetcode link 题目简介 题目要求我们分别计算一个字符串 s 中母音字符与辅音字符出现最多的次数，并返回两者的次数之和 解题思路 我们用一个数组来保存 26 个字母，然后遍历一次 s 统计所有字母出现频率，最后再分别计算母音与字音出现频率最高的次数之和返回就好 Javascript /** * @param {string} s * @return {number} */ var maxFreqSum = function(s) { const countArr = new Array(26).fill(0) const charCodeOfA = 'a'.charCodeAt() const vowels = ['a', 'e', 'i', 'o', 'u'] let frequencyOfVowels = 0 let frequencyOfConsonant = 0 for(const c of s) { countArr[c.charCodeAt() - charCodeOfA]++ } vowels.forEach(v => { const idx = v.charCodeAt() - charCodeOfA frequencyOfVowels = Math.max(frequencyOfVowels, countArr[idx]) countArr[idx] = 0 }) frequencyOfConsonant = Math.max(...countArr) return frequencyOfVowels + frequencyOfConsonant }; "},"medium/":{"url":"medium/","title":"Medium","keywords":"","body":"Meduim "},"medium/2.html":{"url":"medium/2.html","title":"2. Add Two Numbers","keywords":"","body":"2.Add Two Numbers Leetcode link 解题思路 题目告诉我们每一个节点范围在 0 到 9 之间，并且贴心的帮我们倒序了（个位数在链表头，依次是十位，百位，千位。。。），那我们只需要另外创建一个链表，通过一次遍历加总之后返回链表头就可以了。这其中需要注意的就是加法会有进位，所以可以用一个 int 来存储进位值。 C++ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* result = new ListNode(0); ListNode* cur = result; int carry = 0; while (l1 || l2 || carry) { int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry; carry = sum / 10; cur->next = new ListNode(sum % 10); cur = cur->next; l1 = l1 ? l1->next : l1; l2 = l2 ? l2->next : l2; } return result->next; } }; Javascript var addTwoNumbers = function (l1, l2) { const result = new ListNode(0); let cur = result; let carry = 0; while (l1 || l2 || carry) { let sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry; carry = Math.floor(sum / 10); cur.next = new ListNode(sum % 10); cur = cur.next; l1 = l1 ? l1.next : l1; l2 = l2 ? l2.next : l2; } return result.next; }; "},"medium/3.html":{"url":"medium/3.html","title":"3. Longest Substring Without Repeating Characters(medium)","keywords":"","body":"3. Longest Substring Without Repeating Characters Leetcode link 解题思路 本题要求我们找到一个字符串的最长不重复子串的长度 因为子串的连续性，我们可以考虑滑动窗口的方式 具体而言，我们创建两个指针 left 和 right，分别作为窗口的两个边界 一开始，left 指向第一个元素，right 负责向右遍历，直到遇到了与窗口中重复的字符 记录下当前长度之后，我们就可以把 left 往右一个元素，然后继续遍历 right 了 最后，当 left 移到最后一个元素之后，我们比较一下记录下来的长度，取出最大值就好 查找字符是否重复我们可以用哈希集合的数据结构 C++ class Solution { public: int lengthOfLongestSubstring(string s) { int len = s.size(); int right = -1; int res = 0; unordered_set occ; for(int left = 0;left Javascript /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { let right = -1; let res = 0; let len = s.length; let occ = new Set(); for(let left = 0;left "},"medium/5.html":{"url":"medium/5.html","title":"5. Longest Palindromic Substring(medium)","keywords":"","body":"5. Longest Palindromic Substring Leetcode link 解题思路 本题要求我们找出一个字符串的最长回文子串 一个简单的思路就是遍历字符串，把每一个字符当成回文的中心，求出对应的回文子串的起始下标与结束下标 最后选取最长的一段回文子串返回 C++ class Solution { public: string longestPalindrome(string s) { int start = 0, end = 0; for(int i = 0;i end - start) { end = oddRight; start = oddLeft; } if(evenRight - evenLeft > end - start) { end = evenRight; start = evenLeft; } } return s.substr(start, end - start + 1); } pair expandAroundCenter(string& s, int left, int right) { while(left >=0 && right Javascript /** * @param {string} s * @return {string} */ var longestPalindrome = function(s) { let start = 0, end = 0; for(let i = 0;i end - start) { start = oddLeft; end = oddRight; } if(evenRight - evenLeft > end - start) { start = evenLeft; end = evenRight; } } return s.slice(start, end+1); }; // 计算由回文中心出发的最长回文子串起始与结束下标 var expandAroundCenter = function(s, left, right) { while(left >= 0 && right "},"medium/6.html":{"url":"medium/6.html","title":"6. Zigzag Conversion(medium)","keywords":"","body":"6. Zigzag Conversion Leetcode link 题目简介 题目给我们两个参数： s：代表一个字符串 numRows：代表所需行数 题目要求我们使用字符串 s 画一个有 numRows 行的 Z 字形（镜像之后旋转 90 度） 1 7 2 6 8 3 5 9 4 10 （大概长这样） 最后在按照从左到右，从上到下返回，也就是：17268359410 解题思路 这题的难点在于如何构建后将字符按照题目要求顺序提取出来 一开始我想的是用一个二维数组来保存，后来发现用一维字符串数组就可以搞定了 具体来说，上面这个数字的例子可以被压缩成： 1 7 2 6 8 3 5 9 4 10 这样一来，我们就可以把题目简化成： 首先由上到下把字符塞进不同行的字符串里 一旦碰到了行的底部，由下往上把字符塞进不同行的字符串里 循环 1、2 直到字符串被遍历完成 把数组所有的字符串按顺序拼起来就好 Javascript /** * @param {string} s * @param {number} numRows * @return {string} */ var convert = function(s, numRows) { if(numRows === 1) return s const rows = new Array(Math.min(s.length, numRows)).fill('') let direction = 1 let curRow =0 for(const char of s) { rows[curRow] += char curRow += direction if(curRow === 0 || curRow === numRows-1) { direction = -direction } } return rows.join('') }; "},"medium/7.html":{"url":"medium/7.html","title":"7. Reverse Integer(medium)","keywords":"","body":"7. Reverse Integer Leetcode link 题目简介 本题给我们一个参数 x，代表一个 32 位的整数，题目要求我们把整数反转 如果反转后的整数超过了 32 位的限制，则返回 0 Javascript /** * @param {number} x * @return {number} */ var reverse = function (x) { const sign = x >= 0 ? 1 : -1 let posX = Math.abs(x) let res = 0 const LIMIT = 2 ** 31 - 1 while (posX !== 0) { const digit = posX % 10 posX = Math.floor(posX / 10) // check the overflow before adding the digit if (res > LIMIT / 10) { return 0 } res = digit + res * 10 } return res * sign }; "},"medium/8.html":{"url":"medium/8.html","title":"8. String to Integer (atoi)(medium)","keywords":"","body":"8. String to Integer (atoi) Leetcode link 题目简介 本题给了一个参数 s，要求我们将字符串 s 转成 32 位的整数 此外，题目要求： 忽略最前面的空白字符 需要考虑正负符号 -, + 忽略数字前面的 0，并且如果转换过程中遇到了数字以外的字符就要停止，返回当前转换的数字 如果转换的数字超过了 32 位，只需返回 32 位的最大值/最小值 Javascript /** * @param {string} s * @return {number} */ var myAtoi = function (s) { const ZERO = '0'.charCodeAt(0) const POS_LIMIT = 2 ** 31 - 1 const NEG_LIMIT = -(2 ** 31) const len = s.length let res = 0 let i = 0 let sign = 1 // skip the leading space while (i = '0' && s[i] POS_LIMIT) { return POS_LIMIT } if (sign * res "},"medium/11.html":{"url":"medium/11.html","title":"11. Container With Most Water(medium)","keywords":"","body":"11. Container With Most Water Leetcode link 解题思路 本题要求我们选中任意两个高度当成容器求水的最大体积。由题目可知，水的体积 S 的公式如下： S = (right - left) * min(height[left], height[right])，其中 left 与 right 分别是选中的两个高度的下标。 如果把所有的情况遍历一次，总共需要 n * (n - 1) / 2 次，肯定不符合预期，所以我们必须想办法减少复杂度。 考虑到如下两种情况： height[left] ：我们接下来只需要检查 (left + 1, right) 这个区间就好 height[right] ：我们接下来只需要检查 (left, right - 1) 这个区间就好 证明：假设 height[left] ，我们来证明 (left, right - X) 区间已经没有任何能增加水体积的可能了。 当X = 1 时，在区间 (left, right - 1) 我们有水体积 S' = (right - 1 - left) * min(height[left], height[right - 1])。 从 S' 可以推导出 S' ，可想而知，就算 X 再大，只会让水体积更小 在上述结论的情况下，我们再进一步思考，在 height[left] 的时候，如果 height[left + 1] 还是小于 height[left] 那就可以直接略过这个直接检查 left + 2、 left + 3…… 直到找到第一个 height[left + X] > height[left] 之后再计算水体积进行比较。 C++ class Solution { public: int maxArea(vector& height) { int result = 0, left = 0, right = height.size() - 1; while (left Javascript var maxArea = function(height) { let result = 0, left = 0, right = height.length - 1; while (left "},"medium/12.html":{"url":"medium/12.html","title":"12. Integer to Roman(medium)","keywords":"","body":"12. Integer to Roman Leetcode link 题目简介 本题给我们一个参数 num，表示一个 0～3999 的数字 题目要求我们将 num 转换成罗马数字 解题思路 我们只要从大到小遍历罗马数字的值然后将对应的符号放入我们的答案中就可以了 Javascript /** * @param {number} num * @return {string} */ var intToRoman = function (num) { let res = '' while (num > 0) { switch (true) { case num >= 1000: res += 'M' num -= 1000 break; case num >= 900: res += 'CM' num -= 900 break; case num >= 500: res += 'D' num -= 500 break; case num >= 400: res += 'CD' num -= 400 break; case num >= 100: res += 'C' num -= 100 break; case num >= 90: res += 'XC' num -= 90 break; case num >= 50: res += 'L' num -= 50 break; case num >= 40: res += 'XL' num -= 40 break; case num >= 10: res += 'X' num -= 10 break; case num === 9: res += 'IX' num -= 9 break; case num >= 5: res += 'V' num -= 5 break; case num === 4: res += 'IV' num -= 4 break; case num >= 1: res += 'I' num -= 1 break; } } return res }; 或者： /** * @param {number} num * @return {string} */ var intToRoman = function(num) { const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; const symbols = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']; let res = '' for(let i=0;i= values[i]) { res += symbols[i] num -= values[i] } } return res }; "},"medium/15.html":{"url":"medium/15.html","title":"15. 3Sum(medium)","keywords":"","body":"15. 3Sum Leetcode link 题目简介 /** * @param {number[]} nums * @return {number[][]} */ 题目给我们一个数字数组 nums，要求在数组中找出三个数字之和为 0 的所有不重复的三元组 解题思路 这一题是 two sum 的加强版 我们只需要先锁定一个元素（假设是 nums[0]）后，其他的部份也可以用 two sum 的双指针来处理 这题还有一个难点就是要去除重复的三元组，这个需要三个步骤来处理： 首先我们需要对数组 nums 升序排序 对于 i>0，如果出现 nums[i] === nums[i-1]，则直接跳过当前的 i（i 是第一个元素的遍历下标） 当找到三元组 nums[i] + nums[left] + nums[right] === 0 时，我们需要更新 left 以及 right 两个指针，此时如果 nums[left] === nums[left - 1] 或者 nums[right] === nums[right + 1] 时，也需要跳过当前的 left 与 right Javascript /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function (nums) { const res = [] const len = nums.length nums.sort((a, b) => a - b) for (let i = 0; i 0) { break; } // prevent duplicate answers if (i > 0 && nums[i] === nums[i - 1]) { continue } const rest = -nums[i] let left = i + 1 let right = len - 1 while (left rest) { right-- } else if (twoSum left) { right-- } } } } return res }; "},"medium/16.html":{"url":"medium/16.html","title":"16. 3Sum Closest(medium)","keywords":"","body":"16. 3Sum Closest Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} target * @return {number} */ 本题是 3 sum 的变体，要求我们从 nums 中找出三个数字之和与 target 差距最小，并最后返回三数之和 解题思路 这题我们还是用一层遍历 + 双指针的方式来做 区别在于我们需要每次多关注一个 minDiff 的参数更新，这个参数表示当前遍历过的所有三元组中，和与 target 差距最小的差距 如果差距为 0，则返回当前之和，否则要更新 minDiff 并记录当前之和 Javascript /** * @param {number[]} nums * @param {number} target * @return {number} */ var threeSumClosest = function (nums, target) { nums.sort((a, b) => a - b) let minDiff = Infinity let res = Infinity const len = nums.length for (let i = 0; i 0 && nums[i] === nums[i - 1]) { continue } let left = i + 1 let right = len - 1 while (left "},"medium/17.html":{"url":"medium/17.html","title":"17. Letter Combinations of a Phone Number(medium)","keywords":"","body":"17. Letter Combinations of a Phone Number Leetcode link 解题思路 本题要我们求出指定的拨号能够组合出的所有字母排列 要处理这个题目首先需要建立一组拨号数字到字母的映射表 dialMap = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' } 然后我们可以抽象一下：所有拨号字母的组合 = 前面 n 个拨号字母的组合 分别加上 后面一个拨号的字母映射 举个例子，假设现在要求 \"23\"，那么： 2 的组合有：[\"a\", \"b\", \"c\"] 将 3 的字母映射分别加到 2 的组合中：[\"ad\", \"bd\", \"cd\", \"ae\", \"be\", \"ce\", \"af\", \"bf\", \"cf\"] 如此一来，我们只需要遍历 digits，然后每次都将新的数字的映射分别加到旧的组合后面就好了 C++ class Solution { public: vector combineString(vector & prev, string cur) { vector res; for(string comb : prev) { for(char ch: cur) { res.push_back(comb + ch); } } return res; } vector letterCombinations(string digits) { if(digits.size() == 0) { return {}; } unordered_map dialMap { {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; vector res {\"\"}; for(char digit: digits) { res = combineString(res, dialMap[digit]); } return res; } }; Javascript var letterCombinations = function(digits) { const dialMap = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' } return digits.split('').reduce((prev, cur)=> { if(prev.length === 0) { return dialMap[cur].split(''); } let res = []; for(let oldChar of prev) { for(let newChar of dialMap[cur].split('')) { res.push(`${oldChar}${newChar}`); } } return res; },[]) }; "},"medium/18.html":{"url":"medium/18.html","title":"18. 4Sum(medium)","keywords":"","body":"18. 4Sum Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} target * @return {number[][]} */ 这题就是 3 sum 的再进阶版 本题给了一个数字数组 nums 以及一个 target 要求我们在 nums 中找到任意四个元素，使得其和为 target 要求返回所有不重复的四元组 解题思路 3 sum = 一个循环+双指针 4 sum = 两个循环+双指针 记得去除重复的元组就好 Javascript /** * @param {number[]} nums * @param {number} target * @return {number[][]} */ var fourSum = function (nums, target) { const len = nums.length const res = [] if (len a - b) for (let i = 0; i 0 && nums[i] === nums[i - 1]) { continue; } for (let j = i + 1; j i + 1 && nums[j] === nums[j - 1]) { continue } let left = j + 1 let right = len - 1 const sum = nums[i] + nums[j] while (left target) { right-- } else { res.push([nums[i], nums[j], nums[left], nums[right]]) left++ right-- // skip duplicate while (nums[left] === nums[left - 1] && left left) { right-- } } } } } return res }; "},"medium/19.html":{"url":"medium/19.html","title":"19. Remove Nth Node From End of List(medium)","keywords":"","body":"19. Remove Nth Node From End of List Leetcode link 题目简介 /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ 题目要求我们将链表 head 的后面第 n 项删除 解题思路 这种查找链表最后 n 项的题目，我们优先考虑双指针来解决 具体而言，如果题目要求我们删除最后第三项，我们用两个指针来模拟： 1 -> 2 -> 3 -> 4 -> 5 ^ ^ left 指针指向当前链表头，right 指针指向链表头后 3 项的元素（也就是上面代码中的 4） 接下来，我们让两个指针同步往前进，直到 right 指针指向链表最后一个元素： 1 -> 2 -> 3 -> 4 -> 5 ^ ^ 此时指针 left 应该要指向要删除元素的前一个元素 此时我们只需要将 left.next = left.next.next 就可以完成元素删除了 当然我们还需要考虑一种边界情况，那就是要删除的是该链表的链表头 在这种情况下，n 等于链表的长度，此时当我们移动 right 指针的时候，会得到 right === null： // 假设此时 n === 5 1 -> 2 -> 3 -> 4 -> 5 -> null ^ ^ 此时我们需要返回 head.next Javascript /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ var removeNthFromEnd = function(head, n) { let left = head let right = head let count = n while(count>0) { right = right.next count-- } if(!right) { return head.next } while(right.next) { right = right.next left = left.next } left.next = left.next.next return head }; "},"medium/29.html":{"url":"medium/29.html","title":"29. Divide Two Integers(medium)","keywords":"","body":"29. Divide Two Integers Leetcode link 解题思路 本题要求我们在不用乘法、除法与取模运算符的情况下实现一个 32 位整数除法，所得的商向 0 舍入 本题的难点有两个： 边界值的判定 如何用加法模拟除法 边界值判定比较好处理，下面聊一下如何用加法模拟除法 我们直接用一个例子来说明：62 除以 8 要高效且快速逼近被除数，我们考虑 “将除数翻倍” 的方法 首先 62/8 可以看成 (62 - 8 * 2 * 2)/8 + 4 (62 - 32)/8 + 4 可以进一步拆分成 (62 - 32 - 8 * 2)/8 + 4 + 2 最后可以变成(62 - 32 - 16 - 8)/8 + 4 + 2 + 1 = 7（向 0 舍入） C++ class Solution { public: int divide(int dividend, int divisor) { // 边界值 if (dividend == 0) return 0; if (divisor == 1) return dividend; if (divisor == -1) { if (dividend > INT_MIN) return -dividend; return INT_MAX; } // 由于本解法适用两个数都为正，所以这里先保存符号 int sign = 1; if ((dividend > 0 && divisor 0)) { sign = -1; } // 取个绝对值 long a = abs(dividend); long b = abs(divisor); // 核心，本质上就是用递归跑了一次上述思路 long res = helper(a, b); // 最后再把之前保存的符号加回来，顺便处理边界值 if (sign > 0) return res > INT_MAX ? INT_MAX : res; return -res; } int helper(long a, long b) { if (a "},"medium/31.html":{"url":"medium/31.html","title":"31. Next Permutation(medium)","keywords":"","body":"31. Next Permutation Leetcode link 解题思路 本题要求我们通过排列组合得出下一个更大的排列，以 [1,2,3] 为例子，这三个数字总共有 6 种可能的排列组合，从小到大依次是 [1,2,3] 、[1,3,2] 、[2,1,3] 、[2,3,1] 、[3,1,2] 、[3,2,1]，最后一个 [3,2,1] 按照题目的要求要返回 [1,2,3] 那么要怎么找到下一个更大的排列呢？我们以 [4,5,2,6,3,1] 为例： 要找到下一个更大的，我们必须从右往左看，找到从右往左看第一个不是升序的元素，也就是 2 然后我们再重新从右往左看，找到第一个大于 2 的元素，也就是 3 我们把 2 跟 3 交换之后，得到 [4,5,3,6,2,1]，可以明显看出来现在已经比原来的大了，但是太大了 我们发现，可以对第一个交换元素的后面进行排序来缩小这个数，也就是针对 [6,2,1] 排序 最后我们得到 [4,5,3,1,2,6] 最后我们可以推断出，步骤 4 要排序的序列一定是降序的，所以我们可以通过反转来进一步降低复杂度 C++ class Solution { public: void nextPermutation(vector& nums) { int i = nums.size() - 2; while (i >= 0 && nums[i] >= nums[i + 1]) { i--; } if (i >= 0) { int j = nums.size() - 1; while (j >= 0 && nums[i] >= nums[j]) { j--; } swap(nums[i], nums[j]); } reverse(nums.begin() + i + 1, nums.end()); } }; Javascript Array.prototype.myReverse = function (start, end) { const arr = this; while (start = 0 && nums[i] >= nums[i + 1]) { i--; } if (i >= 0) { let j = nums.length - 1; while (j >= 0 && nums[i] >= nums[j]) { j--; } [nums[i], nums[j]] = [nums[j], nums[i]]; } i "},"medium/46.html":{"url":"medium/46.html","title":"46. Permutations(medium)","keywords":"","body":"46. Permutations Leetcode link 解题思路 求一组元素可能的排列组合，最常用的方法就是回溯 backtracking 了 为了减少时间复杂度，我们用了一个数组 visited 来记录当前选择的元素是否已经被选过了，达到剪枝的目的 C++ class Solution { public: vector> permute(vector& nums) { vector> res; vector visited(nums.size()); getPermutations(res, nums, visited, {}); return res; } void getPermutations(vector> &res, vector& nums, vector &visited, vector array) { if(array.size() == nums.size()) { res.push_back(array); return; } for(int i=0;i Javascript var permute = function(nums) { let res = []; let visited = new Array(nums.length).fill(false); getPermutations(res, nums, visited, []); return res; }; var getPermutations = function(res, nums, visited, arr) { if(arr.length === nums.length) { res.push(arr); return; } for(let i = 0;i "},"medium/47.html":{"url":"medium/47.html","title":"47. Permutations II(medium)","keywords":"","body":"47. Permutations II Leetcode link 解题思路 本题跟 46. Permutations 思路差不多，区别在于这个题目给的数组中有重复项 我们可以在 46 题的基础上，加上两个部分： 给 nums 排序，让重复的数字比邻 在 46 题的规则上进行剪枝 第一个部分比较好理解，问题在于第二个部分剪枝的规则，我们的思路是： 首先我们假设有个重复项 [a~1~, a~2~]，那么我们规定 a~1~ 必须在 a~2~ 前面出现 如此一来，我们进行剪枝的规则就出来了： 判断当前项是否与前一项相等，如果是 判断前一项是否已经出现了，如果是 那么不进行剪枝；否则进行剪枝 C++ class Solution { public: vector> permuteUnique(vector& nums) { sort(nums.begin(), nums.end()); vector> res; vector visited(nums.size()); getPermutations(res, nums, visited, {}); return res; } void getPermutations(vector> &res, vector& nums, vector &visited, vector array) { if(array.size() == nums.size()){ res.push_back(array); return; } for(int i=0;i Javascript /** * @param {number[]} nums * @return {number[][]} */ var permuteUnique = function(nums) { // 记得先排序一下让重复项相邻 nums.sort((a, b)=>a-b); let res = []; let visited = new Array(nums.length).fill(false); getPermutations(res, nums, visited, []); return res; }; var getPermutations = function(res, nums, visited, arr) { if(arr.length === nums.length) { res.push(arr); return; } for(let i = 0;i "},"medium/59.html":{"url":"medium/59.html","title":"59. Spiral Matrix II(medium)","keywords":"","body":"59. Spiral Matrix II Leetcode link 解题思路 题目要求我们给 n x n 的数组螺旋赋值 想要螺旋赋值首先就得规定好四面 “墙”，我们分别叫他们 left， right， top， bottom 我们可以把赋值的分成 4 个步骤，并在昨晚之后对墙做相应的调整： 从左到右，之后把上墙下移 ++top 从上到下，之后把右墙左移 --right 从右到左，之后把下墙上移 --bottom 从下到上，之后把左墙右移 ++left 以上四个动作为一个循环，然后不断循环缩小范围直到全部赋值完毕 C++ class Solution { public: vector> generateMatrix(int n) { vector> res(n, vector(n)); int left = 0, right = n - 1, top = 0, bottom = n - 1; int number = 1; // use to trace current path int i = 0; while (left = left) { res[bottom][i--] = number++; } i = --bottom; // bottom to top while (i >= top) { res[i--][left] = number++; } i = ++left; } return res; } }; Javascript /** * @param {number} n * @return {number[][]} */ var generateMatrix = function(n) { const res = Array(n); for(let i = 0;i= left) { res[bottom][i--] = number++; } i = --bottom; // bottom to top while (i >= top) { res[i--][left] = number++; } i = ++left; } return res; }; "},"medium/61.html":{"url":"medium/61.html","title":"61. Rotate List(medium)","keywords":"","body":"61. Rotate List Leetcode link 解题思路 题目要求我们给一个链表旋转 k 个位置，而且把 k 的范围给了一个 ，所以考虑优化肯定需要取余。 回到解题思路本身，链表旋转本质上就是三个步骤： 把原来链表的 “尾巴” 接到 “ 头” 上 确定新的链表头 把新链表头的前一个链表的 next指定为NULL 具体落实到代码里，考虑细节的话需要做到如下几步： 计算链表长度，并把链表尾接到链表头上 计算新的链表头的位置 留一个指针指向新链表的尾巴，并将其next置为NULL C++ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if (head == NULL || k == 0) return head; int len = 1; ListNode* cur = head; // 计算链表长度，并把链表尾接到链表头上 while (cur->next) { len++; cur = cur->next; } cur->next = head; cur = head; // 计算新的链表头的位置 int step = len - (k % len); while (--step > 0) { cur = cur->next; } head = cur->next; // 将新链表尾置为NULL cur->next = NULL; return head; } }; Javascript var rotateRight = function (head, k) { if (!head || k === 0) return head; let len = 1; let cur = head; // 计算链表长度，并把链表尾接到链表头上 while (cur.next) { len++; cur = cur.next; } cur.next = head; cur = head; // 计算新的链表头的位置 let step = len - (k % len); while (--step > 0) { cur = cur.next; } head = cur.next; // 将新链表尾置为NULL cur.next = null; return head; }; "},"medium/63.html":{"url":"medium/63.html","title":"63. Unique Paths II(medium)","keywords":"","body":"63. Unique Paths II Leetcode link 解题思路 本题要求我们在一个 m * n 的矩阵中，计算从左上角走到右下角不碰到障碍物的所有路径 本题解法有两种思路：dfs 以及动态规划 首先来看一下 dfs，dfs 的方法会要求我们遍历所有可能的路径，我们来看一下它的时间复杂度： 因为每一个节点有两种可能的走法：向下跟向右，而所有的节点总共有 m n 个，所以总共要做 m n 次抉择 因此时间复杂度为 O(2 ^ (m * n)) 接下来，我们来看看动态规划 首先，我们用一个二维数组 dp，其中 dp[i][j] 表示矩阵中下标为 (i, j) 的位置能够到达的路径数量 根据题目中只能向下走跟向右走的限制，我们可以轻易得出如下等式： dp[i][j] = dp[i-1][j] + dp[i][j-1] 如果没有障碍物的话，到这里已经结束了，但是题目的另一个约束条件就是路径上可能有障碍物，所以，我们格局需要再打开一点 具体而言，我们可以把目前 m n 的 dp 数组分别在左边跟上面加上一列以及一行，使其大小为 `(m + 1) (n + 1)` 然后我们可以把 dp 数组初始化为 0，然后在 (1, 0) 或者 (0, 1) 的位置初始化为 1 就好了 详情看代码 C++ class Solution { public: int uniquePathsWithObstacles(vector>& obstacleGrid) { int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector> dp(m+1, vector(n+1, 0)); dp[0][1] = 1; for(int i = 1;i Javascript var uniquePathsWithObstacles = function(obstacleGrid) { let m = obstacleGrid.length, n = obstacleGrid[0].length; // dp[m+1][n+1] let dp = new Array(m+1); for(let i=0;i "},"medium/74.html":{"url":"medium/74.html","title":"74. Search a 2D Matrix(medium)","keywords":"","body":"74. Search a 2D Matrix Leetcode link 解题思路 本题给了我们一个二维数组，又告诉我们保证每一行都是升序的，而且下一行的数一定比较大。简单来说，这个就是一个升了一个纬度的升序数组。于是乎，二分法再次成为我们的得力助手。 本题的思路核心在于，如何将二分法计算出来的中间值 mid 对二维数组取值，解决了这一点这题就没什么难度了。 C++ class Solution { public: bool searchMatrix(vector>& matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int left = 0, right = n * m - 1; while (left value) left = mid + 1; } return false; } }; Javascript var searchMatrix = function(matrix, target) { let m = matrix.length, n = matrix[0].length; let left = 0, right = n * m - 1; while (left value) left = mid + 1; } return false; }; "},"medium/81.html":{"url":"medium/81.html","title":"81. Search in Rotated Sorted Array II(medium)","keywords":"","body":"81. Search in Rotated Sorted Array II Leetcode link 解题思路 本题与 704 的 binary search其实本质上是相同的问题，只是这题在原来的基础上加了一个随机旋转数组的操作。但是我们仍然可以用二分的思想来做查找的动作，只是需要多判断一些条件 首先我们假设有这么一个数组 [1, 2, 3, 4, 5, 6, 7]，它经过旋转之后以最中间的数为观察点有 2 种情况： 左边升序、右边不一定升序，比如：[3, 4, 5, 6, 7， 1， 2]（以中间的数 6 来看，3～6 明显是升序的，6～2 明显不升序） 右边升序、左边不一定升序，比如：[6, 7, 1, 2, 3, 4, 5]（以中间的数 2 来看，6～2 明显不升序，2～5 明显升序） 但是题目说到数组允许重复数字，我们考虑到一种特殊的数组 [1, 1, 1, 1, 1, 2]，这种数组为我们的情况增加了一种： 左右两边都一定升序（只要数字 2 不刚好是中间数就会出现这种情况） 要使用二分法，需要确定三个点：left, right, mid left 用来确定二分范围的左边界 right 用来确定二分范围的右边界 mid 是本次二分范围的中心，用来确定下一次二分的区域 本题我们只需要再针对上述三种状况分别判断一下就可以了： 第一种情况，我们可以用 nums[mid] > nums[right] 为真来确定 第二种情况，我们可以用 nums[mid] 为真来确定 第三种情况，我们可以用 nums[mid] == nums[right] 为真来确定 用代码区分开了三种情况之后，我们只需要分别处理就好了，这里我们的思路可以概括为：柿子挑软的捏 针对第一、第二种情况，我们只需要判断 target 是否在他们升序部分就好了，如果是就把范围定到升序部分之后处理就好（情况二刚好也可以处理升序）；如果不是就说明 target 要不在另一部分，要不不在数组中，我们把范围缩小到另一部分重新判断一次情况。 针对第三种情况，我们只需要把 right - 1 就好了，也就是把右边范围缩小慢慢排除重复的数字 C++ class Solution { public: bool search(vector& nums, int target) { int left = 0, right = nums.size() - 1; while (left nums[right]) { // 如果它在升序的部分 if (nums[mid] > target && nums[left] = target) { left = mid + 1; } else { right = mid - 1; } // 确定是第三种情况 } else { right--; } } // 找完之后没找到 return false; } }; Javascript var search = function(nums, target) { let left = 0, right = nums.length - 1; while (left nums[right]) { // 如果它在升序的部分 if (nums[mid] > target && nums[left] = target) { left = mid + 1; } else { right = mid - 1; } // 确定是第三种情况 } else { right--; } } return false; }; "},"medium/99.html":{"url":"medium/99.html","title":"99. Recover Binary Search Tree(medium)","keywords":"","body":"99. Recover Binary Search Tree Leetcode link 解题思路 本题随意调换了 BST 的两个元素。 我们知道，当对 BST 进行先序遍历的时候，得到的是一个递增序列，在递增序列任意交换两个数有两种可能： 两个交换的数是相邻的 两个交换的数不相邻 那么我们可以用一个指针 prev 记录上一个中序遍历的节点，然后跟当前节点对比，如果 prev 比较大，则把 prev 跟当前节点一起存放到一个数组 target 中。 这样子一次遍历之后，有两种可能： target 中有一个元素（因为两个交换的数比邻），那么只需要交换元素中两个指针的 val 就好。 target 中有两个元素（因为两个交换的数不相邻），那么只需要交换 第一个元素的第一个指针的 val 与 第二个元素的第二个指针的 val 就好。 C++ class Solution { public: vector> target; TreeNode* prev = nullptr; void dfs(TreeNode* node) { if (node == nullptr) { return; } dfs(node->left); if (prev && (prev->val > node->val)) { target.push_back({prev, node}); } prev = node; dfs(node->right); } void recoverTree(TreeNode* root) { dfs(root); if (target.size() == 1) { // 相邻情况 swap(target[0].first->val, target[0].second->val); } else if (target.size() == 2) { // 不相邻情况 swap(target[0].first->val, target[1].second->val); } } }; Javascript var recoverTree = function(root) { let target = []; let prev = null; const dfs = (node)=>{ if(!node){ return; } dfs(node.left); if(prev && prev.val > node.val) { target.push([prev, node]); } prev = node; dfs(node.right); } dfs(root); if(target.length === 1) { // 相邻情况 [target[0][0].val, target[0][1].val] = [target[0][1].val, target[0][0].val]; } else if(target.length === 2) { // 不相邻情况 [target[0][0].val, target[1][1].val] = [target[1][1].val, target[0][0].val]; } }; "},"medium/117.html":{"url":"medium/117.html","title":"117. Populating Next Right Pointers in Each Node II(medium)","keywords":"","body":"117. Populating Next Right Pointers in Each Node II Leetcode link 解题思路——先进先出队列 这道题有两种思路，我们先说第一种队列的思路 首先我们需要一个先进先出的队列，然后我们按照题目要求的顺序从上到下从左到右一次把目标元素填入队列中 值得注意的是每一层的最后一个元素后面记得多填一个 NULL ；然后对于节点空的位置也需要填入 NULL C++ class Solution { public: Node* connect(Node* root) { if(!root) { return NULL; } queue q; q.push(root); q.push(NULL); while(q.size() > 1) { Node* node = q.front(); q.pop(); if(node == NULL) { q.push(NULL); } else { node->next = q.front(); if(node->left) { q.push(node->left); } if(node->right) { q.push(node->right); } } } return root; } }; 解题思路——递归 另一种思路是使用递归思想配合一个数组 数组的作用在于记录当前的层从左到右还没有记录 next 的第一个节点 Javascript var connect = function(root) { let levelPtr = []; var addNext = (node, level) => { if(!node) { return; } // 因为每一层都是从左到右访问，所以每一层只需要记录最左边还没有记录 next 指针的元素就好 if(levelPtr[level]) { levelPtr[level].next = node; } levelPtr[level] = node; addNext(node.left, level+1); addNext(node.right, level+1); } addNext(root, 0); return root; }; "},"medium/120.html":{"url":"medium/120.html","title":"120. Triangle(medium)","keywords":"","body":"120. Triangle Leetcode link 解题思路 本题要求我们求出一条从三角形顶部走到底部的最小路径和，且每一步只能移动到下一行的相邻节点上 很明显是一个动态规划的题目，我们需要一个二维数组 dp[i][j] 来记录走到 (i, j) 的最小路径和 我们首先得找到它的状态转移方程，总共有三种情况： j = 0：也就是在第 i 行的最左侧，这个时候只有 (i - 1, 0) 能走到，所以 dp[i][j] = dp[i-1][0] + Triangle[i][0] j = i：也就是在第 i 行的最右侧，这个时候只有 (i - 1, i - 1) 能走到，所以 dp[i][j] = dp[i-1][i-1] + Triangle[i][i] j 0：也就是在中间部分，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + Triangle[i][j] 最后当我们遍历完了 Triangle 之后，只要求 dp[i] 数组的最小元素就好 C++ class Solution { public: int minimumTotal(vector>& triangle) { int n = triangle.size(); vector> dp(n, vector(n)); dp[0][0] = triangle[0][0]; for(int i = 1;i Javascript /** * @param {number[][]} triangle * @return {number} */ var minimumTotal = function(triangle) { let len = triangle.length; let dp = new Array(len).fill(0).map(_=>_ = new Array(len).fill(0)); dp[0][0] = triangle[0][0]; for(let i = 1;i "},"medium/128.html":{"url":"medium/128.html","title":"128. Longest Consecutive Sequence(medium)","keywords":"","body":"128. Longest Consecutive Sequence Leetcode link 解题思路 本题要求我们找出一个给定数组的最长连续元素序列，并要求时间复杂度要是 O(n) 我们考虑到数组中的一个数 x，要求出它的最长连续元素序列，我们会需要一层 O(n) 循环来遍历数组 但是这个 O(n) 的过程也可以用一个哈希表来替代，这样查看一个数是否存在就可以简化成 O(1) 的复杂度 但是即使是这样我们的复杂度在最坏的情况也会达到 所以需要对遍历的元素做一个筛减： 首先如果有一个数 x，那么如果它的 x - 1 存在集合中，我们不需要遍历 如果有一个数 x，如果它的 x + 1 存在集合中，我们需要把它的最长连续元素序列一个个找出来 第二点容易理解，我来说说为什么要有第一点：假定有个数组是 [x, x+1, x+2, x+3, x+4] 那么我们应该都会预期是从 x 开始逐个往 x + 4 来找对吧，如果没有第一条的话，我们对 x+1 ~ x+4 的寻找就是多余的了，所以不应该计算 Javascript /** * @param {number[]} nums * @return {number} */ var longestConsecutive = function(nums) { let res = 0; let set = new Set(); for(let num of nums) { set.add(num); } for(let num of nums) { // 只有在当前数字没有比它小一的数字在集合中时才进入 if(!set.has(num - 1)) { let curNum = num; let curStreakLen = 1; while(set.has(curNum + 1)) { // 寻找集合中比它大一的数字 curNum++; curStreakLen++; } res = Math.max(curStreakLen, res); } } return res; }; "},"medium/138.html":{"url":"medium/138.html","title":"138. Copy List with Random Pointer(medium)","keywords":"","body":"138. Copy List with Random Pointer Leetcode link 解题思路 题目要求我们对有两个指针的链表进行深拷贝，那么我们可以用三个 for 循环依次做以下三件事： 对于每一个链表节点，创建一个新的节点，把旧节点的值给新节点，把新节点的 next 指向旧节点的下一个节点，把旧节点的 next 指向新节点 对于每一个新节点，把新节点的 random 指针指向旧节点的 random 的 next（也就是旧节点的 random 指向的旧节点的新节点） 对于每一个新节点，把 next 指针指向自己的 next->next （也就是旧节点的 next 指向的节点的新节点） C++ class Solution { public: Node* copyRandomList(Node* head) { if (!head) { return NULL; } for (Node* node = head; node; node = node->next->next) { Node* newNode = new Node(node->val); newNode->next = node->next; node->next = newNode; } Node* headNode = head->next; for (Node* node = head; node; node = node->next->next) { Node* newNode = node->next; newNode->random = node->random == NULL ? NULL : node->random->next; } for (Node* node = head; node; node = node->next) { Node* newNode = node->next; node->next = newNode->next; newNode->next = node->next == NULL ? NULL : node->next->next; } return headNode; } }; Javascript var copyRandomList = function(head) { if (!head) { return null; } for (let node = head; node; node = node.next.next) { const newNode = new Node(node.val, node.next, null); node.next = newNode; } const headNode = head.next; for (let node = head; node; node = node.next.next) { const newNode = node.next; newNode.random = node.random === null ? null : node.random.next; } for (let node = head; node; node = node.next) { const newNode = node.next; node.next = newNode.next; newNode.next = node.next === null ? null : node.next.next; } return headNode; }; "},"medium/152.html":{"url":"medium/152.html","title":"152. Maximum Product Subarray(medium)","keywords":"","body":"152. Maximum Product Subarray Leetcode link 解题思路 题目要求我们求乘积最大的连续子数组。 我们需要三个变量： max：保留相乘之后的最大值 min：保留相乘之后的最小值（因为只要之后有负数，这一项可能会变成最大值） res：保留每次循环结束的最大值 算法步骤如下： 循环数组，将数组的元素分别与 max，min 相乘 比较 max，min，数组元素本身，将其中最大值赋值给 max（记得把原来的 max 保存成 temp） 比较 temp，min，数组元素本身，将其中最小值赋值给 min 比较 max 与 res ，将其中最大值赋值给 res 继续步骤 1 直到循环结束 C++ class Solution { public: int maxProduct(vector& nums) { int maximum = 1, minmum = 1, res = nums[0]; for (int num : nums) { maximum *= num; minmum *= num; int temp = maximum; maximum = max({maximum, minmum, num}); minmum = min({temp, minmum, num}); res = res > maximum ? res : maximum; } return res; } }; Javascript var maxProduct = function(nums) { let max = 1, min = 1, res = nums[0]; for(const num of nums) { max *= num; min *= num; // 保存起来，不然有可能本来 max 是最小值最后呗下一行更改了 let temp = max; max = Math.max(max, min, num); min = Math.min(temp, min, num); res = max > res ? max : res; } return res; }; "},"medium/165.html":{"url":"medium/165.html","title":"165. Compare Version Numbers(medium)","keywords":"","body":"165. Compare Version Numbers Leetcode link 题目简介 题目要求我们对比两个只由数字跟 . 构成的版本号 要求从左到右，并忽略小版本号前面的 0 如果 version1 返回 -1 如果 version1 > version2 返回 1 如果 version1 === version2 返回 0 解题思路 我们只需要用 split 将 version 拆分成数组，然后把数组的元素从字符串转换成 number 之后遍历比较就好 Javascript /** * @param {string} version1 * @param {string} version2 * @return {number} */ var compareVersion = function(version1, version2) { const ver1Arr = version1.split('.').map(item => Number(item)) const ver2Arr = version2.split('.').map(item => Number(item)) const ver1Len = ver1Arr.length const ver2Len = ver2Arr.length for(let i=0;i= ver1Len ? 0 : ver1Arr[i] const ver2Val = i >= ver2Len ? 0 : ver2Arr[i] if(ver1Val > ver2Val) { return 1 } if(ver1Val "},"medium/166.html":{"url":"medium/166.html","title":"166. Fraction to Recurring Decimal(medium)","keywords":"","body":"166. Fraction to Recurring Decimal Leetcode link 题目简介 这是道数学相关的题，题目给了分子 numerator 与分母 denominator 两个参数，要求我们返回其小数的表达方式 如果该小数是循环小数，则需要用 () 将循环的部份包裹住 此外题目确保了不会出现无限不循环小数 解题思路 想要解这道题我们需要回归除法的计算方法： 将分子除以分母，获得商与余 如果没有余数，则答案就是商，如果有余数，将答案添加一个小数点，然后余数 *10， 继续除 直到余数为 0 这道题我们也可以用这个思路，区别在于我们需要考虑其他场景： 是否分子有 0 是否两者相除为负数 如何判断出现循环 前两者都好判断，后者的话我们需要用一个 Map 来记录曾经出现过的余数，以及余数除后的商的位置 当我们后续出现了相同的余数，就等于出现了循环，此时我们只需要在之前记录的位置以及当前最后位置加上 () 就好 Javascript /** * @param {number} numerator * @param {number} denominator * @return {string} */ var fractionToDecimal = function (numerator, denominator) { if (numerator === 0) { return '0' } const res = [] // handle negative sign if (numerator "},"medium/167.html":{"url":"medium/167.html","title":"167. Two Sum II - Input Array Is Sorted(medium)","keywords":"","body":"167. Two Sum II - Input Array Is Sorted Leetcode link 解题思路 题目要求我们从一个排序好的数组中找出唯一的两个元素使得相加为 target 因为数组是排序好的，且答案有唯一性，我们可以考虑用双指针来求解 具体来说，我们可以用两个指针 left 与 right 分别指向数组的开头与结尾 当两个指针所指元素之和小于 target，则 left++ 当两个指针所指元素之和大于 target，则 right-- 如果两个指针元素之和等于 target，直接返回 [left + 1, right + 1] C++ class Solution { public: vector twoSum(vector& numbers, int target) { int left = 0, right = numbers.size() - 1; while(left target) { right--; } } return {-1, -1}; } }; Javascript var twoSum = function(numbers, target) { let left = 0, right = numbers.length - 1; while(left target) { right--; } else if(sum "},"medium/173.html":{"url":"medium/173.html","title":"173. Binary Search Tree Iterator(medium)","keywords":"","body":"173. Binary Search Tree Iterator Leetcode link 解题思路 题目给我们一个 BST 的根节点，要求我们写一个能够中序遍历的迭代器。 在没看到题目最后一行要求 O(1) 时间复杂度与 O(h) 空间复杂度的时候，我想的是直接一个先进先出队列加一个中序遍历搞定。 但是限制了空间复杂度之后就只能用折中的方法了： 构造一个方法 particalInorder，依次保存当前节点的最左边枝干 在构造函数调用上述方法 然后在每次 next 执行的时候尝试用当前节点的右节点调用上述方法 hasNext 执行的时候只要判断保存枝干的栈是否为空就好 如此一来，保存枝干的栈就不需要一次把全部的节点都保存进去了。 C++ class BSTIterator { private: // 用来保存枝干的栈 stack s; // 每次只保存最左边的枝干 void partialInorder(TreeNode* node) { while (node != nullptr) { s.push(node); node = node->left; } } public: BSTIterator(TreeNode* root) { partialInorder(root); } int next() { TreeNode* res = s.top(); s.pop(); // 保存当前节点的右节点的左枝干 partialInorder(res->right); return res->val; } bool hasNext() { return !s.empty(); } }; Javascript var BSTIterator = function(root) { this.partialInorder(root) }; /** * @return {number} */ BSTIterator.prototype.next = function() { let res = this.stack.pop(); // 保存当前节点的右节点的左枝干 this.partialInorder(res.right); return res.val; }; /** * @return {boolean} */ BSTIterator.prototype.hasNext = function() { return this.stack.length !== 0; }; // 用来保存当前节点的左枝干 BSTIterator.prototype.partialInorder = function(node) { while(node) { this.stack.push(node); node = node.left; } }; // 用一个栈来保存枝干 BSTIterator.prototype.stack = [] "},"medium/215.html":{"url":"medium/215.html","title":"215. Kth Largest Element in an Array(medium)","keywords":"","body":"215. Kth Largest Element in an Array Leetcode link 解题思路 本题要求我们求出一个数组中第 k 大的数字 一个最简单的方法当然是排序后直接返回下标为 k-1 的数字，但是这样时间复杂度就来到了 O(nlogn) 总所皆知，排序算法在某些情况下是可以来到 O(n) 的复杂度的，那我们有没有办法根据题目的限制来缩小计算范围呢？ 答案是肯定的，我们可以使用快速排序的思想来求解： 快速排序（降序版本）的优点在于，每一次的排序总能确定选中那个数字的排序后下标，且每次排序后，该数字左边必比它大；右边必比它小 套用到这一题，我们只要当快速排序选中的下标刚好等于 k-1 就符合要求了，剩下的部分不需要计算 就算运气不好选中的下标不是 k-1，我们也可以快速定位到下一次快排的范围，进而加速整个算法 C++ class Solution { public: int findKthLargest(vector& nums, int k) { return quickSelect(nums, 0, nums.size()-1, k - 1); } int quickSelect(vector& nums, int left, int right, int index) { // 每次快排结束后检查一下下表是否是 k-1 int position = partition(nums, left, right); if(position == index) { return nums[position]; }else { // 如果不是则可以选取对应的下标范围再做快排 return index & nums, int left, int right) { int num = nums[left]; int i = left + 1; for(int j=left + 1;j num) { swap(nums[i++], nums[j]); } } swap(nums[left], nums[i - 1]); return i-1; } }; Javascript var findKthLargest = function(nums, k) { return quickSelect(nums, 0, nums.length - 1, k - 1); }; var quickSelect = function(nums, left, right, index){ let position = partition(nums, left, right); if(index === position) { return nums[position]; } else { return index > position ? quickSelect(nums, position + 1, right, index) : quickSelect(nums, left, position - 1, index); } } var partition = function(nums, left, right){ let num = nums[left]; let i = left + 1; for(let j = left + 1;j num) { [nums[i], nums[j]] = [nums[j], nums[i]]; i++; } } [nums[left], nums[i - 1]] = [nums[i - 1], nums[left]]; return i-1; } "},"medium/216.html":{"url":"medium/216.html","title":"216. Combination Sum III(medium)","keywords":"","body":"216. Combination Sum III Leetcode link 解题思路 这道题要求我们求 k 个不重复的 1～9 所有可能组合成数字 n 的组合 这种题目我们可以用回溯的方式来做，直接上代码 C++ class Solution { public: vector> res; int k; int n; vector> combinationSum3(int k, int n) { this->k = k; this->n = n; combination(1, {}, 0); return res; } void combination(int start, vector arr, int sum) { if(arr.size()== k) { if(sum == n) { res.push_back(arr); } return; } for(int i = start;i Javascript var combinationSum3 = function(k, n) { let res =[]; var combination = function(start, arr, sum) { // 如果当前组合的数组长度恰好符合 k 个 if(arr.length === k) { // 数组恰好是所求的一种组合 if(sum === n) { res.push(arr); } return; } for(let i= start;i "},"medium/230.html":{"url":"medium/230.html","title":"230. Kth Smallest Element in a BST(medium)","keywords":"","body":"230. Kth Smallest Element in a BST Leetcode link 解题思路 求第 k 小的 BST，核心思路还是在于用中序的优先遍历，当找到第 k 个元素的时候，就是第 k 小的元素 C++ class Solution { private: // 题目规范 BST 元素最小是 0 int res = -1; public: void dfs(TreeNode* node, int& k) { // k left, k); // 找到第 k 小的数之后直接返回 if (--k == 0) { res = node->val; return; } dfs(node->right, k); } int kthSmallest(TreeNode* root, int k) { dfs(root, k); return res; } }; Javascript var kthSmallest = function(root, k) { let res = -1; let count = 0 const dfs = (node, k) => { // count > k 是为了剪枝 if (!node || count > k) { return; } dfs(node.left, k); // 当找到第 k 小的数直接返回 if (++count == k) { res = node.val; return; } dfs(node.right, k); } dfs(root, k); return res; }; "},"medium/284.html":{"url":"medium/284.html","title":"284. Peeking Iterator(medium)","keywords":"","body":"284. Peeking Iterator Leetcode link 解题思路 题目要求我们实现一个可以 peek 的 PeekingIterator。通过继承了一个 Iterator，我们可以使用它的 next 与 hasNext 方法。 为此我们可以用两个变量 nextNum 和 hasNextNum 分别记录当前的对象状态。 这样子 peek 与 hasNext 方法只要直接返回变量即可。 在构造函数与 next 方法中，我们只需要对这两个变量进行单独维护就好。 C++ class PeekingIterator : public Iterator { private: int nextNum; bool hasNextNum; public: PeekingIterator(const vector& nums) : Iterator(nums) { hasNextNum = Iterator::hasNext(); if (hasNextNum) { nextNum = Iterator::next(); } } // Returns the next element in the iteration without advancing the iterator. int peek() { return nextNum; } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. int next() { // preserve current result int res = nextNum; hasNextNum = Iterator::hasNext(); if (hasNextNum) { nextNum = Iterator::next(); } return res; } bool hasNext() const { return hasNextNum; } }; Javascript var PeekingIterator = function(iterator) { this.hasNextNum = iterator.hasNext(); if(this.hasNextNum) { this.nextNum = iterator.next(); } // 保存起来之后 next 需要用到 this.iterator = iterator; }; /** * @return {number} */ PeekingIterator.prototype.peek = function() { return this.nextNum; }; /** * @return {number} */ PeekingIterator.prototype.next = function() { let res = this.nextNum; this.hasNextNum = this.iterator.hasNext(); if(this.hasNextNum) { this.nextNum = this.iterator.next(); } return res; }; /** * @return {boolean} */ PeekingIterator.prototype.hasNext = function() { return this.hasNextNum; }; "},"medium/287.html":{"url":"medium/287.html","title":"287. Find the Duplicate Number(medium)","keywords":"","body":"287. Find the Duplicate Number Leetcode link 解题思路——打标签 TC: O(n) SC: O(1) 本题其中一个约束条件是数组的元素只会在 [1, n] 之间，而且有且只有一个重复元素。 打标签的思路就是：如果把每个元素当成下标来访问数组，那么重复的元素一定会导致其中一个元素被访问到两次，只要我们给访问过的元素打一个标签，之后访问的时候如果遇到这个标签就表示当前当成下标的元素就是重复的元素。 注：这是一个不错的思路，但是违反了题目不可以更改数组的要求，所以下面会提供另一种解法 C++ class Solution { public: int findDuplicate(vector& nums) { int result = -1; for (int i = 0; i Javascript var findDuplicate = function(nums) { let result = -1; for (let i = 0; i Math.abs(num)) return result; }; 解题思路——龟兔赛跑 TC: O(n) SC: O(1) 本题其中一个约束条件是数组的元素只会在 [1, n] 之间，而且有且只有一个重复元素。 也就是说，数组中的元素都可以当成数组的下标来访问其他元素。我们如果顺着这个思路，可以得到一条有环的路径（因为有重复元素），且重复的元素就是环的入口节点 参考 leetcode 官方题解的图示： 那么这道题就变成了：如何寻找有环链表的入口节点 快慢指针的思路，共分为三步： 用两个指针分别从链表头 pHead 出发，快指针一次走两步，慢指针一次走一步。 找出快慢指针相遇节点：如果有环，快慢指针必定相遇，假设相遇点为 p，环的入口节点为 q，pHead 到 q 的距离为 A，q 到 p 的距离为 B，p 到 q 的距离为 C，那么可以得出以下一幅图： 找出入口节点：由上图，我们可以得出一个公式 2(A+B)=A+nB+(n-1)C，其中 n 代表 B 段路径快指针走了 n 次。以上公式化简得 A=(n-2)(B+C)+C。这表示 A 的路径长跟走了 n-2 圈再走一段 C 是一样长的。如果我们分别用两个指针从 pHead 与 p 开始走，那么他们相遇的第一个节点就是环的入口节点 C++ class Solution { public: int findDuplicate(vector& nums) { int fast = nums[0], slow = nums[0]; // 找到相遇的节点 do { fast = nums[nums[fast]]; slow = nums[slow]; } while (fast != slow); // 让快的指针从链表头开始重新走 fast = nums[0]; // 让慢的指针从相遇处开始走 while (fast != slow) { fast = nums[fast]; slow = nums[slow]; } // 当两个指针再次相遇的时候，就是在环的入口节点了 return fast; } }; Javascript var findDuplicate = function(nums) { let fast = nums[0], slow = nums[0]; // 找到相遇的节点 do { fast = nums[nums[fast]]; slow = nums[slow]; } while (fast != slow); // 让快的指针从链表头开始重新走 fast = nums[0]; // 让慢的指针从相遇处开始走 while (fast != slow) { fast = nums[fast]; slow = nums[slow]; } // 当两个指针再次相遇的时候，就是在环的入口节点了 return fast; }; "},"medium/289.html":{"url":"medium/289.html","title":"289. Game of Life(medium)","keywords":"","body":"289. Game of Life Leetcode link 解题思路 本题非常有意思，我特别去找了一下还有对应的游戏，可以迭代出很多有意思的图案，感兴趣的同学可以玩玩看&#x1F606; 本题的难点在于如何在不构造另一个数组的情况下“同步”改变细胞的状态。 突破点在于构造出包含上一代信息的“伪状态”，考虑到题目给出的 int 数组只用了 1 个 bit，我们约定有如下的状态： 第 0 位表示当前的状态，第1位表示下一代的状态（注意这里是 bits） 00: 现在是死的，下一代还是死的 01: 现在是活的，下一代死了 10: 现在是死的，下一代活了 11: 现在是活的，下一代还是活的 接下来我们就遍历数组，把元素与 1 相与 & 就可以得到当前状态，把元素跟 2 相或 | 就可以记录下一代的状态（如果下一代死了就不用管，因为本来就是 0） 最后记得把所有元素右移 >> 一位就能得到下一代的状态了 C++ class Solution { public: // 计算当前活着的邻居 int countLifeNeighbor(vector>& board, int row, int col) { int count = 0; // ↖️ count += (row == 0 || col == 0) ? 0 : board[row - 1][col - 1] & 1; // ⬆️ count += (row == 0) ? 0 : board[row - 1][col] & 1; // ↗️ count += (row == 0 || col == board[0].size() - 1) ? 0 : board[row - 1][col + 1] & 1; // ⬅️ count += (col == 0) ? 0 : board[row][col - 1] & 1; // ➡️ count += (col == board[0].size() - 1) ? 0 : board[row][col + 1] & 1; // ↙️ count += (row == board.size() - 1 || col == 0) ? 0 : board[row + 1][col - 1] & 1; // ⬇️ count += (row == board.size() - 1) ? 0 : board[row + 1][col] & 1; // ↘️ count += (row == board.size() - 1 || col == board[0].size() - 1) ? 0 : board[row + 1][col + 1] & 1; return count; } void gameOfLife(vector>& board) { for (int row = 0; row >= 1; } } } }; Javascript /** * @param {number[][]} board * @return {void} Do not return anything, modify board in-place instead. */ var gameOfLife = function (board) { for (let row = 0; row >= 1; } } }; // 计算当前活着的邻居 function countLifeNeighbor(board, row, col) { let count = 0; // ↖️ count += row === 0 || col === 0 ? 0 : board[row - 1][col - 1] & 1; // ⬆️ count += row === 0 ? 0 : board[row - 1][col] & 1; // ↗️ count += row === 0 || col === board[0].length - 1 ? 0 : board[row - 1][col + 1] & 1; // ⬅️ count += col === 0 ? 0 : board[row][col - 1] & 1; // ➡️ count += col === board[0].length - 1 ? 0 : board[row][col + 1] & 1; // ↙️ count += row === board.length - 1 || col === 0 ? 0 : board[row + 1][col - 1] & 1; // ⬇️ count += row === board.length - 1 ? 0 : board[row + 1][col] & 1; // ↘️ count += row === board.length - 1 || col === board[0].length - 1 ? 0 : board[row + 1][col + 1] & 1; return count; } "},"medium/304.html":{"url":"medium/304.html","title":"304. Range Sum Query 2D - Immutable(medium)","keywords":"","body":"304. Range Sum Query 2D - Immutable Leetcode link 解题思路 本题要求我们实现一个类，这个类包含一个构造函数以及方法 构造函数接收一个二维数组，共有 m * n 个元素，而方法接收二维数组的两个坐标并返回两个坐标构成的矩形内部的元素之和 题目除了核心的方法之外还让我们实现了构造函数，不难看出如果我们善加利用的话，可以显著减少每一次的计算元素和的复杂度 我们考虑构建一个新的二维数组 sum，数组的元素有 (m+1) * (n+1) 个，sum[i][j] 代表从 (0, 0) 到 (i, j) 的元素之和 有了数组 sum 之后，我们不难发现要求下图红色部分面积可以看成：全部着色区块 - 绿色区块 - 蓝色区块 + 蓝色绿色重叠区块 也就是：sum[4][4] - sum[4][2] - sum[2][4] + sum[2][2] C++ class NumMatrix { public: vector> sum; NumMatrix(vector>& matrix) { int m = matrix.size(); int n = matrix[0].size(); sum = vector>(m+1, vector(n+1, 0)); for(int i=1;i Javascript /** * @param {number[][]} matrix */ var NumMatrix = function(matrix) { let m = matrix.length; let n = matrix[0].length; this.sum = new Array(m+1); for(let i=0;i "},"medium/318.html":{"url":"medium/318.html","title":"318. Maximum Product of Word Lengths(medium)","keywords":"","body":"318. Maximum Product of Word Lengths Leetcode link 解题思路 题目要求我们在一个字符串数组中找出字符完全不同的两个字符串使其长度乘积最大 这个题目的难点分为两个部分： 比较两个字符串是否有相同字符 找出符合条件的字符串中乘积最大的答案 比较两个字符串是否有相同字符 因为字符串之可能是英文的小写字母，所以我们可以用一个 int 长度的空间来放它的位掩码，位掩码从右到左依次代表 a 到 z，如果位掩码为 1 则表示该字符有出现 举个例子：abd 可以认为是 1011，aadddef 可以认为是 111001 一旦我们建立了所有字符串的位掩码，就可以通过两两相与是否大于 0 来判断是否有相同字符了 找出符合条件的字符串中乘积最大的答案 这个问题我们直接简单的双重循环来做比较，另外维护一个 res 变量保存最大结果 C++ class Solution { public: int maxProduct(vector& words) { vector bitMasks; for(string &word:words) { int bitMask = 0; for(char &c:word) { bitMask |= 1 0) { continue; } int product = words[i].size() * words[j].size(); res = max(product, res); } } return res; } }; "},"medium/322.html":{"url":"medium/322.html","title":"322. Coin Change(medium)","keywords":"","body":"322. Coin Change Leetcode link 解题思路 题目要求我们计算给出的硬币能构成指定金额的最小数量 这种求极值的问题非常适合用动态规划来求解 我们可以构造一个有 amount + 1 个元素的数组 dp，表示构成 0 ~ amount 金额的最小硬币个数 至于状态转移方程，我们考虑到有一个金额 i，我们可以通过遍历硬币的种类来更新 dp[i] 更新的思路是这样的，当我们遇到一个硬币的金额 coin 小于 i 的时候，i 有两种可能： 不用这个硬币，也就是 dp[i] = dp[i] 用这个硬币，也就是 dp[i] = dp[i - coin] + 1 题目要求我们求最小个数，所以状态转移方程就是 dp[i] = min(dp[i], dp[i - coin] + 1) 最后，我们把 1 ~ amount 金额全部遍历一遍更新 dp 就好了 C++ class Solution { public: int coinChange(vector& coins, int amount) { vector dp(amount+1, amount+1); dp[0] = 0; for(int i=1;i= coin) { dp[i] = min(dp[i], dp[i-coin] + 1); } } } return dp[amount] > amount ? -1 : dp[amount]; } }; Javascript /** * @param {number[]} coins * @param {number} amount * @return {number} */ var coinChange = function(coins, amount) { let dp = new Array(amount+1).fill(amount+1); dp[0] = 0; for(let i = 1;i amount ? -1 : dp[amount]; }; "},"medium/341.html":{"url":"medium/341.html","title":"341. Flatten Nested List Iterator(medium)","keywords":"","body":"341. Flatten Nested List Iterator Leetcode link 解题思路 本题的难点在于要怎么把层层嵌套的 list 摊平 在这里我们可以用递归的思路，具体而言就是写一个辅助函数 flatten 来遍历 nestedList： 如果是整数的话，就保存起来 如果是另一个 list 的话，就把 list 当新的参数递归自己 C++ class NestedIterator { private: vector res; // cpp 为了方便直接给了一个下标辅助遍历结果 int idx=0; public: NestedIterator(vector &nestedList) { flatten(nestedList); } int next() { return res[idx++]; } bool hasNext() { return idx &nestedList) { for(int i=0;i Javascript var NestedIterator = function(nestedList) { this.res = []; flatten(nestedList, this.res); }; function flatten(nestedList, arr) { for(let i=0;i "},"medium/347.html":{"url":"medium/347.html","title":"347. Top K Frequent Elements(medium)","keywords":"","body":"347. Top K Frequent Elements Leetcode link 解题思路——最小堆 TC: SC: 我们可以维护一个 map，来保存数组元素与出现频率，然后再维护一个优先队列构造的最小堆，里面保存了元素从小到大的出现频率 最后再一次遍历把前 k 小的元素丢进数组里就好了 C++ class Solution { public: vector topKFrequent(vector& nums, int k) { unordered_map map; for (int n : nums) { map[n]++; } priority_queue, greater> pq; for (auto& m : map) { pq.push(m.second); // 如果超出 k 个元素，就不保存了，这样能保证优先队列的头一定是第 k 大的 if (pq.size() > k) { pq.pop(); } } vector res; for (auto& m : map) { if (m.second >= pq.top()) { res.push_back(m.first); } } return res; } }; Javascript /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var topKFrequent = function(nums, k) { let map = {} for(let n of nums){ map[n]?map[n]++ : map[n] = 1; } let arr = []; for(let key in map) { arr.push([Number(key), map[key]]); } // 偷懒一下直接用 sort arr.sort((a,b)=>b[1]-a[1]); let res = []; for(let i = 0;i 解题思路——桶排序 TC: SC: 与上面的最小堆一样，我们还是先用一个 map 来统计频率。但是这次不同的是，我们用一个数组，把频率作为下标，依次把元素填进数组里。这样一来只要由后往前遍历，就能依次得到前 k 大高频元素了 C++ class Solution { public: vector topKFrequent(vector& nums, int k) { unordered_map map; for (int n : nums) { map[n]++; } vector> bucket(nums.size() + 1); for (auto& m : map) { bucket[m.second].push_back(m.first); } vector res; for (int i = bucket.size() - 1; i >= 0; i--) { for (int j = 0; j "},"medium/376.html":{"url":"medium/376.html","title":"376. Wiggle Subsequence(medium)","keywords":"","body":"376. Wiggle Subsequence Leetcode link 解题思路 本题要求我们找出一个数组中最长的摆动序列，且允许对数组中的元素进行删除操作 这一题我们可以用贪心的思路来求解 已知一个给定的数组有多个 “峰”（比两边都大的数） 跟多个 “谷”（比两边都小的数），峰跟谷中间也可能会有一些过渡元素 我们的目标就是，把过渡元素全部剔除掉，计算剩余的峰与谷的个数 Javascript /** * @param {number[]} nums * @return {number} */ var wiggleMaxLength = function(nums) { let len = nums.length; if(len 0 && prevDiff =0)) { res++; prevDiff = diff; } } return res; }; "},"medium/399.html":{"url":"medium/399.html","title":"399. Evaluate Division(medium)","keywords":"","body":"399. Evaluate Division Leetcode link 解题思路 题目给了我们一些变量的除法结果，要求我们计算出其他变量的除法结果，如果条件不足就返回 -1.0 我们可以把问题简化一下：把它变成一幅图 equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]] values = [1.5,2.5,5.0] queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]] 把每个变量当成一个节点，节点之间的有向边表示相除的结果，注意节点间的有向边都是双向的，因为回来的边的权重可以用 1 除以出去的边得到。 另外图之间的节点有可能不相连，也有可能成环。 有了图之后，我们就可以用 DFS 或者 BFS 来找出两个边是否相连并且计算结果了（结果可以看成边的权重相乘） C++ class Solution { public: double dfs(unordered_map>> graph, unordered_set visited, string start, string end) { if (graph.find(start) == graph.end() || graph.find(end) == graph.end()) { return -1; } else if (start == end) { return 1; } // 记录已访问的节点，避免图形成环无法跳出 visited.insert(start); for (auto next : graph[start]) { if (visited.count(next.first) == 0) { double res = dfs(graph, visited, next.first, end); if (res != -1) { return res * next.second; } } } return -1.0; } vector calcEquation(vector>& equations, vector& values, vector>& queries) { int n = equations.size(); unordered_map>> graph(n); for (int i = 0; i result; for (auto q : queries) { unordered_set visited; double res = dfs(graph, visited, q[0], q[1]); result.push_back(res); } return result; } }; Javascript /** * @param {string[][]} equations * @param {number[]} values * @param {string[][]} queries * @return {number[]} */ var calcEquation = function(equations, values, queries) { let n = equations.length; let graph = {}; for (let i = 0; i "},"medium/406.html":{"url":"medium/406.html","title":"406. Queue Reconstruction by Height(medium)","keywords":"","body":"406. Queue Reconstruction by Height Leetcode link 解题思路 题目要求我们将输入的二维数组 people 按照特定的规律排序 规律是，数组元素的第一项表示当前的人的身高，第二项表示当前的人的前面有几个比他高或者跟他一样高的人 那么我们的思路就是： 首先先将所有人按照从低到高排序（因为比较低的人并不会影响到高的人的第二项，所以低的人需要优先排序） 其次，如果两个人身高相同，那么在她前面比她高的人多的排在前面（因为第二项比较大的人在身高相同的情况下肯定会比第二项比较小的人更靠后） 综上所述，我们需要对 people[0] 做升序，如果相等，则对 people[1] 做降序 重新排序完数组之后，我们就可以按照排序好的顺序来遍历数组了，具体思路如下： 首先我们需要一个长度为 people.length 的数组 res 然后我们依序遍历数组 people，按照顺序获取当前元素的第二项 k（k 代表了我们要将它放在数组 res 的第 k 个空元素的位置） 接着我们遍历数组 res，找出第 k 个空元素依次放入当前遍历的 people 元素 循环第 2、3 步直到数组遍历完毕，最后的 res 数组就是答案 Javascript /** * @param {number[][]} people * @return {number[][]} */ var reconstructQueue = function(people) { people.sort((a, b) => { if(a[0] === b[0]) { return b[1] - a[1]; } return a[0] - b[0]; }); const res = new Array(people.length).fill(0); for(let person of people) { let pos = person[1]; let space = 0; for(let j = 0;j "},"medium/417.html":{"url":"medium/417.html","title":"417. Pacific Atlantic Water Flow(medium)","keywords":"","body":"417. Pacific Atlantic Water Flow Leetcode link 题目简介 题目给我们一个二维数组 heights 表示一个岛屿，其中每个元素代表岛屿各个位置的高度 该岛屿的北面与西面被太平洋包围；东面与南面被大西洋包围 题目要求下在哪些岛屿的位置的雨水可以同时流到太平洋与大西洋 雨水能从 A 流到 B 只有可能是 A 的高度大于等于 B 的高度 题目要我们返回所有符合条件的坐标的集合 解题思路 这题我们可以从水流入大海之前的最后一个位置开始，一点一点的往回找到水流过的地方 具体来说，我们可以从岛屿的四条与大海接壤的边开始，对边上的格子依次做深度优先遍历 dfs dfs 的终止条件就是当前格子被搜寻过了，或者当前格子比上一个格子低（也就是水无法从当前格子流向上一个格子） 但是由于我们大海有两个，所以我们判断当前格子有没有被搜寻过需要区分是被流进太平洋的水流过，还是被流进大西洋的水流过 所以我们不能用一个简单的 true/false 来判断，我们可以用： 1 代表大西洋 2 代表太平洋 这样一来有两个好处： 判断被哪个洋流过只需要进行一个简单的比特位的与操作就可以了 如果当前格子被流进两个洋的水都流过了，那么它就是 3，如果当前格子为 3 我们就可以将其加入答案之中了 Javascript /** * @param {number[][]} heights * @return {number[][]} */ var pacificAtlantic = function (heights) { const res = [] const width = heights.length const len = heights[0].length // we use 0 for not visited // 1 for visited by Atlantic ocean // 2 for visited by Pacific ocean const ATLANTIC = 1 const PACIFIC = 2 const visited = Array.from({length: width}, _ => new Array(len).fill(0)) const dfs = (x, y, h, mark) => { if (visited[x][y] & mark || heights[x][y] 0) dfs(x - 1, y, heights[x][y], mark) if (x 0) dfs(x, y - 1, heights[x][y], mark) if (y "},"medium/456.html":{"url":"medium/456.html","title":"456. 132 Pattern(medium)","keywords":"","body":"456. 132 Pattern Leetcode link 背景知识 本题要求我们找出一个数组中是否有 “132” 组合，注意是允许不连续的 考虑到时间复杂度，我们把三个数字全部遍历一次肯定会 OT 那么我们可以想一下有没有可能遍历其中一个就可以找到结果呢？答案是可以的，而且有三种方法： 遍历其中的 1，也就是最小的那个数，这样一来我们只要在它的右边找出一对 (j,k)，使得 j>k 就好 遍历其中的 3，也就是最大的数，这样一来，我们得在它的左边找到 “小于它的最小的数“，在它右边找到 ”小于它的最大的数“ 遍历其中的 2，也就是中间的数，思路与方法一差不多，只是变成要在它的左边找一对 (i,j)，使得 i。 解题思路——方法一 我们来讲一下方法一，因为方法一只要在保证 j>k 的条件下，记录最大的 k 拿来跟遍历的数比较就好。 举个例子，现在有一组数组 [3, 4, 6, 4, 3, -1, 6]，我们维护一个单调递减栈，其中存放着比 j 小的同时下标比 j 大的数。 我们从后往前遍历： 数字 6：此时栈为空，我们把它入栈；栈顶为 6 数字 -1：-1 入栈；栈顶为 -1 数字 3：3 > -1，表示它有可能是 j，这个时候我们可以把 k 设置成 “比 j 小的最大值”；在这里，k = -1；把 3 入栈 数字 4：4 > k，表示 4 不符合被当成 \"1\" 的条件；4 > 3，表示它有可能是 j；更新 k 为 3；把 4 入栈 数字 6：6 > 3，不能为 \"1\"；6 > 4，更新 k 为 4；把 6 入栈 数字 4：4 == 4，不能为 \"1\"；4 ，不更新 k；把 4 入栈 数字 3：3 ，可以当成 \"1\"，这下子三个数都找到了，返回 true 注：在找比 j 小的最大值的时候顺便会把栈里面比 j 小的数全部丢掉，因为没用了 下面的表展示了在遍历过程栈与 k 的变化： 数字 栈（栈底 -> 栈顶） k 6 [6] -∞ -1 [6, -1] -∞ 3 [6, 3] -1 4 [6, 4] 3 6 [6, 6] 4 4 [6, 6, 4] 4 3 [6, 6, 4] 4 C++ class Solution { public: bool find132pattern(vector& nums) { // 遍历 \"132\" 中最小的 \"1\" // 单调递减的栈 stack st; // k: \"132\" 中的 \"2\" int k = INT_MIN; for (int i = nums.size() - 1; i >= 0; i--) { // 只有当 k 有被更新过，当前元素才可能小于它（才有可能是 \"1\"），而后面的循环表示 k 要被更新过必须有比 k 大的数在栈中 if (nums[i] st.top())) { k = max(k, st.top()); st.pop(); } // 只要 k 有被更新过，说明这个栈里面必有比 k 大的数 st.push(nums[i]); } return false; } }; Javascript var find132pattern = function(nums) { let stack = []; let k = Number.MIN_SAFE_INTEGER; for(let i=nums.length-1;i>=0;i--) { if(nums[i] stack[stack.length-1]) { k = Math.max(k, stack.pop()); } stack.push(nums[i]); } return false; }; 解题思路——方法三 思路来源：https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/850676 因为觉得思路太好了所以搬运记录一下 这个方法是用了遍历 \"132\" 中的 \"2\"，它可以让我们从前往后遍历，如果今天的数据是流的话就只能用这个方法了 这个方法我们需要维护一个栈，还有一个数组，其中数组 leftMin 保存的是当前元素左边最小的数 我们的目标是找到一个数小于栈顶元素的同时，栈顶元素左边的最小值也小于它就返回 true 一样用 [3, 4, 6, 4, 3, -1, 6] 来做例子吧： 数字 3：目前栈为空，直接把 3 入栈；leftMin[0] = 3 数字 4：4 > 3，表示它不能被当成 j，将 3 出栈，4入栈；leftMin[1] = 3 数字 6：6 > 4，一样将 4 出栈，6入栈；leftMin[2] = 3 数字 4：4 ，表示它有可能是 j，然后我们看一下栈顶元素左边元素最小值是 3，3 ，bingo～ 注：在代码中为了访问方便栈中存放的其实是下标，这里写元素是为了理解方便 下面的表展示了在遍历过程栈与数组的变化： 数字 栈（栈底 -> 栈顶） leftMin 3 [3] [3] 4 [4] [3, 3] 6 [6] [3, 3, 3] 4 C++ class Solution { public: bool find132pattern(vector& nums) { stack st; // 存放当前元素左边最小的数 vector leftMin{INT_MAX}; for (int i = 0; i Javascript var find132pattern = function(nums) { let stack = []; // 存放当前元素左边最小的数 let leftMin = [Number.MAX_SAFE_INTEGER]; for(let i=0;i 0) && (nums[stack[stack.length-1]] 0) && leftMin[stack[stack.length-1]] "},"medium/462.html":{"url":"medium/462.html","title":"462. Minimum Moves to Equal Array Elements II(medium)","keywords":"","body":"462. Minimum Moves to Equal Array Elements II Leetcode link 解题思路 题目要求我们将一个数组中的数字使用最少的操作变成全部一样 根据题目描述，我们要找的肯定是所有数字的中位数了，所以我们只需要对数组排序之后，将每个数字都与中位数相减之后加总就是解答了 Javascript /** * @param {number[]} nums * @return {number} */ var minMoves2 = function(nums) { nums.sort((a, b)=>a-b); let mid = nums[Math.floor(nums.length / 2)] let res = 0; for(let num of nums) { res+= Math.abs(num - mid); } return res; }; 本题的性能优化点在排序算法的使用上，在 215 中，我们对快速排序做了一个改进，使其可以在 O(n) 的复杂度下求解出第 k 小的元素，这一题的思路只是把 215 的第 k 小变成第 num.lenth / 2 小罢了，具体可以参考 215 的代码 "},"medium/474.html":{"url":"medium/474.html","title":"474. Ones and Zeroes(medium)","keywords":"","body":"474. Ones and Zeroes Leetcode link 解题思路 这个题目也太难懂了吧&#x1F92F; 题目要求我们求出一个字符串数组的最长子集，约束条件是最长子集的所有 0 的个数加起来不能超过 m；所有 1 的个数加起来不能超过 n（注意是所有子集合并计算） 很明显是一道动态规划的题目，我们还是需要一个二维数组 dp 数组 dp[i][j] 表示 i 个 0 与 j 个 1 的最长子集 那么状态转移方程是什么呢？我们考虑到有一个字符串的 0 的个数为 zeros，1 的个数为 ones，状态转移方程可以写成： dp[i][j] = max(dp[i][j], dp[i - zeros, j - ones] + 1) 前面的 dp[i][j] 表示不选这个字符串的最长子集，后面表示选择这个字符串之后的最长子集，求其最大值 最后总结一下流程： 首先初始化二维数组 dp 的每一个元素为 0 再来遍历字符串数组 strs，计算每一个字符串的 zeros 跟 ones 接着对 zeros 跟 ones 遍历，更新 dp 数组 返回 dp[m][n] C++ class Solution { public: int findMaxForm(vector& strs, int m, int n) { vector> dp(m+1, vector(n+1, 0)); for(string str:strs) { int zeros = count(str.begin(), str.end(), '0'); int ones = count(str.begin(), str.end(), '1'); for(int i = m;i >= zeros;i--) { for(int j = n;j >= ones;j--) { dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1); } } } return dp[m][n]; } }; Javascript var findMaxForm = function(strs, m, n) { // dp[i][j]: i 个 0，j 个 1 的时候最长子集 let dp = new Array(m+1).fill(0).map(arr=>new Array(n+1).fill(0)); for(let str of strs) { let zeros = (str.match(/0/g) || []).length; let ones = (str.match(/1/g) || []).length; for(let i = m;i >= zeros;i--) { for(let j = n;j >= ones;j--) { dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1); } } } return dp[m][n]; }; "},"medium/535.html":{"url":"medium/535.html","title":"535. Encode and Decode TinyURL(medium)","keywords":"","body":"535. Encode and Decode TinyURL Leetcode link 解题思路 这道题让我们模拟短链接生成算法。这题出的……直接原路返回也能过。 一般而言，短链接生成分为两步： 根据某种规则生成后面的乱序字符串 将乱序字符串与原来的长链接建立映射关系 C++ class Solution { private: unordered_map urlMap; string characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; public: // Encodes a URL to a shortened URL. string encode(string longUrl) { srand(time(NULL)); // 因为测试用例规模就 700 多个，用 4 位字符串已经够了 string tinyUrl = \"http://tinyurl.com/\" + generateRandomStr(4); urlMap[tinyUrl] = longUrl; return tinyUrl; } // Decodes a shortened URL to its original URL. string decode(string shortUrl) { return urlMap[shortUrl]; } string generateRandomStr(int length) { string res = \"\"; while (length--) { int randomIndex = rand() % 62; res += characters[randomIndex]; } return res; } }; Javascript /** * Encodes a URL to a shortened URL. * * @param {string} longUrl * @return {string} */ var encode = function(longUrl) { // 因为测试用例规模就 700 多个，用 4 位字符串已经够了 let tinyUrl = \"http://tinyurl.com/\" + generateRandomStr(4); urlMap[tinyUrl] = longUrl; return tinyUrl; }; /** * Decodes a shortened URL to its original URL. * * @param {string} shortUrl * @return {string} */ var decode = function(shortUrl) { return urlMap[shortUrl]; }; var urlMap = {}; const characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; var generateRandomStr = function(length) { let res = '' while (length--) { let randomIndex = Math.random() % 62; res += characters[randomIndex]; } return res; } /** * Your functions will be called as such: * decode(encode(url)); */ "},"medium/538.html":{"url":"medium/538.html","title":"538. Convert BST to Greater Tree(medium)","keywords":"","body":"538. Convert BST to Greater Tree Leetcode link 解题思路 本题要求我们把一个 BST 的每个节点的值变成节点本身的值加上所有比它大的节点的值 仔细看题目给出的示例，可以看到这个节点的累加过程是 右节点 根节点 左节点 所以我们可以用中序深度优先搜索来做这题，记得维护一个 sum 变量来保存之前累加的值就好 C++ class Solution { private: int sum = 0; public: void dfs(TreeNode* root) { if (!root) { return; } if (root->right) { dfs(root->right); } root->val = sum += root->val; if (root->left) { dfs(root->left); } } TreeNode* convertBST(TreeNode* root) { dfs(root); return root; } }; Javascript var convertBST = function(root) { // 如果用全局变量好像 leetcode 跑测试会有问题，就写进来了 let sum = 0 var dfs = function(root) { if(!root) { return; } if(root.right) { dfs(root.right); } root.val = sum+= root.val; if(root.left){ dfs(root.left); } } dfs(root); return root; }; "},"medium/581.html":{"url":"medium/581.html","title":"581. Shortest Unsorted Continuous Subarray(medium)","keywords":"","body":"581. Shortest Unsorted Continuous Subarray Leetcode link 解题思路——排序 TC: O(n * log(n)) SC: O(n) 本题要求我们找出一个未排序数组的最长已排序连续子数组 既然是这样，那我们可以直接用一个相同的数组，经过排序之后分别从左边跟右边寻找第一个不相同的元素然后计算元素之间的距离就好 C++ class Solution { public: int findUnsortedSubarray(vector& nums) { vector sortedNums(nums); sort(sortedNums.begin(), sortedNums.end()); int left = 0, right = nums.size() - 1; while ((left = 0) && (sortedNums[right] == nums[right])) { right--; } int res = right - left + 1; return res > 0 ? res : 0; } }; Javascript var findUnsortedSubarray = function(nums) { let sortedNums = [...nums]; sortedNums.sort((a,b)=>a-b); let left = 0, right = nums.length - 1; while ((left = 0) && (sortedNums[right] === nums[right])) { right--; } let res = right - left + 1; return res > 0 ? res : 0; }; 解题思路——逻辑 TC: O(n) SC: O(1) 我们也可以用逻辑推导出问题的答案： 首先我们先从左往右找第一个不是升序的元素，从这个元素开始，找出剩余数组的最小值，记为 minimum 然后我们从右往左找第一个不是降序的元素，从这个元素开始，找出剩余数组的最大值，记为 maximun 接着我们从左往右遍历数组，这次的目标是找到第一个比 minimum 大的元素，其下标记作 k 我们再从右往左遍历数组，找到第一个比 maximum 小的元素，其下标记作 l 求 l 与 k 之间的距离，就是我们的答案 C++ class Solution { public: int findUnsortedSubarray(vector& nums) { int maximun = INT_MIN, minimum = INT_MAX; int len = nums.size(); bool flag = false; for (int i = 1; i nums[i]) { flag = true; } if (flag) { minimum = min(nums[i], minimum); } } flag = false; for (int j = len - 2; j >= 0; j--) { if (nums[j] > nums[j + 1]) { flag = true; } if (flag) { maximun = max(nums[j], maximun); } } int k, l; for (k = 0; k minimum) { break; } } for (l = len - 1; l >= 0; l--) { if (nums[l] Javascript var findUnsortedSubarray = function(nums) { let maximun = Number.MIN_SAFE_INTEGER, minimum = Number.MAX_SAFE_INTEGER; let len = nums.length; let flag = false; for (let i = 1; i nums[i]) { flag = true; } if (flag) { minimum = Math.min(nums[i], minimum); } } flag = false; for (let j = len - 2; j >= 0; j--) { if (nums[j] > nums[j + 1]) { flag = true; } if (flag) { maximun = Math.max(nums[j], maximun); } } let k, l; for (k = 0; k minimum) { break; } } for (l = len - 1; l >= 0; l--) { if (nums[l] "},"medium/583.html":{"url":"medium/583.html","title":"583. Delete Operation for Two Strings(medium)","keywords":"","body":"583. Delete Operation for Two Strings Leetcode link 解题思路 本题给定我们两个字符串，要求删除最少的字符使得两个字符串相同 本题考虑动态规划的思考 我们需要一个二维数组 dp，其中 dp[i][j] 表示使 word1 长度为 i 的前缀与 word2 长度为 j 的前缀相同的最少删除操作次数 首先判断边界情况： i = 0：表示 word1 字符串为空，那么对于任意的 j，有 dp[0][j] = j j = 0：表示 word2 字符串为空，呢么对于任意的 i，有 dp[i][0] = i 再来判断 i，j 都大于 0 的情况 word1[i - 1] = word2[j - 1]：加入两个相同的字符，则他们的最少删除数取决于之前的删除个数，换言之 dp[i][j] = dp[i-1][j-1] word1[i - 1] != word2[j - 1]：加入两个不相同的字符，这个时候要判断 dp[i][j - 1] 还是dp[i - 1][j] 哪个比较小，将比较小的那个 +1 综上所述，状态转移方程为： C++ class Solution { public: int minDistance(string word1, string word2) { int len1 = word1.size(); int len2 = word2.size(); vector> dp(len1 + 1, vector(len2 + 1)); for(int i = 1;i Javascript /** * @param {string} word1 * @param {string} word2 * @return {number} */ var minDistance = function(word1, word2) { let len1 = word1.length; let len2 = word2.length; let dp = new Array(len1+1).fill(0).map(_=>_ = new Array(len2+1).fill(0)); for(let i = 1;i "},"medium/611.html":{"url":"medium/611.html","title":"611. Valid Triangle Number(medium)","keywords":"","body":"611. Valid Triangle Number Leetcode link 题目简介 本题给了一个数组 nums 要求我们在数组中任意选取三个数字组成一个三角形，并且求出三个数字的组合有多少种 如果有两个数组元素相等，也视为两个不同的元素 解题思路 要组成三角形的要求就是两边之和大于第三边 我们可以先对数组升序排序，然后我们用下标 k 由后往前遍历数组（从大到小） 遍历的过程中，我们需要用双指针 i, j 来分别指向 0 以及 k-1 接下来我们计算 nums[i] + nums[j] > nums[k] ，有两种可能： true 代表当前组合可以组成三角形，那么我们可以组成三角形的组合数 count 需要加上 j-i 种（因为如果 i 可以组成三角形，比 i 大且比 j 小的数组元素也能够组成三角形） false 代表当前组合无法组成三角形，那么我们可以将 i++ 来寻找更大的数组元素 当我们完成下标 k 的遍历时，组合数 count 就是答案 Javascript /** * @param {number[]} nums * @return {number} */ var triangleNumber = function(nums) { let count = 0 nums.sort((a, b) => a - b) for(let k = nums.length - 1;k>=0;k--) { let i = 0, j = k - 1 while(i nums[k]) { count += j - i j-- } else { i++ } } } return count }; "},"medium/633.html":{"url":"medium/633.html","title":"633. Sum of Square Numbers(medium)","keywords":"","body":"633. Sum of Square Numbers Leetcode link 解题思路 本题目给到我们一个正整数 c，要求我们找出是否有正整数 a，b 符合等式：a^2 + b^2 = c 一个简单的想法就是用两个指针 a，b 往中间夹紧遍历，如果直到 a>b 还没找到，那么就可以返回 false 了 a 一般从 0 开始（因为不能排除有 b^2 = c 的可能性） b 则从 sqrt(c) 开始（因为 b 最大的情况就刚好是 c 开根号） Javascript /** * @param {number} c * @return {boolean} */ var judgeSquareSum = function(c) { let a = 0; let b = Math.floor(Math.sqrt(c)); while(a "},"medium/647.html":{"url":"medium/647.html","title":"647. Palindromic Substrings(medium)","keywords":"","body":"647. Palindromic Substrings Leetcode link 解题思路——回文特性 题目要求我们求一个字符串中回文子字符串的个数 首先我们分析一下要达成回文有哪些可能： aba 形式：也就是由奇数个字符组成，除了中间的那个之外其他的两两相同 aa 形式：由偶数个字符组成，两两相同 至此，我们可以通过遍历输入的字符串并分别判断以上两种可能性来计算回文子字符串的个数 C++ class Solution { public: int countSubstrings(string s) { int res = 0; for(int i = 0;i=0 && right =0 && right Javascript var countSubstrings = function(s) { let res = 0; for(let i=0;i=0 && right = 0 && right 解题思路——DP 这题也可以用动态规划来解 首先我们把二维数组 dp[i][j] 定义为下标从 i 到 j 的字符串是否能构成回文 接下来，我们使用两个指针 i 跟 j，来遍历字符串 什么情况会构成回文呢？首先 s[i] == s[j] 是所有的大前提，满足这个前提之下有三种可能： i 跟 j 中间只有一个字符 i 跟 j 是相邻的 dp[i+1][j-1] 能构成回文 详情看代码： C++ class Solution { public: int countSubstrings(string s) { int res = 0; int len = s.size(); vector> dp(len, vector(len, false)); for(int i = len-1;i>=0;i--) { for(int j = i;j Javascript var countSubstrings = function(s) { let res = 0; let len = s.length; let dp = new Array(len); for(let i=0;i=0;i--) { for(let j = i;j "},"medium/665.html":{"url":"medium/665.html","title":"665. Non-decreasing Array(medium)","keywords":"","body":"665. Non-decreasing Array Leetcode link 解题思路 题目给定一个数组 nums，要求我们判断在对多改变一个元素的情况下是否能将该数组变为升序（包含相等） 本题的关卡有两个： 在满足题目的要求下最多能有几个非升序的元素呢？ 一个 在发现有非升序的元素 nums[i] 时，应该如何改变元素呢？ 第一种情况 nums[i + 1] ：这种情况需要将 nums[i + 1] 变为 nums[i] 第二种情况 nums[i + 1] >= nums[i - 1]：这种情况需要将 nums[i] 变为 nums[i + 1] C++ class Solution { public: bool checkPossibility(vector& nums) { bool flag = false; for(int i = 0;i y) { if(flag) { return false; } flag = true; if(i >0 && y Javascript /** * @param {number[]} nums * @return {boolean} */ var checkPossibility = function(nums) { let flag = false; for(let i = 0;i y) { // 只允许更改一次 if(flag) { return false; } flag = true; // 第一种情况 if(i>0 && y "},"medium/669.html":{"url":"medium/669.html","title":"669. Trim a Binary Search Tree(medium)","keywords":"","body":"669. Trim a Binary Search Tree Leetcode link 解题思路 本题要求我们给 BST 剪枝， 可以用 dfs 的思想递归。 考虑到有两种情况： 如果当前节点小于 low，则返回当前节点的右边子节点 如果当前节点大于 high，则返回当前节点的左边子节点 接下来就可以针对 root->left 与 root->right 来递归了 C++ class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { if (!root) { return nullptr; } if (root->val right, low, high); } else if ((root->val > high)) { return trimBST(root->left, low, high); } root->left = trimBST(root->left, low, high); root->right = trimBST(root->right, low, high); return root; } }; Javascript var trimBST = function(root, low, high) { if(!root) { return null; } if(root.val high) { return trimBST(root.left, low, high); } root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; }; "},"medium/769.html":{"url":"medium/769.html","title":"769. Max Chunks To Make Sorted(medium)","keywords":"","body":"769. Max Chunks To Make Sorted Leetcode link 题目简介 本题给了我们一个数组，要求我们对其分块后进行升序排列（分块就是将其拆分成任意长度的数组），要求分块后合并的排序结果要跟一开始的数组排序结果保持一致 解题思路 在题目的约束中，我们能够完成分块，有一个主要的原则：每个分块中，最小的数字必须在最后面，否则都能从该分块中拆出符合题目要求的别的分块来 基于这个原则我们来看一个例子：[0,1,4,3,2,5,6] 我们不难看出，这个例子最多能拆出 5 个分块：[0], [1], [4,3,2], [5], [6] 所以这题的难点在于要怎么把 [4,3,2] 这种情况判断出来 有意思的是，题目的限制给了我们线索，其中最关键的有两条： - 0 - 数组中任何数字都是唯一的 这两条告诉我们，数组的下标与数字是一一对应的 那么，我们只需要遍历数组，一旦数组当前遍历下标的和与数组当前遍历值的和相等时，则表示可以分块 拓展一下，如果没有这两个条件我们该怎么做？ 将原数组深拷贝成一个新数组，并将其排序 同时遍历新数组与原数组 一旦他俩遍历过元素的和相等，则表示可以分块 Javascript /** * @param {number[]} arr * @return {number} */ var maxChunksToSorted = function (arr) { let indexSum = 0 let valueSum = 0 let trunk = 0 for (let i = 0; i "},"medium/785.html":{"url":"medium/785.html","title":"785. Is Graph Bipartite?(medium)","keywords":"","body":"785. Is Graph Bipartite? Leetcode link 背景介绍 很调皮的一个题目 文字说明也很难懂。。。 简单来说题目提供一个二维数组，graph[0] 代表与第 0 个元素有无向边的元素集合，且每个两个元素之间最多有一条边，也有可能没有边 题目要求我们判断这个图是不是二分图：也就是能把图分成两个不相交的集合，使得同一集合的顶点之间不相连 解题思路——染色 我们把图染色，染色规则是：有边的两个点不能染同一个颜色 因为是二分图，所以我们的颜色有三种状态：0 表示未染色、1, -1分别代表两种不同颜色 一旦发现有两个相邻的元素被染了同一个颜色，表示这个图不是二分图，返回 false C++ class Solution { public: bool isBipartite(vector>& graph) { int n = graph.size(); vector colors(n); for (int i = 0; i >& graph, int color, int index, vector& colors) { if (colors[index] != 0) { return colors[index] == color; } colors[index] = color; for (int i : graph[index]) { if (!valid(graph, -color, i, colors)) { return false; } } return true; } }; Javascript /** * @param {number[][]} graph * @return {boolean} */ var isBipartite = function(graph) { let n = graph.length; let colors = new Array(n).fill(0); for (let i = 0; i 解题思路——并查集 与前面的染色思路相近，我们把连接到同一个节点的节点集合划分到一个组：graph[0] 是一个组，graph[1] 也是一个组。。。 接下来，我们只需要判断同一个组里的元素是否有相邻就好，如果有，则不是二分图 举个例子： graph[0] 的元素跟元素 0 如果在同一个组，则表示这个图不是二分图 C++ class UnionFind { private: vector root; vector rank; public: UnionFind(int size) : root(size), rank(size) { for (int i = 0; i = rank[rootY]) { root[rootY] = rootX; rank[rootX] += rank[rootY]; } else { root[rootX] = rootY; rank[rootY] += rank[rootX]; } } } }; class Solution { public: bool isBipartite(vector>& graph) { int n = graph.size(); UnionFind uf(n); for (int i = 0; i JS class UnionFind { constructor(size) { this.root = new Array(size); this.rank = new Array(size); for (let i = 0; i = this.rank[rootY]) { this.root[rootY] = rootX; this.rank[rootX] += this.rank[rootY]; } else { this.root[rootX] = rootY; this.rank[rootY] += this.rank[rootX]; } } } }; var isBipartite = function(graph) { let n = graph.length; let uf = new UnionFind(n); for (let i = 0; i "},"medium/820.html":{"url":"medium/820.html","title":"820. Short Encoding of Words(medium)","keywords":"","body":"820. Short Encoding of Words Leetcode link 解题思路 本题要求我们将一个字符串数组编码为一个用 # 区隔的长字符串 根据题目的描述，我们的出一个结论：当一个字符串是另一个字符串的后缀时，可以忽略它的长度 根据这个结论，我们可以使用字典树这个数据结构来求解 具体而言，我们可以用字符串倒叙的方式来组织字典树，举个例子： 数组 words 有两个元素 ['time', 'me', 'abe', 'el', bell]，按照字符串倒叙来组织字典树之后如下图所示 我们在组织完字典树的时候，顺便用变量 count 记录一下当前节点有多少子节点，比如 'me' 的 m 就有两个子节点 最后我们只需要判断 count 为 0 的字符串长度加一的总和就是我们的答案了 C++ class TrieNode { TrieNode* children[26]; public: int count; TrieNode() { for(int i = 0;i & words) { TrieNode* trie = new TrieNode(); unordered_map nodes; for(int i = 0;i = 0;j--) { cur = cur->add(word[j]); } nodes[cur] = i; } int res = 0; for(auto& [node, idx]: nodes) { if(node->count == 0) { res += words[idx].size() + 1; } } return res; } }; "},"medium/826.html":{"url":"medium/826.html","title":"826. Most Profit Assigning Work(medium)","keywords":"","body":"826. Most Profit Assigning Work Leetcode link 解题思路 本题题目有点难懂，而且中间有个小坑，我先来重新描述一下题目的要求： 首先题目规定了总共有 m 份工作与 n 个工人，并且给定了 difficulty，profit，worker 三个数组，其中： difficulty 代表工作的难度，限制长度为 m，与 profit 数组一一对应 profit 代表工作的报酬，限制长度为 m，与 difficulty 数组一一对应 worker 代表工人的技能水平，限制长度为 n 此外，题目还给了两个限制： 一个工人只能做一次工作，并且做的工作难度不能超过工人自身的技能水平（也就是 worker 数组的对应值） 一个工作可以被多个工人多次完成，并且报酬可以累加 题目要求在这些条件下，计算出所有工人可以获得最高利润的工作分配方法。 在题目中包含的内容只有这么多，但是在实际的测试 case 中，其实还有一个情况是题目忽略的： 相同难度的工作可能有多份，并且其报酬可能不唯一 了解了上述的要求之后，为了使利润最大化，我们需要让每一个工人做能力范围内利润最高的工作，那么我们需要遵循如下步骤： 先使用一个 Map 把所有工作的难度与利润一一对应起来（为了第二步排序之后还能保留对应关系） 给所有的工作难度从小到大排序 根据难度的排序遍历 Map，给所有难度对应的利润调整成：当前难度的工作所能获得的最高利润 遍历所有工人的能力，找出能力范围能获得的最高利润进行加总 Javascript /** * @param {number[]} difficulty * @param {number[]} profit * @param {number[]} worker * @return {number} */ var maxProfitAssignment = function(difficulty, profit, worker) { let result = 0; const difficulty2Profit = new Map(); for(let i=0;i profit[i]) continue; } difficulty2Profit.set(difficulty[i], profit[i]); } // sort the difficulty in ascending order difficulty.sort((a, b)=> a-b); // get the maximum profit base on previous difficulty for(let i=1;i curProfit) { difficulty2Profit.set(difficulty[i], prevProfit); } } // Calcutale the maximum profit for(let i=0;i=0;j--) { if(worker[i] >= difficulty[j]) { result += difficulty2Profit.get(difficulty[j]); break; } } } return result; }; "},"medium/912.html":{"url":"medium/912.html","title":"912. Sort an Array(medium)","keywords":"","body":"912. Sort an Array Leetcode link 题目简介 题目要求我们给数组升序排列，要求 nlogn 的时间复杂度以及不能使用内置排序方法 解题思路 直接快排秒了 Javascript /** * @param {number[]} nums * @return {number[]} */ var sortArray = function(nums) { return nums.quickSort(); }; Array.prototype.quickSort = function (left = 0, right = this.length - 1) { if (left >= right) { return this; } let i = left - 1; let j = right + 1; const pivot = this[Math.floor((i + j) / 2)]; while (i pivot); if (i "},"medium/923.html":{"url":"medium/923.html","title":"923. 3Sum With Multiplicity(medium)","keywords":"","body":"923. 3Sum With Multiplicity Leetcode link 解题思路 TC: ， M 是数组 arr 中最大的数 SC: ，M 是数组 arr 中最大的数 题目要求我们找出三个数之和为 target 的多种可能，且数组 arr 可能存在重复数字 我们可以观察一下题目给出的范围： 3 0 0 可能出现的数字范围 arr[i] 从 0 到 100，那么我们可以用 count[x] 来保存数字 x 在数组中出现的次数，对于每一个 x + y + z = target 组合，我们用数学方法来分析几种可能性的组合： x != y != z：有 种组合 x == y != z：有 种组合 x == y == z：有 种组合 x == y == z：有 种组合 最后把上述所有可能加总取模就好了。 C++ class Solution { public: int threeSumMulti(vector& arr, int target) { int MOD = 1e9 + 7; long res = 0; long count[101] = {0}; for (int num : arr) { count[num]++; } // x != y != z for (int x = 0; x = 0 && x Javascript /** * @param {number[]} arr * @param {number} target * @return {number} */ var threeSumMulti = function(arr, target) { const MOD = 1e9 + 7; let res = 0; let count = new Array(101).fill(0); for (let num of arr) { count[num]++; } // x != y != z for (let x = 0; x = 0 && x "},"medium/966.html":{"url":"medium/966.html","title":"966. Vowel Spellchecker(medium)","keywords":"","body":"966. Vowel Spellchecker Leetcode link 题目简介 题目给我们两个参数： wordlist：一个字符串数组，表示我们有的字典 queries：一个字符串数组，表示我们要用来查询字典的字符串 由于 queries 中的字符串可能会出现一些母音字母的笔误，所以我们需要设计一个算法来输出每一个查询字符串的正确字符串 输出字符串的规则如下： 如果查询字符串在大小写敏感的情况下完全符合字典的某个字符串，直接返回该字符串 如果查询字符串在大小写不敏感的情况下符合字典某个字符，返回字典出现的第一个对应的字符串 如果查询字符串某些母音字符误写成了其他的母音字符（允许大小写不敏感），返回字典出现的第一个对应字符串 如果以上都不成立，则返回空字符串 解题思路 根据上述规则，我们能很快写出一个该逻辑的算法，但是直接写出来的算法复杂度会是 $O(W \\times Q \\times N)$ 其中 W 代表 wordlist.length，Q 代表 queries.length，N 代表所有 wordlist 字符串的平均长度 所以我们需要采取一些空间换时间的策略 这个策略分成两个部分：数据预处理、查询 数据预处理 首先为了应对第一种情况，我们可以将 wordlist 用一个 Set 保存，这种情况下我们查找任意一个 Query 的复杂度是 $O(1)$ 其次为了应付第二种情况，我们可以用一个 Map 来保存所有字典字符串到全小写字典字符串的映射 第三种情况也是可以用一个 Map 来保存所有字典字符串到归一化母音字符串（把字符串中的母音字符都用一个符号代替）的映射 这个部份的时间复杂度是 $O(W \\times N)$、空间复杂度是 $O(W \\times N)$ 查询 我们只需要遍历 queries 分别在 Set 与两个 Map 中寻找符合条件的字符就好 这个部份的时间复杂度是 $O(Q \\times N)$ 这样一来我们的算法时间复杂度就降低到了 $O((Q + W) \\times N)$ Javascript /** * @param {string[]} wordlist * @param {string[]} queries * @return {string[]} */ var spellchecker = function(wordlist, queries) { const wordSet = new Set(wordlist) const caseInsensitiveMap = new Map() const vowelInsensitiveMap = new Map() const res = [] const equalizeVowels = word => word.toLowerCase().replace(/[aeiou]/g, '@') wordlist.forEach(word => { const lowerCaseWord = word.toLowerCase() if(!caseInsensitiveMap.has(lowerCaseWord)) { caseInsensitiveMap.set(lowerCaseWord, word) } const equalVowelWord = equalizeVowels(word) if(!vowelInsensitiveMap.has(equalVowelWord)) { vowelInsensitiveMap.set(equalVowelWord, word) } }) for(const q of queries) { // 1. exactly match if(wordSet.has(q)) { res.push(q) continue } // 2. case-independant match const lowerCaseQuery = q.toLowerCase() if(caseInsensitiveMap.has(lowerCaseQuery)) { res.push(caseInsensitiveMap.get(lowerCaseQuery)) continue } // 3. vowel error match const equalVowelQuery = equalizeVowels(q) if(vowelInsensitiveMap.has(equalVowelQuery)) { res.push(vowelInsensitiveMap.get(equalVowelQuery)) continue } // 4. no match res.push('') } return res }; "},"medium/1029.html":{"url":"medium/1029.html","title":"1029. Two City Scheduling(medium)","keywords":"","body":"1029. Two City Scheduling Leetcode link 解题思路 题目叫我们把一半的人安排到 a 市，一半的人安排到 b 市，那我们可以针对去 a 市的成本 aCost 与去 b 市的成本 bCost 求差值之后升序排序来确定去 a 市的名单，剩下的一半则是去 b 市的名单。 使用 aCost - bCost 之后由小到大排序是因为当去 a 市的成本与去 b 市的成本少的越多（差值越大）很显然我们应该优先安排该候选人去 a 市（机会成本更小一点） C++ bool comparator(vector &a, vector &b) { if (a[0] - a[1] > &costs) { // 排序 sort(costs.begin(), costs.end(), comparator); int result = 0, n = costs.size() / 2; // 只遍历一半的 vector，前面的一半去 a 市，后面的一半去 b 市 for (int i = 0; i Javascript /** * @param {number[][]} costs * @return {number} */ var twoCitySchedCost = function(costs) { costs.sort((a,b)=> (a[0]-a[1]) - (b[0]-b[1])); let result = 0, len = costs.length / 2; for(let i=0;i "},"medium/1039.html":{"url":"medium/1039.html","title":"1039. Minimum Score Triangulation of Polygon(medium)","keywords":"","body":"1039. Minimum Score Triangulation of Polygon Leetcode link 题目简介 题目给我们一个参数数组 values 代表一个凸多边形的顶点集合，数组的顺序代表了多边形沿顶点顺时针的顶点的价值 题目要求我们对多边形进行三角剖分（将其分割成多个三角形）剖分出的三角形的价值是三个顶点价值的乘积 最后我们需要求出所有三角形价值之和最小的值是多少 解题思路 这一题需要慢慢推导，我们先从三角形开始：假设一开始题目给了三个顶点 [1,2,3] 则这个三角形的价值就是三个顶点相乘，也就是 6 接下来是正方形 [3,7,4,5]： 3--7 | | 5--4 我们可以选取相邻的两个点 [3, 5] 他们会组成一条边，基于这条边，我们可以再任意选取一点（假设是 7） 此时我们可以将正方形剖分成两个三角形：[3, 5, 7]，[5, 7, 4] 此时我们已经将问题拆分成了处理三角形的模式 接下来我们来看看正五边形： 1 / \\ 5 2 \\ / 4-3 我们一样可以选取相邻的两个点 [1, 5]，基于这条边我们再任意选取一个点（假设是 3） 此时我们可以将正五边形拆分成一个三角形 [1, 5, 2] 以及一个四边形 [5, 2, 3， 4] 其中三角形我们可以用一开始的方式来处理、四边形也可以继续用上面方式处理…… 看到规律了吧！ 接下来我们来聊聊怎么构建这个算法 这个算法的初始是由两个点组成的，我们可以使用一个二维数组 dp[i][j] 来表示点 [i, j] 组成的边进行剖分之后的价值 这两个点我们选择数组的第一个以及最后一个元素（因为这样一来我们可以通过 j-i 来判断剩下的点是否可以组成三角形） 然后我们需要构建一个 helper 函数使用递归的方式慢慢剖分多边形 Javascript /** * @param {number[]} values * @return {number} */ var minScoreTriangulation = function (values) { const len = values.length const dp = new Array(len).fill().map(item => new Array(len).fill(0)) return helper(dp, values, 0, len - 1) }; const helper = (dp, values, i, j) => { // cannot form triangles if (j - i "},"medium/1048.html":{"url":"medium/1048.html","title":"1048. Longest String Chain(medium)","keywords":"","body":"1048. Longest String Chain Leetcode link 解题思路 本题要求我们求出给定字符串数组的最长词链；词链中每一个元素都是后一个元素的前身；前身指的是在给定字符串不改变顺序的情况下删除任意一个字符构成的新字符串 首先，由于词链中元素的长度一定是从小到大且每个元素长度都是前一个长度加一，所以我们需要先对 words 排序 排完序之后，我们考虑动态规划的方法，创建一个数组 dp，其中 dp[i] 表示排序后的 words 数组中第 i 个元素的最长词链长度 有了 dp 之后，我们可以方便的得出，假设有个新字符串 words[j]，且它是 words[i] 的前身，则 dp[i] = max(dp[i], dp[j] + 1) 最后，如果字符串 a 是 b 的前身，要满足两个条件： a 的长度只能是 b 的长度减一 a 中的字符必须按顺序出现在 b 中 C++ class Solution { public: int longestStrChain(vector& words) { sort(words.begin(), words.end(), [](const string& a, const string& b){ return a.size() dp(len, 1); int res = 1; for(int i = 0;i = 0;j--) { if(isPredecessor(words[j], words[i])) { dp[i] = max(dp[i], dp[j] + 1); } } res = max(res, dp[i]); } return res; } bool isPredecessor(const string& s1, const string& s2) { if(s1.size() != s2.size() - 1) { return false; } int i = 0; for(int j = 0;j Javascript /** * @param {string[]} words * @return {number} */ var longestStrChain = function (words) { words.sort((a, b) => a.length - b.length); let len = words.length; let dp = new Array(len).fill(1); let res = 1; for (let i = 1; i = 0; j--) { if (isPredecessor(words[j], words[i])) { dp[i] = Math.max(dp[i], dp[j] + 1); } } res = Math.max(dp[i], res); } return res; }; var isPredecessor = function (str1, str2) { // predecessor 最多允许少一个字符 if (str1.length !== str2.length - 1) { return false; } let i = 0; for (let j = 0; j "},"medium/1052.html":{"url":"medium/1052.html","title":"1052. Grumpy Bookstore Owner(medium)","keywords":"","body":"1052. Grumpy Bookstore Owner Leetcode link 解题思路 本题题目说的有点模糊，我简单用自己的语言描述一下题意 题目给了我们三个参数： customers：Array，代表在第 n 分钟进来的客人数量，所有的客人都会一直呆到关门 grummpy：Array，取值为 0 或 1，0 代表店主脾气很好，此时客人会很满意；1 代表此时店主脾气暴躁，此时进来的客人会很不满（但是不会离开，也不会影响之前或之后进来的客人） minutes：Number，店主得到高人指点，习得了抑制脾气的方法（参考班纳压抑绿巨人的情况）但是这个方法只能持续一段固定的连续时间，这段时间的长度就是 minutes 题目要求我们求店主最多能让多少顾客满意 这一题最主要的思路就是把固定的部分与变化的部分分开计算： 固定的部分：指的是店主脾气好的时候进来的客人，这一组客人始终都是满意的 变化的部分：值得是店主脾气不好的时候进来的客人，这一部分客人的满意度取决于店主有没有在这个时间段使用技巧 固定的部分很好计算，只要把 grumpy 是 0 的时间段进来的客人数量全部加起来就好 变化的部分就需要用到滑动窗口来求解了，我们把 minutes 的长度当成窗口，通过窗口的滑动来计算每一个窗口能让本来不满意的顾客（grumpy 为 0 的时候进来的顾客）满意的数量，最后求所有可能的最大值就好 为了方便理解，我写了两个版本，第一个版本用到了两次循环，更加方便理解；第二个版本直接把两个循环合在一起了，复杂度降低胃了 O(n) Javascript——方便理解版 /** * @param {number[]} customers * @param {number[]} grumpy * @param {number} minutes * @return {number} */ var maxSatisfied = function (customers, grumpy, minutes) { // calculate the initial satisfication for all customers let initSatisfication = 0; for (let i = 0; i Javascript——时间复杂度 O(n) 版 /** * @param {number[]} customers * @param {number[]} grumpy * @param {number} minutes * @return {number} */ var maxSatisfied = function (customers, grumpy, minutes) { // use for sliding window let left = 0, right = 0; // satisfication without technique let initSatisfication = 0; // satisfication using technique let extra = 0, maxExtra = 0; while (right = minutes - 1) { maxExtra = Math.max(extra, maxExtra); } right++; } return initSatisfication + maxExtra; } "},"medium/1091.html":{"url":"medium/1091.html","title":"1091. Shortest Path in Binary Matrix(medium)","keywords":"","body":"1091. Shortest Path in Binary Matrix Leetcode link 解题思路 题目要求我们从给定的一个 n*n 的格子里面找出一条最短的从左上角到右下角的路径（这个路径只能由 0 构成且可以往 8 个方向走） 这种题目可以用 bfs 来做，我们把起始点当成第一层，起始点能到的地方当成第二层，以此类推 每次都遍历完同一层之后再遍历下一层，这样一来，只要碰到了右下角的格子，当前的层数就是我们要的最短路径长 C++ class Solution { public: int shortestPathBinaryMatrix(vector>& grid) { int size = grid.size(); int level = 0; queue> q; vector> visited(size, vector(size, false)); if(grid[0][0] == 0) { q.push({0, 0}); visited[0][0] = true; } while(!q.empty()) { level++; int n = q.size(); for(int i = 0;i node = q.front(); q.pop(); int x = node.first, y = node.second; if(x == size-1 && y == size-1) { return level; } for(int j = x-1;j>& grid, vector> &visited) { int size = grid.size(); return x>=0 && x = 0 && y Javascript /** * @param {number[][]} grid * @return {number} */ var shortestPathBinaryMatrix = function (grid) { let size = grid.length; // 记录当前元素访问状态 let visited = new Array(size); for (let i = 0; i 0) { let len = queue.length; level++; for (let i = 0; i = 0 && y >= 0 && x "},"medium/1110.html":{"url":"medium/1110.html","title":"1110. Delete Nodes And Return Forest(medium)","keywords":"","body":"1110. Delete Nodes And Return Forest Leetcode link 解题思路 本题要求我们 “去除” 二叉树中的某些点，然后按照任意顺序返回剩余的根结点们（就有点像是把一棵树砍了然后把树枝重新种下的感觉） 本题的难点主要在于，我们要怎么在遍历二叉树的同时把对应节点的引用处理好 首先我们会需要一个遍历函数 delNode，我们采取迭代的方式遍历 在遍历中，我们需要判断当前节点是否需要被删除： 如果不需要则正常遍历 如果需要，则要给当前节点的父节点返回 null；然后，在遍历到当前节点的子节点时，需要把他们加到返回的数组中 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number[]} to_delete * @return {TreeNode[]} */ var delNodes = function(root, to_delete) { const result = []; const delNode = (node, isRoot) => { if(!node) return null; // 判断当前节点是否需要被删除 const shouldDel = to_delete.includes(node.val); // 如果当前节点的上个节点被删除，且当前节点需要保留，则判断当前节点是一个新的根结点，需要返回 if(isRoot && !shouldDel) { result.push(node); } // 正常遍历 node.left = delNode(node.left, shouldDel); node.right = delNode(node.right, shouldDel); // 如果当前节点被删除了，需要给当前节点父节点返回 null return shouldDel ? null : node; } delNode(root, true); return result; }; "},"medium/1190.html":{"url":"medium/1190.html","title":"1190. Reverse Substrings Between Each Pair of Parentheses(medium)","keywords":"","body":"1190. Reverse Substrings Between Each Pair of Parentheses Leetcode link 解题思路 题目要求我们翻转括号内的字符串 这一题的关键在于，如何处理三种不同的情况： 遇到 (：我们需要维护一个栈，把 ( 之前的字符串存起来 遇到 )：把之前遍历过的 ( 之后的字符串翻转一次，并且从栈顶拿到字符串拼接到反转后的字符串前 遇到一般字符：用一个字符串变量保存起来 Javascript /** * @param {string} s * @return {string} */ var reverseParentheses = function(s) { const stack = []; let result = ''; for(const c of s) { switch(c) { case '(': stack.push(result); result = ''; break; case ')': result = result.split('').reverse().join(''); const lastStr = stack.pop(); if(lastStr) { result = lastStr + result; } break; default: result = result + c; } } return result; }; "},"medium/1202.html":{"url":"medium/1202.html","title":"1202. Smallest String With Swaps(medium)","keywords":"","body":"1202. Smallest String With Swaps Leetcode link 解题思路 题目给了我们一个字符串，并且给了多个可以多次交换的字符串下标，要求我们经过一连串交换之后返回字典序最小的字符串。 首先我们需要知道一件事：交换是有传递性的。 也就是说，如果有可交换下标 [a,b] 与[b,c]，那么 a 与 c 也是可以交换的（通过 b） 所以，我们可以把所有可以互相交换的字符下标收集起来，称为一个组。 将所有的字符下标都收集完了之后，我们对每个组内都以字典序排序，然后按照顺序放回原来在的下标，就是题目所求了。 针对上面的思路，我们使用并查集数据结构。 C++ class UnionFind { private: vector root; vector rank; public: UnionFind(int size) : root(size), rank(size) { for (int i = 0; i = rank[rootY]) { root[rootY] = rootX; rank[rootX] += rank[rootY]; } else { root[rootX] = rootY; rank[rootY] += rank[rootX]; } } } }; class Solution { public: string smallestStringWithSwaps(string s, vector>& pairs) { int n = s.size(); UnionFind uf(n); // 给所有字符分组（保存下标） for (auto& edge : pairs) { uf.unionSet(edge[0], edge[1]); } // 建立组长->组员的映射（保存下标） unordered_map> groups; for (int i = 0; i indics = group.second; // 把每一组的成员按照字典顺序排列 vector chars; for (int index : indics) { chars.push_back(s[index]); } sort(chars.begin(), chars.end()); // 把排列好的字符放回对应的位置 for (int i = 0; i Javascript class UnionFind { constructor(size) { this.root = new Array(size); this.rank = new Array(size); for (let i = 0; i = this.rank[rootY]) { this.root[rootY] = rootX; this.rank[rootX] += this.rank[rootY]; } else { this.root[rootX] = rootY; this.rank[rootY] += this.rank[rootX]; } } } } var smallestStringWithSwaps = function (s, pairs) { const n = s.length; const uf = new UnionFind(n); // 给所有字符分组（保存下标） for (let edge of pairs) { uf.unionSet(edge[0], edge[1]); } // 建立组长->组员的映射（保存下标） let groups = {}; for (let i = 0; i a.charCodeAt('0') - b.charCodeAt('0')); // 把排列好的字符放回对应的位置 for (let i = 0; i "},"medium/1209.html":{"url":"medium/1209.html","title":"1209. Remove All Adjacent Duplicates in String II(medium)","keywords":"","body":"1209. Remove All Adjacent Duplicates in String II Leetcode link 解题思路 题目要求我们去掉字符串重复 k 次的字符，需要注意的是每次删除完字符之后还要重新检查新的字符串是否还存在重复 k 次的字符 我们可以用栈来做这道题，栈内存放 字符 - 连续出现个数 的集合，当连续出现个数等于 k 的时候，就可以把这一组集合出栈了 最后，我们根据栈内的信息重新还原字符串就好 C++ class Solution { public: string removeDuplicates(string s, int k) { stack> st; for (int i = 0; i 0) { st.push({s[i], count}); } } // 最后根据栈内信息还原字符串 string res = \"\"; while (!st.empty()) { auto top = st.top(); while (top.second-- > 0) { res += top.first; } st.pop(); } reverse(res.begin(), res.end()); return res; } }; Javascript var removeDuplicates = function(s, k) { let stack = []; for (let i = 0; i 0) { stack.push([s[i], count]); } } // 最后根据栈内信息还原字符串 let res = \"\"; while (stack.length!==0) { let [ch, count] = stack[stack.length-1]; while (count-- > 0) { res = ch + res; } stack.pop(); } return res; }; "},"medium/1268.html":{"url":"medium/1268.html","title":"1268. Search Suggestions System(medium)","keywords":"","body":"1268. Search Suggestions System Leetcode link 解题思路 本题要求我们实现一个搜索推荐系统，要求输入每一个字符都要展示前三个搜索结果（字典序排序） 这种逐个字符搜索的题目很适合使用 字典树 来求解，对于字典树中任意一个 node 节点，从根节点到它的字符串称为 prefix 另外，因为要逐个展示搜索结果，所以我们需要额外使用一个优先队列来保存三个以当前 prefix 为开头的字符串 C++ // 字典树结构 struct Trie { unordered_map child; priority_queue words; }; class Solution { public: void addWord(Trie* root, const string& word) { Trie* cur = root; for(const char& c : word) { if(!cur->child.count(c)) { cur->child[c] = new Trie(); } cur = cur->child[c]; // 额外维护一个优先队列保存当前 prefix 的前三个字符串 cur->words.push(word); if(cur->words.size() > 3) { cur->words.pop(); } } } vector> suggestedProducts(vector& products, string searchWord) { Trie* root = new Trie(); for(const string& word: products) { addWord(root, word); } vector> ans; Trie* cur = root; // 标记字典树的结尾 bool flag = false; for(const char& c: searchWord) { if(flag || !cur->child.count(c)) { ans.push_back({}); flag = true; } else { cur = cur->child[c]; vector selects; while(!cur->words.empty()) { selects.push_back(cur->words.top()); cur->words.pop(); } reverse(selects.begin(), selects.end()); ans.push_back(move(selects)); } } return ans; } }; "},"medium/1302.html":{"url":"medium/1302.html","title":"1302. Deepest Leaves Sum(medium)","keywords":"","body":"1302. Deepest Leaves Sum Leetcode link 解题思路 这道题可以用队列与递归两种方法来写，因为思路很简单我用 C++ 实现了队列；用 js 实现递归 队列的话记得把每一行的最后一个元素后面插入一个空指针判别一行的结束 递归的话需要额外的一个变量来记录最深的层数，只需要记录最深那一层的加总就好 C++——队列 class Solution { public: int deepestLeavesSum(TreeNode* root) { queue pq; int sum = 0; pq.push(root); pq.push(nullptr); while(pq.size() > 1) { TreeNode* node = pq.front(); pq.pop(); if(node == nullptr) { pq.push(nullptr); sum = 0; continue; } sum+=node->val; if(node->left) { pq.push(node->left); } if(node->right) { pq.push(node->right); } } return sum; } }; Javascript——递归 var deepestLeavesSum = function(root) { let deepestLevel = 1; let sum = 0; let dfs = (node, level) => { if(!node) { return; } dfs(node.left, level+1); if(level > deepestLevel) { deepestLevel = level; sum = node.val; } else if(level == deepestLevel) { sum += node.val; } dfs(node.right, level+1); } dfs(root, 1); return sum; }; "},"medium/1352.html":{"url":"medium/1352.html","title":"1352. Product of the Last K Numbers(medium)","keywords":"","body":"1352. Product of the Last K Numbers Leetcode link 题目简介 本题要求我们实现一个类，这个类有着两个功能：添加数字、计算最后 k 个数字的乘积 解题思路 为了最大化减小计算开销，我们可以额外使用一个数组，来保存每一个数字与前面所有数字的乘积 举个例子，如果题目给的数字是：[1,2,3,4]，那么这个数组保存的就是：[1,2,6,24] 这样一来，如果我们要计算后两位的乘积，直接使用 24 / 2 就可以了 但是这个方案还有一个小问题，那就是 0 如果遇到了 0，那么 0 前面的所有乘积都会变成 0，所以在遇到 0 的时候，我们需要将整个保留乘积的数组恢复初始值 [1] 然后我们加一个判断条件，如果当前要求的 k 大于等于当前乘积数组的长度时，直接返回 0，否则就用除法得出答案 Javascript var ProductOfNumbers = function() { // 初始值 this.product = [1] }; /** * @param {number} num * @return {void} */ ProductOfNumbers.prototype.add = function(num) { if(num === 0) { this.product = [1] } else { this.product.push(num * this.product[this.product.length - 1]) } }; /** * @param {number} k * @return {number} */ ProductOfNumbers.prototype.getProduct = function(k) { if(k "},"medium/1379.html":{"url":"medium/1379.html","title":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree(medium)","keywords":"","body":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree Leetcode link 解题思路 题目给了我们两棵一模一样的树，并且将一个指针 target 指向了原树的其中一个节点，要求我们找到拷贝树上对应的节点 这种题目一般用 bfs 或者 dfs 来求解，一种简单的思路就是： 遍历拷贝的树，当遇到与 target 指针指向的值一样的树节点的时候，返回拷贝树对应的节点指针 但是这个思路有一个限制条件，就是树上不能有两个值相同的节点。 所以在这里我们用同时遍历两棵树的方法，详情见代码： C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) { TreeNode* res = nullptr; dfs(original, cloned, target, res); return res; } // 记得这里的 res 需要使用引用，因为我们需要记录 res 指针存放的地址 void dfs(TreeNode* original, TreeNode* cloned, TreeNode* target, TreeNode*& res) { // 如果已经找到了 res，就没必要继续下去了 if(original == nullptr || res != nullptr) { return; } // 当原树的节点等于目标节点的时候，拷贝树的对应节点就是我们的解 if(original == target) { res = cloned; return ; } dfs(original->left, cloned->left, target, res); dfs(original->right, cloned->right, target, res); } }; "},"medium/1396.html":{"url":"medium/1396.html","title":"1396. Design Underground System(medium)","keywords":"","body":"1396. Design Underground System Leetcode link 解题思路 题目要求我们实现一个 UndergroundSystem 类，该类有三个方法： checkIn：记录某个用户的 id，进站的站名，进站的时间 checkOut：记录某个用户的 id，出站的站名，出站的时间 getAverageTime：返回所有直接从站 A 到坐到站 B 的乘客所花的平均时间 另外题目还保证了用户只要进站就会出站，且出站时间一定比进站时间晚。 有了以上信息，我们可以构造两个映射表： routeTime：它保存了从站 A 到站 B 的路线名称与记录所有旅客旅行时间的数组 { “startStation_endStation”: [routeTime1, routeTime2, ...] } checkInInfo：它保存了用户 A 的 Uid 与进站站名，进站时间 { Uid: [stationName, time] } 下一步，我们可以借助映射表保存的数据，对三个方法进行操作： checkIn：把用户的 id，进站的站名，进站的时间保存到 checkInInfo 中 checkOut：根据 checkInInfo，找出有同样 id 的进站用户，拼接进出站名称，然后跟经过时间一起保存到 routeTime 中 getAverageTime：根据 routeTime 中的数据，给用户的旅行时间求一个平均值并返回 C++ class UndergroundSystem { private: // {startStation_endStation: [routeTime1, routeTime2, ...]} unordered_map> routeTime; // {Uid: [stationName, time]} unordered_map> checkInInfo; public: UndergroundSystem() {} void checkIn(int id, string stationName, int t) { checkInInfo[id] = {stationName, t}; } void checkOut(int id, string stationName, int t) { string station = checkInInfo[id].first + \"_\" + stationName; int time = t - checkInInfo[id].second; routeTime[station].push_back(time); } double getAverageTime(string startStation, string endStation) { string station = startStation + \"_\" + endStation; int totalTime = 0; int count = 0; for (auto &time : routeTime[station]) { totalTime += time; count++; } // 题目要求输出 double return (double)totalTime / count; } }; Javascript var UndergroundSystem = function() { // {startStation_endStation: [routeTime1, routeTime2, ...]} this.routeTime = {}; // {Uid: [stationName, time]} this.checkInInfo = {}; }; /** * @param {number} id * @param {string} stationName * @param {number} t * @return {void} */ UndergroundSystem.prototype.checkIn = function(id, stationName, t) { this.checkInInfo[id] = [stationName, t]; }; /** * @param {number} id * @param {string} stationName * @param {number} t * @return {void} */ UndergroundSystem.prototype.checkOut = function(id, stationName, t) { const station = this.checkInInfo[id][0] + \"_\" + stationName; const time = t - this.checkInInfo[id][1]; (this.routeTime[station] === undefined) && (this.routeTime[station] = []); this.routeTime[station].push(time); }; /** * @param {string} startStation * @param {string} endStation * @return {number} */ UndergroundSystem.prototype.getAverageTime = function(startStation, endStation) { const station = startStation + \"_\" + endStation; let totalTime = 0; let count = 0; for (let time of this.routeTime[station]) { totalTime += time; count++; } return totalTime / count; }; "},"medium/1423.html":{"url":"medium/1423.html","title":"1423. Maximum Points You Can Obtain from Cards(medium)","keywords":"","body":"1423. Maximum Points You Can Obtain from Cards Leetcode link 解题思路 本题给定我们一个数组，要求我们每次只能从数组两端取值，要求取 k 次之后总和最大 这个题目其实很适合用滑动窗口来求解，有两种思路： 假想数组头尾拼接起来，从数组最后 k 个开始遍历，然后遍历最后 k-1 个到第一个，最后 k-2 个到第二个。。。 求数组剩余连续部分的最小值，然后用数组总和减去最小值，因为剩余部分最小表示取的 k 个最大 C++ class Solution { public: int maxScore(vector& cardPoints, int k) { int total = accumulate(cardPoints.begin(), cardPoints.end(), 0); int len = cardPoints.size(); int windowSize = len - k; int left = 0, right = windowSize - 1; int sum = accumulate(cardPoints.begin(), cardPoints.begin() + windowSize, 0); int minSum = sum; while(right Javascript /** * @param {number[]} cardPoints * @param {number} k * @return {number} */ var maxScore = function(cardPoints, k) { let totalSum = cardPoints.reduce((prev, cur)=> prev + cur, 0); let len = cardPoints.length; // window size let size = len - k; let left = 0, right = size - 1; let sum = 0; for(let i=0;i "},"medium/1461.html":{"url":"medium/1461.html","title":"1461. Check If a String Contains All Binary Codes of Size K(medium)","keywords":"","body":"1461. Check If a String Contains All Binary Codes of Size K Leetcode link 解题思路——哈希表 题目给定一个二进制字符串 s 跟一个数字 k，要求我们判断所有的 k 位二进制是否都是字符串 s 的子串 首先，所有的 k 位二进制总共有 个，一个字符串要包含所有的 k 位二进制，长度不能小于 哈希表的思路是这样的： 遍历字符串 s，找出所有长度为 k 的子串 将这些子串放到一个哈希表中 利用哈希表去重的特性，如果遍历完了之后哈希表的长度等于 则表示所有的 k 位二进制都被我们找到了 C++ class Solution { public: bool hasAllCodes(string s, int k) { // reduce computation if(s.size() subStrs; for(int i=0;i+k 解题思路——哈希表+滑动窗口 上述思路最大的性能瓶颈在于对字符串的操作，我们可以依靠滑动窗口的思路来减少对字符串的操作 我们假设字符串当前遍历到长度为 k 的二进制子串为： 下一个子串就是： 我们可以把上述两个二进制子串转成十进制的表示为 结合上述两个式子，我们可以得到递推公式： 至此，我们就可以把哈希表的指责从保存字符串变成保存整数了，最重要的是，对字符串的操作少了非常多次 C++ class Solution { public: bool hasAllCodes(string s, int k) { if(s.size() substrs{num}; for(int i = 1;i+k "},"medium/1465.html":{"url":"medium/1465.html","title":"1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts(medium)","keywords":"","body":"1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts Leetcode link 解题思路 本题给出了一个 h * w 的蛋糕以及他要切的地方，要求我们求出蛋糕经过切割后剩下的最大面积 本题的思路很简单，就是分别找出横着切与竖着切中的最大距离，然后相乘起来就好了 最后一个要注意的点是，相乘之后的数字可能会超过精度，所以可以选用 JS 中的 bigInt 来保存 Javascript var maxArea = function(h, w, horizontalCuts, verticalCuts) { horizontalCuts.push(h, 0); horizontalCuts.sort((a, b) => a-b); verticalCuts.push(w, 0); verticalCuts.sort((a, b) => a-b); let maxWidth = 0, maxHeight = 0; for(let height = 1;height "},"medium/1482.html":{"url":"medium/1482.html","title":"1482. Minimum Number of Days to Make m Bouquets(medium)","keywords":"","body":"1482. Minimum Number of Days to Make m Bouquets Leetcode link 解题思路 题目给了我们三个参数： bloomDay：Array，代表花园所有花各自开始盛开的天数 m：Number，代表我们需要制作的花束数量 k：Number，代表我们制作一束花束需要用到多少株花 此外，题目要求我们所有的花束都只能用（数组中）相邻的花来制作，且一枝花只能用来制作一个花束 这个题解题的思路是：我们需要一天天的比较现在盛开的花，看看哪一天符合制作所有花束的条件 因此，我们需要一个函数 canMakeBouquets 来帮我们判断某一天是否符合制作花束的条件了 此外，为了减少复杂度，我们可以使用二分法来减少计算的天数，二分法的范围从 1～bloomDay.length 详情请看代码： Javascript /** * @param {number[]} bloomDay * @param {number} m * @param {number} k * @return {number} */ var minDays = function(bloomDay, m, k) { if(m*k > bloomDay.length) { return -1; } const canMakeBouquets = (day) => { let bouquet = 0; let flowers = 0; for(const date of bloomDay) { if(date = m) { return true } } return false; } let low = 1, high = Math.max(...bloomDay); while(low "},"medium/1488.html":{"url":"medium/1488.html","title":"1488. Avoid Flood in The City(medium)","keywords":"","body":"1488. Avoid Flood in The City Leetcode link 解题思路 本题的关键在于我们要怎么在同一个湖的下一场雨之前把湖水排干 为了这个目的我们需要提前做一些准备： fullLakes：一个 Map，用来保存 rains[i], i，记录之前的雨下在 rains[i] 湖的下标（日期） dryDays：数组，用来记录还未使用的没下雨的下标（日期），这样可以在将来下雨的时候用 res：数组，用来保存答案 有了这些之后，我们的算法步骤如下： 遍历 rain 数组 如果当天没下雨，则将当前下标保存到 dryDays 中，然后回到步骤 1 如果当天下雨了，判断当前下雨的湖泊之前是否有下过雨（是否在 fullLakes 中），如果有则在 dryDays 中寻找从上次下雨到现在范围内最早的 dryDay 放水；如果没有就把当前下雨的湖泊记录到 fullLakes 中 如果在 dryDays 中找不到符合规则的时间，则返回空数组 [] 题目描述有一点没有说清楚，如果当天没下雨，但是也没有需要放水的湖泊了，我们仍然需要选择一个 1～无限大的数字来填充进数组 不然这个 case 就会失败： // testcase [69,0,0,0,69] // expect [-1,69,1,1,-1] 下标 2、3 的数字不能是 -1。。。所以我们一开始给数组 res 要默认赋值 1 Javascript /** * @param {number[]} rains * @return {number[]} */ var avoidFlood = function (rains) { const res = new Array(rains.length).fill(1) // {rains[i], i} const fullLakes = new Map() const dryDays = [] for (let i = 0; i { let left = 0 let right = arr.length while (left > 1 if (arr[mid] "},"medium/1530.html":{"url":"medium/1530.html","title":"1530. Number of Good Leaf Nodes Pairs(medium)","keywords":"","body":"1530. Number of Good Leaf Nodes Pairs Leetcode link 题目简介 本题给了我们两个参数，第一个 root 代表了二叉树的根结点、第二个 distance 代表了距离（距离由两个节点要经过多少节点才能相遇决定） 题目要求我们找出树的所有叶子节点中，相遇的距离小于 distance 有几对 解题思路 本题是一个树相关的题目，要求找树的叶子节点的距离我们可以使用 DFS 来遍历整棵树 但是问题是，我们怎么在遍历的过程中，把叶子节点直接的距离也一起计算出来呢？ 方式有很多种，我在这里选择了用数组来记录 我构建了一个数组 leafDistances，数组记录的是以该节点为根结点，它到所有它的叶子节点的距离 假设今天有一棵树： a | \\ b c // leafDistances = [1, 1] 当我们构建了一个这样的数组的时候，我们就可以对数组中每个叶子节点的距离进行相加比较了 举个上面的例子，b 到 c 的距离就是 leafDistances[0] + leafDistances[1] 只要他们小于 distance，就可以给结果加一了 那么我们的问题就变成了，要怎么构造这个数组呢？分成两种情况： 遍历叶子节点时：要返回 [1]，代表叶子节点的父节点到叶子节点的距离为 1 遍历到父节点时：构建一个新的数组，把改节点左右两个子节点记录的数组距离都加一后 push 进新数组后返回 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} distance * @return {number} */ var countPairs = function(root, distance) { let result = 0; function dfs(node) { if(!node) return []; // 遍历到叶子节点的情况 if(!node.left && !node.right) return [1]; const leftDistances = dfs(node.left); const rightDistances = dfs(node.right); // 每遍历到一个节点，找找经过当前节点的叶子节点有没有距离小于 distance 的其他叶子节点，如果有则记录下来 for(const leftDistance of leftDistances) { for(const rightDistance of rightDistances) { if(leftDistance + rightDistance "},"medium/1552.html":{"url":"medium/1552.html","title":"1552. Magnetic Force Between Two Balls(medium)","keywords":"","body":"1552. Magnetic Force Between Two Balls Leetcode link 解题思路 本题本质上要我们去求极小值中的极大值，这种题目我们优先使用二分法来做 二分法的范围左边（min）取 0，右边（max）取 force 最大的值（也就是 position 中的最大值减掉最小值） 每次二分，我们都要判断当前的 force 是否可以放下所有的球： 如果可以，则重新调整范围 min 为上次的 force 如果不行，则重新调整范围 max 为上次的 force 最后我们再看看 max 还是 min 能放下所有小球，返回能放下小球的最大值就好 Javascript /** * @param {number[]} position * @param {number} m * @return {number} */ var maxDistance = function (position, m) { position.sort((a, b) => a - b) let min = 0; let max = position[position.length - 1] - position[0] while (min + 1 { let lastPosition = position[0]; balls--; for (const pos of position) { if (pos - lastPosition >= force) { balls--; lastPosition = pos; } if (balls === 0) { break; } } return balls === 0; } "},"medium/1584.html":{"url":"medium/1584.html","title":"1584. Min Cost to Connect All Points(medium)","keywords":"","body":"1584. Min Cost to Connect All Points Leetcode link 背景知识 这道题本质上是一道最小生成树 Minimum Spanning Tree (MST) 的题目。 题目给了我们在二维平面上的 n 个点，让我们求能让总距离最短且能将所有点连接起来的路径。 这个过程，恰巧也是生成 MST 的过程。 求 MST，主要有两个算法：Kruskal 与 Prim，下面将会分别描述两个算法的思路 解题思路——Kruskal's Algorithm Kruskal 算法把焦点放在 “边” 上，他的想法是： 先求出所有的边，再对它们的权重（一般是距离）排序 根据排序，从小到大依次取边 如果取得的边会让图形构成 “回路”，就抛弃这条边，继续第二步 如果不会则持续第二步，直到所有边都被取完或被丢弃 里面值得推敲的是，要如何判断取得的边会构成 “回路”，这一点就要用到并查集 Union-find, aka Disjoint-set。 简单来说，并查集是一个数据解构，它提供了两种方法： 合并 Union：将一个节点合并到一个组中 查 Find：查找一个节点是否在一个组中 我们可以利用它的特性，经过以下步骤确认是否成环： 把第一个点加到组里 取得选中的边的终点，并且确认是否已经在组里了 如果已经在组里了，那么表示加入这个边必定成环，则丢弃 如果不在组里，表示选中的边不会成环，把它的终点加到组里，然后重复第二步直到所有的边都取完了 C++ class UnionFind { private: vector group; public: UnionFind(int size) { group = vector(size); for (int i = 0; i >& points) { int n = points.size(); vector>> edges; // store edges' distance for (int curNode = 0; curNode 解题思路——Prim's Algorithm 相比 Kruskal 把重心放在边上，Prim 算法把重心放在 “点” 上。 它的核心思路在于： 一开始选中任意一点，将其加入 MST 中 选中距离 MST 最近的一个点，将其也加入 MST 中 重复第二步直到所有的点都被纳入 MST 中 使用一般的 Prim 算法的性能瓶颈在于：要维护一个优先队列，用以保存所有与 MST 相邻的边长度。 实现如下： /* * @lc app=leetcode id=1584 lang=cpp * * [1584] Min Cost to Connect All Points */ struct Edge { int start; int target; int distance; Edge(int _start, int _target, int _distance) { start = _start; target = _target; distance = _distance; } }; struct Cmp { bool operator()(Edge &a, Edge &b) { return a.distance > b.distance; } }; // @lc code=start class Solution { private: // visited points vector visited; // reserve shortest edge at top priority_queue, Cmp> pq; // find all edges of the point, and push into pq void findEdge(int point, vector>> &graph) { for (auto &edge : graph[point]) { int target = edge.first; // if visited, forget it if (visited[target]) { continue; } int distance = edge.second; pq.push({point, target, distance}); } } public: int minCostConnectPoints(vector> &points) { int n = points.size(); visited.resize(n); vector>> graph(n); // reserve edges' distance for (int curNode = 0; curNode 所以，我们可以换一种思路，优化一下优先队列。 具体地说，我们可以改为维护一个数组 minDist，它是一个长度等于节点数的数组，minDist[n] 表示从节点 n 到 MST 树的最短距离。 具体步骤如下： 在一开始，我们先把 minDist 的每一项都设为∞ 然后我们任意选择一点 将选择的点加入 MST 然后将 minDist[n] 设为 0（n 为选择的点），将其他元素更新成该点到点 n 的距离 从更新好的距离中选择还没被加入 MST 且距离最短的点，重复步骤三 实现如下： class Solution { public: int minCostConnectPoints(vector> &points) { int n = points.size(); int result = 0; int edgeUsed = 0; vector visited(n); // minDist[n]: the shortest distance from n to MST vector minDist(n, INT_MAX); // start from points[0] minDist[0] = 0; while (edgeUsed minDist[i]) { curMinEdge = minDist[i]; curNode = i; } } visited[curNode] = true; result += curMinEdge; edgeUsed++; // update minDist for adjacent node for (int nextNode = 0; nextNode 如果还有看不懂的同学可以看一下 官方解答 的第三个的动图就懂了 "},"medium/1625.html":{"url":"medium/1625.html","title":"1625. Lexicographically Smallest String After Applying Operations(medium)","keywords":"","body":"1625. Lexicographically Smallest String After Applying Operations Leetcode link 题目简介 吐槽一下：这一题能成为 medium 单纯就是暴力模拟的计算量不大，如果要简化这题的话个人认为是一道 hard…… /** * @param {string} s * @param {number} a * @param {number} b * @return {string} */ 本题给了我们一个原始字符串 s（其中每个字符都是 0～9 的数字字符，并且 s 的长度是偶数）以及一个整数 a 与整数 b 要求我们经过无限次的操作之后，求出语义最小的字符串 s 操作有两种： 旋转（将字符串往右旋转 b 个字符）：假设 s=0123, b = 2，旋转后得到 s=2301 求和（将当前字符串奇数下标加 a 后对 10 取余）：假设 s=0123, a = 9，结果为 s=0022 解题思路——模拟 这题最简单的思路就是把所有可能的字符串都找出来，然后比较一下将语义最小的字符串返回 具体来说，我们可以用一个 set 来记录我们处理过的字符串；一个 queue 来将所有新字符串入栈；一个变量 res 来记录当前语义最小的字符串 每次循环我们从 queue 中取出字符串，更新 res 变量，然后将其旋转与求和的新字符串入栈，直到 queue 栈为空 Javascript /** * @param {string} s * @param {number} a * @param {number} b * @return {string} */ var findLexSmallestString = function (s, a, b) { let res = s const set = new Set() const queue = [s] while (queue.length > 0) { const str = queue.shift() if (str { return str.slice(b, str.length) + str.slice(0, b) } const add = (str, a) => { let newStr = '' for (let i = 0; i 解题思路——数学简化 上面的方法虽然能过，但是构造所有字符串无疑是有点麻烦了，我们接下来研究一下要如何简化 首先我们明确一下目标，要让语义最小，我们的首要目标就是让最高位的数字最小 题目提供了两种调整最高位数字的方法，所以我们可以将目标拆解为两个： 通过求和把所有的数字调整到最小 通过旋转把最小的数字调整到最前面 求和 根据题目要求，我们每次求和都只能将所有位于当前奇数下标的数字全部求和 所以，在只讨论求和的情况下，我们的目标就是，把最高位的奇数下标的数字调整到最小，也就是将 s[1] 的数字调整到最小 那么我们如何将 s[1] 调整到最小呢？有两种方式： 循环对 s[1] 求和，直到得出最小的数字为止，然后对余下的奇数下标数字操作相同次数的求和（最差的情况会多 10 次计算） 用我们伟大的数学直接计算出需要加多少～（在所有情况都只需要一次计算） 第一个方式的实现非常简单，但是缺点是会提升复杂度（但是这一题暴力都能解所以肯定是可以通过的） 我们接下来重点看一下第二个方式的推导： 根据题目求和的要求，我们可以得出如下公式 $ r = (s[1] + ak) \\mod 10$ 其中 k 代表我们进行了 k 次的操作，r 代表 s[1] 经过 k 次操作之后的结果 我们的目标就是得出 ak 是多少可以让 r 最小 我们再进一步可以将 mod 10 操作看成减去多次的 10，我们假设 q 为需要减去 10 的次数，于是公式变成了 $ r = s[1] + ak - 10q$ 由于我们的目标是得出 s[1] 要如何操作才能变成 r，所以我们调换一下公式 $ak - 10q = r - s[1]$ 其中 ak - 10q 就是我们需要对 s[1] 进行的操作，所以我们接下来的目标就是看看如何使得 ak - 10q 有解 万幸的是～我们有 裴蜀定理： 裴蜀定理假设有 a，b 两个不全为 0 的整数，必定存在两个整数 x 与 y 使得 ax+by= gcd(a, b) 成立 Gcd 表示最大公因数 我们把其中的 x 替换成 k、y 替换成 q、a 还是 a、b 替换成 10，可以得到： $ak - 10q = gcd(a, 10) = r - s[1]$ 于是我们得到结论一：r - s[1] 是 gcd(a, 10) 的倍数 根据同余的定义，我们可以根据结论一推导出～ 如果整数 (a) 和 (b) 的差 ((a-b)) 能被 (m) 整除，即 (m|(a-b))，则称 (a) 和 (b) 对模 (m) 同余 结论二： r 与 s[1] 对gcd(a, 10) 同余 由于我们要让 r 最小，所以我们可以推导出～ 结论三：r = s[1] mod gcd(a, 10) 我们把结论三套回一开始的公式： $s[1]\\ mod\\ gcd(a, 10) = s[1] + ak - 10q$ 调整一下，计算 ak 的公式就有了： $ak = s[1]\\ mod\\ gcd(a, 10) - s[1] + 10q$ 由于我们最后会对 10 取余，所以我们只需要让 q = 1 就可以防止 s[1] mod gcd(a, 10) - s[1] 是负的了 旋转 接下来我们来看看旋转要如何简化 首先明确一点，我们旋转的目的是为了让最高位的数字最小，换言之就是 s[0] 最小 那么我们接下来就来分析一下，有哪些数字有机会成为 s[0]（或者换一个思路，s[0] 通过旋转能出现在哪些位置） 假设字符串 s 长度是 len，每次能旋转 b 位，我们不难得出以下公式 $0 + bk\\ mod\\ len$ 其中 k 代表旋转的次数，这个公式代表 s[0] 通过 k 次旋转后会出现的位置，我们整理一下公式 $bk - len*q$ 其中 mod len 可以看成减去了 q 次的 len 根据我们的老熟人 裴蜀定理 得知：如果该公式有解，这些解必须是 gcd(b, len) 也就是说，只有位置在 gcd(b, len) 的倍数的字符有机会旋转到 s[0] 旋转+求和 接下来我们来讨论一下两个操作一起来的情况 具体而言，我们要来讨论一下我们是否能通过旋转将下标为奇数的字符旋转为下标为偶数的字符 我们已经知道字符串长度必为偶数，那么只有两种情况： b 为奇数：旋转一次会让奇偶下标的字符位置互换 b 为偶数：奇偶下标字符不会互换 所以我们得到结论：只有当 b 为奇数的时候，我们才需要对偶数下标的数字求和 Javascript /** * @param {string} s * @param {number} a * @param {number} b * @return {string} */ var findLexSmallestString = function (s, a, b) { const arr = s.split('').map(c => Number(c)) const len = arr.length const rotateStep = gcd(b, len) const addGcd = gcd(a, 10) let res = arr for (let i = 0; i { while (a) { [a, b] = [b % a, a] } return b } const add = (arr, addGcd, start) => { const c = arr[start] const inc = c % addGcd - c + 10 for (let i = start; i { for (let i = 0; i "},"medium/1631.html":{"url":"medium/1631.html","title":"1631. Path With Minimum Effort(medium)","keywords":"","body":"1631. Path With Minimum Effort Leetcode link 解题思路——并查集 本题给了我们一个二维数组，并要求我们找到从左上角到右下角元素波动最小（就是靠近的两个元素差值的最大值最小）的路径。 我们可以把这个问题简化成：找到一个图上的一条路径，这条路径最长的部分必须是所有路径最长的部分的最小值。 因此，我们可以使用基于并查集的 Kruskal 算法来做，具体思路如下： 计算所有相邻元素之间的距离（就是两个元素之间的差值） 将所有的距离从小到大排序 从最小的距离开始，依次将元素加入并查集中 检查左上角的起点与右下角的终点是否已经在同一个组中，如果是则返回当前的距离 如果不是则回到第三步继续计算 C++ class UnionFind { private: vector root; vector rank; public: UnionFind(int size) : root(size), rank(size) { for (int i = 0; i = rank[rootY]) { root[rootY] = rootX; rank[rootX] += rank[rootY]; } else { root[rootX] = rootY; rank[rootY] += rank[rootX]; } } } }; class Solution { public: int minimumEffortPath(vector> &heights) { int col = heights[0].size(), row = heights.size(); vector> edges; // 计算节点与下面、右边的边距（effort） for (int i = 0; i (a) (b); }); UnionFind uf(col * row); int start = 0, end = col * row - 1; for (auto [cell1, cell2, distance] : edges) { uf.unionSet(cell1, cell2); if (uf.find(start) == uf.find(end)) { return distance; } } return 0; } }; Javascript class UnionFind { constructor(size) { this.root = new Array(size); this.rank = new Array(size); for (let i = 0; i = this.rank[rootY]) { this.root[rootY] = rootX; this.rank[rootX] += this.rank[rootY]; } else { this.root[rootX] = rootY; this.rank[rootY] += this.rank[rootX]; } } } }; var minimumEffortPath = function(heights) { const row = heights.length, col = heights[0].length; let edges = []; // 计算元素与下面，右边的边距 for(let i=0;i 大） edges.sort((a, b)=> a[2] - b[2]); const uf = new UnionFind(col * row); const start = 0, end = col * row - 1; for(let edge of edges) { const [cell1, cell2, effort] = edge; uf.unionSet(cell1, cell2); if(uf.find(start) === uf.find(end)) { return effort; } } return 0; }; 解题思路——Dijkstra 我们可以把题目化简成求图上指定起点与终点的最短路径。只是最短路径的定义不再是路径累加，而是用最长的一段路径代表。 于是，我们就可以用 Dijkstra 的思想来做了，具体思路如下： 我们需要一个数组 dist 来记录任意点到起点的最短路径，并在一开始初始化数组元素为∞ 我们还需要一个优先队列 pq 来记录当前 “发现” 的元素以及当前的最短路长度 最后我们维护一个已到达数组 visited 来保存已经确定了最短路的元素 然后就可以开始 Dijkstra 了，区别在于更新 dist 的条件是当前节点到起始点最长的一段路径要小于 dist 里面记录的长度 C++ class Solution { private: int direction[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; bool inRange(int x, int y, int row, int col) { return x >= 0 && x = 0 && y >& heights) { int row = heights.size(), col = heights[0].size(); auto Cmp = [](const auto& e1, const auto& e2) { auto&& [x1, y1, d1] = e1; auto&& [x2, y2, d2] = e2; return d1 > d2; }; // {row, col, distance} priority_queue, vector>, decltype(Cmp)> pq(Cmp); pq.push({0, 0, 0}); vector dist(row * col, INT_MAX); dist[0] = 0; vector visited(row * col); while (!pq.empty()) { auto [x, y, distance] = pq.top(); pq.pop(); int position = x * col + y; if (visited[position]) { continue; } if (x == row - 1 && y == col - 1) { break; } visited[position] = true; for (int i = 0; i "},"medium/1641.html":{"url":"medium/1641.html","title":"1641. Count Sorted Vowel Strings(medium)","keywords":"","body":"1641. Count Sorted Vowel Strings Leetcode link 解题思路 这道题规律特别明显，可以直接列出来看看： N a u e i o 1 1 1 1 1 1 2 5 4 3 2 1 3 15 10 6 3 1 4 25 20 10 4 1 5 50 25 15 5 1 可以看到，对于 [n = 2, a] 这个格子，它的值等于 [n = 1, a] + [n = 1, u] + [n = 1, e] + [n = 1, i] + [n = 1, o] 对于 [n = 3, u] 这个格子，它的值等于 [n = 2, u] + [n = 2, e] + [n = 2, i] + [n = 2, o] 不难看出，每一个格子的值等于其上一行同一列 到 上一行最后一列的加总 注：还有另一种规律是，从右上到左下是一个倾斜了 45 度的杨辉三角，也可以套公式来解 C++ class Solution { public: int countVowelStrings(int n) { int a = 1, e = 1, i = 1, o = 1, u = 1; while(n-- > 1) { a = a + e + i + o + u; e = e + i + o + u; i = i + o + u; o = o + u; u = u; } return a + e + i + o + u; } }; Javascript var countVowelStrings = function(n) { let [a, e, i, o, u] = new Array(5).fill(1); while(n-- > 1) { a = a + e + i + o + u; e = e + i + o + u; i = i + o + u; o = o + u; u = u; } return a + e + i + o + u; }; "},"medium/1642.html":{"url":"medium/1642.html","title":"1642. Furthest Building You Can Reach(medium)","keywords":"","body":"1642. Furthest Building You Can Reach Leetcode link 解题思路 leetcode 难得有这么幽默的一道题，本题要求我们在屋顶玩跑酷，题目给定我们两个工具：砖块与梯子，其中梯子可以无限延长，而砖块只有固定高度；题目要求我们翻越尽可能多的建筑屋顶，要求是，如果要翻越的建筑比当前建筑低，直接跳下去就完事；如果比当前建筑高，则需要借助砖块或者梯子。 可想而知，梯子是我们想要翻越尽可能多屋顶的最佳选择，所以必须尽可能的 “换” 更多的砖块 至于怎么换呢？我门需要用到贪心的思路，具体步骤如下： 首先我们往前翻越要优先使用砖块 当遇到砖块用完的情况下，我们可以用梯子 “换” 砖块 也就是比较当前高度差以及之前最高的高度差，如果之前的高度差比较大，则用梯子替代掉之前用了最多砖块的地方；否则直接用梯子 重复步骤 1，3 直到砖块梯子都用完且无法前进的时候返回当前下标 C++ class Solution { public: int furthestBuilding(vector &heights, int bricks, int ladders) { // 大根堆保存之前翻越每一栋楼用的砖块数量 priority_queue pq; for (int num = 0; num 0) { // 梯子还够的话，用梯子 ladders--; // 如果之前用过的砖块比现在要用的多就用砖块换，否则直接用梯子 if (!pq.empty() && pq.top() > altitude) { bricks += pq.top(); pq.pop(); num--; } } else { // 连梯子都无了那就是真的无了 return num; } } } } return heights.size() - 1; } }; "},"medium/1653.html":{"url":"medium/1653.html","title":"1653. Minimum Deletions to Make String Balanced(medium)","keywords":"","body":"1653. Minimum Deletions to Make String Balanced Leetcode link 题目简介 题目给我们一个入参 s，代表一个由 a 与 b 两个字母组成的字符串 题目要求我们删除最少的字符让字符串中不存在 ba 的组合 并且最后返回需要删除的字符数量 解题思路 想要让字符串中没有 ba 的组合，有两种方式： 删除掉 ba 中的 b 删除掉 ba 中的 a 但是我们要怎么知道我们应该选择哪一种方式呢？ 答案是选择删除 ba 组合中连续数量比较少的那个字母 举个例子：aababbab 我们可以看到第一个 ba 组合是：aababbab 这个时候因为这个组合的 b 跟 a 数量是一样的，所以我们任意删除一个都可以，删除字符数记 1 第二个组合是：aababbab 这个时候我们可以看到 a 的数量比 b 少，所以就把 a 删除，删除字符记 2 结果返回 2 具体编码中，我们只需要在遇到 b 的时候用一个计数器 count 把 b 的数量记下，然后在遇到 a 的时候把 count 的数量减一的同时把删除字符的数量加一即可 Javascript /** * @param {string} s * @return {number} */ var minimumDeletions = function(s) { let count = 0; let deletion = 0; for(const c of s) { if(c === 'b') { count++; } else if(count > 0) { deletion++; count--; } } return deletion; }; "},"medium/1658.html":{"url":"medium/1658.html","title":"1658. Minimum Operations to Reduce X to Zero(medium)","keywords":"","body":"1658. Minimum Operations to Reduce X to Zero Leetcode link 解题思路 本题要求我们用一个数组 nums 的两端之和组成整数 x 我们可以换个角度思考，首先求一个数 count 等于数组 nums 所有元素之和减去整数 x 我们就可以把问题转变为，找出数组中，长度之和为 count 的最长连续子串 因此，我们就可以用滑动窗口的思想来做题了 C++ class Solution { public: int minOperations(vector& nums, int x) { int left = 0, right = 0; // nums 数组的每一项之和 int arrSum = 0; for(int num :nums) { arrSum += num; } int count = arrSum - x; // 当前滑动窗口之和 int sum = 0; // 题目所求的长度 int res = -1; // 数组所有元素之和小于整数 x，不可能有结果 if(count count) { sum -= nums[left++]; } if(count == sum) { res = max(res, right - left + 1); } right++; } if(res == -1) { return -1; } else { return nums.size() - res; } } }; Javascript var minOperations = function(nums, x) { let left = 0, right = 0; // nums 数组的每一项之和 let arrSum = nums.reduce((prev, cur)=> prev + cur, 0); let count = arrSum - x; // 当前滑动窗口之和 let sum = 0; // 题目所求的长度 let res = -1; // 数组所有元素之和小于整数 x，不可能有结果 if(count count) { sum -= nums[left++]; } if(count === sum) { res = Math.max(res, right - left + 1); } right++; } if(res === -1) { return -1; } else { return nums.length - res; } }; "},"medium/1679.html":{"url":"medium/1679.html","title":"1679. Max Number of K-Sum Pairs(medium)","keywords":"","body":"1679. Max Number of K-Sum Pairs Leetcode link 解题思路——排序+双指针 TC: O(nlogn) SC: O(1) 题目要求我们计算在数组中任取两个不重复的数字总和为 k 的组合数，且用过的数字不能再用 那么我们可以用排序+双指针来解： 先把数组由小到大排序 使用两个指针分别从数组的左边跟右边开始往中间遍历 如果左右指针所指元素相加小于 k ，则可以将左指针 +1来加大两数之和 反之如果左右指针所指元素相加大于 k ，则可以将右指针 -1来缩小两数之和 如果两数之和刚好相等，那么组合数 +1，并且把左指针 +1，右指针 -1 重复步骤 2～5 直到左右指针相遇（指向同一个元素） C++ class Solution { public: int maxOperations(vector& nums, int k) { int res = 0, left = 0, right = nums.size() - 1; sort(nums.begin(), nums.end()); while ((left k) { right--; } else { left++; right--; res++; } } return res; } }; Javascript var maxOperations = function(nums, k) { let left = 0, right = nums.length-1, res = 0; nums.sort((a,b)=>a-b); while((left 解题思路——建立映射 TC: O(n) SC: O(n) 第一种方法因为用了排序使得时间复杂度比较高，那么我们可以用时间换空间的方式，也就是： 建立一个映射来保存出现过的数字的次数，然后对数组中的每个元素，在映射中找 k 与元素的差，如果在映射表中存在计数，则表示我们需要的组合出现了 C++ class Solution { public: int maxOperations(vector& nums, int k) { int res = 0; unordered_map freq; for (int num : nums) { int rest = k - num; if (freq[rest] > 0) { res++; freq[rest]--; } else { freq[num]++; } } return res; } }; Javascript var maxOperations = function(nums, k) { let res = 0; let freq = {}; for(let num of nums) { let rest = k - num; if(freq[rest]!== undefined && freq[rest] > 0) { freq[rest]--; res++; } else { (freq[num] === undefined) && (freq[num] = 0); freq[num]++; } } return res; }; "},"medium/1689.html":{"url":"medium/1689.html","title":"1689. Partitioning Into Minimum Number Of Deci-Binary Numbers(medium)","keywords":"","body":"1689. Partitioning Into Minimum Number Of Deci-Binary Numbers Leetcode link 解题思路 题目要求我们使用二进制的数来拼出十进制的任何数 本题答案个数的限制在于给出的十进制数最大的一位数，所以我们只要遍历找出最大的那个元素就好 C++ class Solution { public: int minPartitions(string n) { return *max_element(n.begin(), n.end()) - '0'; } }; Javascript /** * @param {string} n * @return {number} */ var minPartitions = function(n) { let max = 0; for(let c of n) { max = Math.max(c, max); } return max; }; "},"medium/1695.html":{"url":"medium/1695.html","title":"1695. Maximum Erasure Value(medium)","keywords":"","body":"1695. Maximum Erasure Value Leetcode link 解题思路 题目要求我们求一个正整数数组 nums 的累加和最大的无重复元素的连续子数组，返回其累加和的值 因为要求连续子数组，所以我们优先考虑滑动窗口的方式 另外，我们可以用一个集合来记录当前窗口内已有的元素，如果出现了重复元素，则将窗口内该元素包含之前的元素全部清理出窗口外 我们记录下每个符合条件的窗口累加和，最后再取最大值就是题目所求了 C++ class Solution { public: int maximumUniqueSubarray(vector& nums) { int left = 0, right = 0; int res = -1; int sum = 0; unordered_set set; int len = nums.size(); while(right Javascript /** * @param {number[]} nums * @return {number} */ var maximumUniqueSubarray = function(nums) { let left = 0, right = 0; let set = new Set(); let res = -1; let sum = 0; let len = nums.length; while(right "},"medium/1717.html":{"url":"medium/1717.html","title":"1717. Maximum Score From Removing Substrings(medium)","keywords":"","body":"1717. Maximum Score From Removing Substrings Leetcode link 解题思路 本题给了我们一个字符串 s 以及两个数字 x 与 y，其中： x 代表当 ab 组合从字符串去除时候得到的分数 y 代表当 ba 组合从字符串去除时候得到的分数 最后要我们求能够从给定条件下获得的最高分数 这个题目我们可以采用顺序遍历字符串的形式来做，在遍历过程中我们会遇到几种情况： 遇到了字母 a 遇到了字母 b 遇到了其他字母 我们来分别分析一下这三种情况： 遇到字母 a 首先我们要明确的一点是，我们的希望永远优先把分数高的组合给去除掉 当我们遇到字母 a 的时候，我们要先做两个个判断： 去除 ba 的得分是否比去除 ab 高：if(y > x) a 前面是否有 b 可以凑成 ba 如果这两个条件成立，恭喜，我们可以把 y 的分数收入囊中了 如果这两个条件有一个不成立，那么不好意思，我们先把 a 的数量记起来，继续遍历（因为在这一轮遍历，我们只希望去除分数高的组合） 遇到字母 b 这个时候的目标与上述一致，我们的希望永远优先把分数高的组合给去除掉 只是判断条件改了： 去除 ab 的得分是否比去除 ba 高：if(x > y) a 前面是否有 b 可以凑成 ab 如果条件成立，把分数 x 纳入囊中 如果不成立，记下 b 的数量，继续遍历 遇到其他字母 遇到其他字母的时候，我们的目标是：把前面分数低的得分组合做一个结算 这个目标有两个问题要解决： 为什么前面都是分数低的？因为我们优先把分数高的组合去除了，剩下来的 a/b 只可能是分数低的组合或者单个字母两种情况 要怎么结算？我们取 a/b 中数量最少的个数去✖️低分分数 循环结束 当循环结束的时候，字符串的尾巴可能还会有剩下一些低分组合，要记得把这些低分组合用遇到其他字母的算法做一个结算 Javascript /** * @param {string} s * @param {number} x: 'ab' * @param {number} y: 'ba' * @return {number} */ var maximumGain = function(s, x, y) { let aCount = 0; let bCount = 0; const minPoint = Math.min(x, y); let result = 0; for(let i=0;i 'b': // 如果出现了不是 a/b 的字符，要把前面留存的 a/b 的分数算一下 // 因为后面两个 case 的规则决定了当出现分数比较高的组合会第一时间处理掉 // 所以这里如果有能凑成一堆的 a/b，一定是分数比较低的组合 result += Math.min(aCount, bCount) * minPoint; aCount = bCount = 0; break; case c === 'a': // 当 y > x 且 ba 组合出现的时候，优先处理掉当前的 ba 组合（计算分数） if(y > x && bCount > 0) { result += y; bCount--; } else { // 如果没出现，就先记着之后处理 aCount++; } break; case c === 'b': // 当 x > y 且 ab 组合出现的时候，优先处理掉当前的 ab 组合（计算分数） if(x > y && aCount > 0) { result += x; aCount--; } else { // 如果没出现，就先记着之后处理 bCount++; } break; } } // 当上述循环结束的时候，有可能还会有分数少的组合在字符串末尾没有处理的情况，这里统一处理 result += Math.min(aCount, bCount) * minPoint; return result; }; "},"medium/1721.html":{"url":"medium/1721.html","title":"1721. Swapping Nodes in a Linked List(medium)","keywords":"","body":"1721. Swapping Nodes in a Linked List Leetcode link 解题思路 本题要求我们找到单向链表第 k 个节点与倒数第 k 个节点交换，难点在于如何在一次遍历中找到倒数第 k 个节点 我们可以先找到第 k 个节点 n1，这个时候 head 跟 n1 的距离刚好是 k，我们用一个指针 n2 指向 head，然后 n1 与 n2 同时往后遍历链表，这样只要 n1 找到了链表的尾节点， n2 就恰巧是倒数第 k 个节点了。 C++ class Solution { public: ListNode* swapNodes(ListNode* head, int k) { ListNode *n1 = head, *n2 = head, *n_kth; while (--k > 0) { n1 = n1->next; } n_kth = n1; while (n1->next != NULL) { n2 = n2->next; n1 = n1->next; } swap(n_kth->val, n2->val); return head; } }; Javascript var swapNodes = function(head, k) { let n1 = head, n2 = head, n_kth; while (--k > 0) { n1 = n1.next; } n_kth = n1; while (n1.next != null) { n2 = n2.next; n1 = n1.next; } [n_kth.val, n2.val] = [n2.val, n_kth.val]; return head; }; "},"medium/1733.html":{"url":"medium/1733.html","title":"1733. Minimum Number of People to Teach(medium)","keywords":"","body":"1733. Minimum Number of People to Teach Leetcode link 题目简介 题目给了我们三个参数： n：代表有多少种语言 languages：是一个二维数组，代表每一种语言有多少个人会 friendships：也是一个二维数组，在同一个数组元素内的人表示是朋友 题目要求我们选择一种语言去教人，使得所有朋友都能够互相使用相同语言沟通 要求我们得出最少教多少个人就能够符合要求 解题思路 这道题需要分成三个步骤来解： 先通过遍历所有的朋友，找出有多少人是需要被教新的语言的（只要朋友双方没有共同语言就需要将两个人都列入需要教学的范围） 在所有需要教学的人中，找出他们共同会最多的语言 用所有需要教学的人，减去会最多语言的人数，就是需要教学的最少人数了 Javascript /** * @param {number} n * @param {number[][]} languages * @param {number[][]} friendships * @return {number} */ var minimumTeachings = function (n, languages, friendships) { // 计算需要被教学的人 const userToTeach = new Set() for (const [u1, u2] of friendships) { const hasCommonLang = languages[u1 - 1].some(lang => languages[u2 - 1].includes(lang)) if (!hasCommonLang) { userToTeach.add(u1) userToTeach.add(u2) } } // 计算最多人会的语言与其会的人数 const langCount = new Array(n+1).fill(0) let mostKnownLangCount = 0 for(const user of userToTeach) { for(const lang of languages[user - 1]) { langCount[lang]++ mostKnownLangCount = Math.max(langCount[lang], mostKnownLangCount) } } // 所有需要被教学的人，减去最多人会的语言的人数 return userToTeach.size - mostKnownLangCount } "},"medium/2043.html":{"url":"medium/2043.html","title":"2043. Simple Bank System(medium)","keywords":"","body":"2043. Simple Bank System Leetcode link 题目简介 这是一道系统设计题 题目回调用我们的构造函数 Bank 并且传入一个数字数组 balance，其长度为账户的数量，数组内的元素代表该帐号的余额 题目要求我们实现一系列的操作： transfer：将 account1 账户的 money 转账到 account2 账户 deposit：将 money 存入 account 账户 withdraw：从 account 账户取出 money 解题思路 只需要注意这些操作失败的原因有两个： 该帐号不存在：account > balance.length 该帐号转出的钱比当前存款多：money > balance[account - 1] Javascript /** * @param {number[]} balance */ var Bank = function (balance) { this.balance = balance this.len = balance.length }; /** * @param {number} account1 * @param {number} account2 * @param {number} money * @return {boolean} */ Bank.prototype.transfer = function (account1, account2, money) { if (account1 > this.len || account2 > this.len || this.balance[account1 - 1] this.len) { return false } this.balance[account - 1] += money return true }; /** * @param {number} account * @param {number} money * @return {boolean} */ Bank.prototype.withdraw = function (account, money) { if (account > this.len || this.balance[account - 1] "},"medium/2048.html":{"url":"medium/2048.html","title":"2048. Next Greater Numerically Balanced Number(medium)","keywords":"","body":"2048. Next Greater Numerically Balanced Number Leetcode link 题目简介 /** * @param {number} n * @return {number} */ 题目给我们一个数字 n 要求我们求出比 n 大的最小的平衡数 平衡数的定义：这个数字内的每一个数字的数量必须与数字大小一致 举例：333221 就是平衡数、3221 就不是（因为 3 没有 3 个） 解题思路 这题的关键在与这个范围限制：0 由于比 10^6 更大的平衡数是 1224444，我们不难看出这个是可以通过简单的暴力判断求出的 具体而言我们从 n+1 开始循环，对每个数判断是否是平衡数，返回遇到的第一个平衡数即可 Javascript /** * @param {number} n * @return {number} */ var nextBeautifulNumber = function (n) { for (let i = n + 1; ; i++) { if (isBalance(i)) { return i } } return -1 }; const isBalance = num => { const count = new Array(10).fill(0) while (num > 0) { count[num % 10]++ num = Math.floor(num / 10) } for (let i = 0; i 0 && count[i] !== i) { return false } } return true } "},"medium/2096.html":{"url":"medium/2096.html","title":"2096. Step-By-Step Directions From a Binary Tree Node to Another(medium)","keywords":"","body":"2096. Step-By-Step Directions From a Binary Tree Node to Another Leetcode link 解题思路 本题给了我们一棵二叉树，以及一个起点与一个终点，要求我们得出从起点到终点的最短路线 最短路线是一个字符串，有三个字符代表三个方向： U：往父节点走 L：往左边子节点走 R：往右边子节点走 本题可以分成三个步骤来走： 找到最近共同父节点 LCA(Lowest Common Ancestor)：详见代码中的 findLCA 方法 从 LCA 出发，分别遍历到起点与终点的路径：详见代码中的 findPath 方法 最后，我们将起点终点的路径拼起来，注意从起点到 LCA 的路径要全部替换成 U Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} startValue * @param {number} destValue * @return {string} */ var getDirections = function(root, startValue, destValue) { const lca = findLCA(root, startValue, destValue); let startPath = []; let destPath = []; findPath(lca, startValue, startPath); findPath(lca, destValue, destPath); return 'U'.repeat(startPath.length) + destPath.reverse().join('') }; // LCA: Lowest Common Ancestor const findLCA = (node, startValue, destValue) => { if(!node || node.val === startValue || node.val === destValue) { return node; } const left = findLCA(node.left, startValue, destValue); const right = findLCA(node.right, startValue, destValue); // 遍历到这里有两种可能： // 1. startValue 与 destValue 有一个共同的祖先节点，此时 left && right 会同时存在 // 2. startValue 或 destValue 是另一方的祖先节点，此时只有作为祖先节点的节点才会被赋值 if(left && right) { return node; } else { return left ? left : right; } } const findPath = (node, target, path) => { if(!node) { return false; } if(node.val === target) { return true; } if(findPath(node.left, target, path)) { path.push('L'); return true; } if(findPath(node.right, target, path)) { path.push('R'); return true; } return false; } "},"medium/2125.html":{"url":"medium/2125.html","title":"2125. Number of Laser Beams in a Bank(medium)","keywords":"","body":"2125. Number of Laser Beams in a Bank Leetcode link 题目简介 /** * @param {string[]} bank * @return {number} */ 题目给我们可以字符串数组 bank，其字符串都是由 0 与 1 组成 其中 0 代表当前格子是空的，1 代表当前格子有安保设施 当满足以下两个条件时，安保设施可以发出一道光束： 当两个安保设施不在同一行时（也就是不属于同一个字符串） 当两个安保设施所在的两行中间没有别的带有安保设施的行（也就是要么两个安保设施所在的行紧挨着；要么两个安保设施中间的行没有安保设施） 题目要求我们在给定的 bank 下会有多少条光束产生 解题思路 根据题目我们不难看出，如果有两行 i，j 满足产生光束的条件的话，产生的光束数量为 bank[i] * bank[j] 如果有完全没有安保设施的行的话，我们直接忽略 Javascript /** * @param {string[]} bank * @return {number} */ var numberOfBeams = function (bank) { let res = 0 // beams in previous line let prev = 0 for (let i = 0; i Javascript（或者用数组来做） /** * @param {string[]} bank * @return {number} */ var numberOfBeams = function (bank) { let res = 0 const arr = bank.map(str => { return str.split('').reduce((acc, cur) => { return acc + (cur & 1) }, 0) }).filter(num => num > 0) for (let i = 1; i "},"medium/2191.html":{"url":"medium/2191.html","title":"2191. Sort the Jumbled Numbers(medium)","keywords":"","body":"2191. Sort the Jumbled Numbers Leetcode link 题目简介 本题也是一个数组排序题，题目给了我们两个入参： mapping：映射数组，代表下标到对应数字的映射，比如 [9] 代表数字 0 映射到数字 9 nums：需要被排序的数字数组 题目要求我们将 nums 的数字按照 mapping 映射之后的值升序排序，并且要求我们在元素映射后相等时不能改变对应的位置 解题思路 这一题只需要完成三步操作就可以解出： 求的 nums 中所有数字的映射值 根据映射值进行升序排序 排序过程中保证相等的元素相对位置不变（这个 js 的 sort 方法已经帮我们保证了这点） Javascript /** * @param {number[]} mapping * @param {number[]} nums * @return {number[]} */ var sortJumbled = function (mapping, nums) { // 求得数字的映射值 const transform = (num) => { return parseInt( num. toString(). split(''). map(item => mapping[item]). join('')) } const numMap = {}; for(const num of nums) { numMap[num] = transform(num); } // 根据映射值排序 return nums.sort((a, b) => numMap[a] - numMap[b]); }; "},"medium/2196.html":{"url":"medium/2196.html","title":"2196. Create Binary Tree From Descriptions(medium)","keywords":"","body":"2196. Create Binary Tree From Descriptions Leetcode link 解题思路 本题要求我们根据题目给定的描述信息，构造一个二叉树 入参是一个数组 descriptions，其中每一项包含了三个信息： parent：标识当前元素的父元素 child：标识当前元素的 value isLeft：标识当前元素是否是父元素的左节点 最后题目要求我们返回二叉树的根结点 通过观察题目给到的测试 case，我们不难发现题目给到的节点其实是乱序的 那么我们就需要维护一个 map 的映射，保证我们能够找到之前创建的节点 其次，我们还需要解决一个问题：如何找到跟节点 通过观察测试 case，我们可以得到一个结论：跟节点永远不会出现在 child 的位置上 我们可以通过这一点，维护一个 childNode Set，用来保存出现在 child 位置上的节点，最后遍历找出没在 Set 中的节点就是根结点 解决了这两个难点后，我们就可以开始遍历 descriptions 了，遍历过程中我们只需要做好四件事： 判断父节点有没有被创建过，没有的话创建一个父节点，并将其保存到 map 中 判断子节点有没有被创建过，没有的话创建一个子节点，并将其保存到 map 中 建立父子节点之间的关系 把子节点保存到 set 中 最后，我们遍历 map 然后找到没有在 set 中的节点返回就行～ Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[][]} descriptions * @return {TreeNode} */ var createBinaryTree = function (descriptions) { const childNode = new Set(); const createdNode = new Map(); for (const node of descriptions) { // 处理子节点 let curNode if (createdNode.has(node[1])) { curNode = createdNode.get(node[1]); } else { curNode = new TreeNode(node[1]); createdNode.set(node[1], curNode); } // 处理父节点 let parentNode if (createdNode.has(node[0])) { parentNode = createdNode.get(node[0]); } else { parentNode = new TreeNode(node[0]); createdNode.set(node[0], parentNode); } // 建立父子节点之间关系 if (node[2]) { parentNode.left = curNode; } else { parentNode.right = curNode; } // 记录子节点 childNode.add(node[1]); } // 找出根节点返回 for (const [key, value] of createdNode) { if (!childNode.has(key)) { return value; } } }; function TreeNode(val, left, right) { this.val = (val === undefined ? 0 : val) this.left = (left === undefined ? null : left) this.right = (right === undefined ? null : right) } "},"medium/2221.html":{"url":"medium/2221.html","title":"2221. Find Triangular Sum of an Array(medium)","keywords":"","body":"2221. Find Triangular Sum of an Array Leetcode link 题目简介 题目给我们一个数组 nums ，nums 的每一个元素都是 0～9 的数字 题目要求我们按照如下步骤计算数组直到数组长度为 1 并返回唯一的元素： 假设原数组有 n 个元素，创建一个长度为 n - 1 的数组 newArr 对于每一个符合条件 0 的 i，newArr[i] = (nums[i] + nums[i + 1]) % 10 使用 newArr 取代原来的数组 回到步骤 1 解题思路 这题有两个思路，第一个思路是直接按照题目要求模拟出来就好，复杂度是 O(n^2)，但是可以 accept 另外有一个解法用到了组合数以及中国余数定理，能够把复杂度降到 O(n) Javascript:O(n^2) /** * @param {number[]} nums * @return {number} */ var triangularSum = function(nums) { let res = [...nums] let temp = [] let i = 0 while(i Javascript: O(n) /** * @param {number[]} nums * @return {number} */ var triangularSum = function(nums) { const n = nums.length; if (n === 1) return nums[0] % 10; const m = n - 1; // --- mod 2 --- let S2 = 0; for (let i = 0; i 0 ? 0 : r5; // if any factor 5 remains, coeff ≡ 0 (mod 5) } S5 = (S5 + (nums[i] % 5) * (i === 0 ? 1 : c5)) % 5; } // --- CRT combine to mod 10 --- const t = (S2 - (S5 & 1) + 2) & 1; // choose t in {0,1} s.t. parity matches return (5 * t + S5) % 10; }; "},"medium/2300.html":{"url":"medium/2300.html","title":"2300. Successful Pairs of Spells and Potions(medium)","keywords":"","body":"2300. Successful Pairs of Spells and Potions Leetcode link 题目简介 题目给了 spells 与 potions 两个数组还有一个 number success，要求针对每一个 spells 中的元素 spells[i]，有多少个 potions 的元素 potions[j] 符合：spells[i] * potions[j] >= success 解题思路 针对题目要求，我们可以对 potions 做排序后，遍历当前 spells ，针对每一个 spell 用 binary search 找出符合题目要求的最小的 potions[j] 的下标 j 然后用 potions.length - j 就可以得出基于当前 spell 符合条件的 potion 有多少个了 Javascript /** * @param {number[]} spells * @param {number[]} potions * @param {number} success * @return {number[]} */ var successfulPairs = function (spells, potions, success) { potions.sort((a, b) => a - b) const res = [] spells.forEach(s => { const idx = binarySearch(potions, s, success) const count = potions.length - idx res.push(count) }) return res }; const binarySearch = (arr, multiples, target) => { let left = 0 let right = arr.length while (left > 1 if (arr[mid] * multiples >= target) { right = mid } else { left = mid + 1 } } return left } "},"medium/2327.html":{"url":"medium/2327.html","title":"2327. Number of People Aware of a Secret(medium)","keywords":"","body":"2327. Number of People Aware of a Secret Leetcode link 题目简介 有个人在第一天的时候知晓了一个秘密，但是他只会在 delay 了几天后，才会把秘密告诉另外一个人（每人每天只能告诉一个人） 而且，每个人在得知消息的 forget 天后，就会忘了这个消息，在忘记消息的当天也无法再把秘密告诉其他人 题目要我们求在第 n 天的时候，这个秘密会有多少人知道 解题思路 根据题目，我们可以把所有的人分成两个部分： 当天刚得知秘密的人：我们用 dp[i] 代表在第 i 天有多少人刚刚得知秘密 当天能够分享秘密的人：我们用 share 来代表 根据题目描述，因为第一天只有一个人知道秘密，所以 dp[1] = 1，share = 0 从第二天开始，我们需要计算 share 跟 dp[i] share 的计算有两个部分： 如果 $i - delay > 0$ ，share += dp[i - delay] ：这个等式表示，如果当前天数大于 delay 的天数之后，过了 delay 天数的那些人就可以开始分享秘密了 如果 $i-forget > 0$，share -= dp[i - forget]：这个等式表示，如果当前天数大于 forget 的天数之后，过了 forget 天数的那些人就不能分享秘密了 经过上述计算，我们可以得到当天可以 share 的人数 当天可以 share 的人数 = 当天新知道消息的人数，所以 dp[i] = share 综上，我们可以得知从第二天到第 n 天每天新得知消息的人数，那么我们要计算第 n 天还有多少人知道消息，我们只需要计算从第 n - forget + 1 天到第 n 天总共有多少人新得知消息就好，也就是 sum(dp[i]), i form (n-forget+1) to n 最后别忘了 mod 一个 $10^9+7$ Javascript /** * @param {number} n * @param {number} delay * @param {number} forget * @return {number} */ var peopleAwareOfSecret = function (n, delay, forget) { const mod = 1000000007n const dp = new Array(n + 1).fill(0n) dp[1] = 1n // the number of people who can share on that day let share = 0n for (let i = 2; i 0n) { share += dp[i - delay] } if (i - forget > 0) { share -= dp[i - forget] } dp[i] = share } let res = 0n for (let i = n - forget + 1; i "},"medium/2353.html":{"url":"medium/2353.html","title":"2353. Design a Food Rating System(medium)","keywords":"","body":"2353. Design a Food Rating System Leetcode link 题目简介 题目要求我们实现一个食物评分系统，其中包含三个方法 FoodRatings：构造函数，包含 foods, cuisines, ratings 三个参数分别代表食物、菜系、评分，其中食物是唯一的 changeRating：更改评分，接受 food, newRating 两个参数 highestRated：返回当前菜系最高评分的食物，接受 cuisine 一个参数 解题思路 这道题的核心难点在于，要如何在调用 highestRated 时使用最少的时间复杂度 解决方案是使用大顶堆 MaxHeap 首先我们需要几个 Map 来帮助我们保存食物、菜系、评分之间的关系： foodToCuisine：保存食物到菜系之间的映射关系 foodToRating：保存食物到评分间的映射关系 cuisineToHeap：保存菜系到大顶堆之间的映射关系 大顶堆中保存着由评分与食物组成的数组 当调用 FoodRatings 时，我们需要根据参数初始化好三个 Map 的数据 当调用 changeRating 时，我们需要更新 foodToRating 与 cuisineToHeap之中的 heap，但是 heap 中的数据不好删除，所以我们在这一步就先只插入新数据就好 最后当调用 highestRated 时，我们需要将 heap 取得的最大 rating 与当前的 foodToRating 中记录的 rating 做对比，如果不符合我们需要抛弃当前的数据（把 changeRating 时没有删除的数据在这里删除了）直到我们找到符合 foodToRating 记录的 rating leetcode 在 js 环境有提供了 PriorityQueue 的实现，所以也可以不用自己实现一个 MaxHeap Javascript（自己实现 maxHeap） /** * @param {string[]} foods * @param {string[]} cuisines * @param {number[]} ratings */ var FoodRatings = function (foods, cuisines, ratings) { this.foodTocuisine = new Map() this.foodToRating = new Map() this.cuisineToHeap = new Map() for (let i = 0; i parent's rating if (parent >= 0 && this.compare(this.heap[index], this.heap[parent]) > 0) { // swap them [this.heap[index], this.heap[parent]] = [this.heap[parent], this.heap[index]] this.heapifyUp(parent) } } heapifyDown(index) { const left = index * 2 + 1 const right = index * 2 + 2 let largest = index // if left > largest if (left 0) { largest = left } // if right > largest if (right 0) { largest = right } if (largest !== index) { [this.heap[index], this.heap[largest]] = [this.heap[largest], this.heap[index]] this.heapifyDown(largest) } } compare([ratingA, foodA], [ratingB, foodB]) { if (ratingA !== ratingB) { return ratingA - ratingB } return foodB.localeCompare(foodA) } } Javascript（使用 leetcode 提供的 PriorityQueue） /** * @param {string[]} foods * @param {string[]} cuisines * @param {number[]} ratings */ var FoodRatings = function (foods, cuisines, ratings) { this.foodTocuisine = new Map() this.foodToRating = new Map() this.cuisineToQueue = new Map() for (let i = 0; i { if (a[0] !== b[0]) return b[0] - a[0]; return a[1].localeCompare(b[1]); })) } this.cuisineToQueue.get(cuisine).enqueue([ratings[i], foods[i]]) } }; /** * @param {string} food * @param {number} newRating * @return {void} */ FoodRatings.prototype.changeRating = function (food, newRating) { this.foodToRating.set(food, newRating) const cuisine = this.foodTocuisine.get(food) this.cuisineToQueue.get(cuisine).enqueue([newRating, food]) }; /** * @param {string} cuisine * @return {string} */ FoodRatings.prototype.highestRated = function (cuisine) { const queue = this.cuisineToQueue.get(cuisine) while(!queue.isEmpty()){ const [rating, food] = queue.front() if(rating === this.foodToRating.get(food)) { return food } queue.dequeue() } return '' }; "},"medium/2415.html":{"url":"medium/2415.html","title":"2415. Reverse Odd Levels of Binary Tree(medium)","keywords":"","body":"2415. Reverse Odd Levels of Binary Tree Leetcode link 题目简介 题目给我们一个完美二叉树（所有父节点都有两个子节点且所有叶子节点都在同一层），要求我们将奇数层的所有叶子节点翻转（简单理解成 Array.reverse() 就好 解题思路 其实翻转的本质可以看成，有两个指针分别指向需要交换的层的最左边与最右边的节点，然后将其交换后把指针各自往中间走一步，直到指针相遇 那么我们在树中要怎么样找到当前层最左跟最右的节点呢？答案是 dfs 我们只需要在深度遍历的时候，同时遍历两个节点就好了，所以 dfs 的调用应该是这样的： dfs(node.left, node.right, level) 那么我们接下来要怎么让两个 “指针” 同时往中间走呢？答案是反过来遍历： dfs(node.right, node.left, level) 基于以上，我们可以看代码了 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {TreeNode} */ var reverseOddLevels = function(root) { const dfs = (left, right, level) => { if(left === null || right === null) { return } if(level % 2 === 1) { [left.val, right.val] = [right.val, left.val] } dfs(left.left, right.right, level+1) dfs(left.right, right.left, level+1) } dfs(root.left, root.right, 1) return root }; "},"medium/2471.html":{"url":"medium/2471.html","title":"2471. Minimum Number of Operations to Sort a Binary Tree by Level(medium)","keywords":"","body":"2471. Minimum Number of Operations to Sort a Binary Tree by Level Leetcode link 题目简介 本题给了我们一棵二叉树，并且保证了每个节点都是唯一的 题目要求我们针对每一层对这个树做升序排序，然后返回在排序中所需的最少交换次数 解题思路 首先，针对每一层的遍历，我们优先选用 bfs 来求解 有了 bfs 我们可以很快得到每一层的所有节点，并且我们可以将其升序排序 题目的难点在于要怎么获取最少的交换次数呢？ 我们可以遍历当前层的节点，通过不断把排序好的值与排序前的位置当前值进行交换，并将交换的次数记录下来，这样等到最后还原成原来的值之后，所得到的次数就是最少的次数 我们可以借用一个 map 来保存当前层所有节点的值与原来的位置（下标）的映射 有了这个映射之后，我们只需要遍历当前层，然后对比排序前后，如果不一致，从 map 中获取排序后的值原来的位置，然后做三件事： 交换新位置与原来的位置的值 更新 map 计算次数 然后不断循环对比就好 Javascript /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var minimumOperations = function (root) { if (!root) return 0 let count = 0 const queue = [root] while (queue.length > 0) { const len = queue.length const curLevel = [] // bfs for (let i = 0; i a-b) // count the operations const map = new Map() for (let i = 0; i "},"medium/2598.html":{"url":"medium/2598.html","title":"2598. Smallest Missing Non-negative Integer After Operations(medium)","keywords":"","body":"2598. Smallest Missing Non-negative Integer After Operations Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} value * @return {number} */ 题目给了一个数字数组 nums 以及一个数字 value 我们可以对数组 nums 的任意数字加或减 value 题目要求我们求出经过无限次操作之后的最大的 MEX MEX 代表数组从 0 开始遇到的第一个空缺的正整数（比如 [0, 1, 2, 3, 5] 的 MEX 就是 4 解题思路 不难看出对于任何数组元素 num，我们都可以通过无限次加减 value 得到 [0 ~ value-1] 的整数 对于正数 num，我们可以用 num % value 得到 对于负数 num，我们可以用 (value - (-num % value)) % value 得到 如此一来我们可以将数组 nums 转换成一个元素只在 [0 ~ value-1] 范围内的数组 newNums 我们最关心的其实是 newNums 中每个值的个数，所以我们可以用一个长度为 value 的数组 counts 来计算每一个元素的个数 接下来我们只需要计算出 counts 中值最小且下标最小的元素 count（对应到 newNums 出现次数最少且最小的元素） 找到后我们就可以用 count * value + i （i 代表 count 元素的下标）获得最大的 MEX 了 Javascript /** * @param {number[]} nums * @param {number} value * @return {number} */ var findSmallestInteger = function (nums, value) { const counts = new Array(value).fill(0) nums.forEach(num => { if (num "},"medium/2749.html":{"url":"medium/2749.html","title":"2749. Minimum Operations to Make the Integer Zero(medium)","keywords":"","body":"2749. Minimum Operations to Make the Integer Zero Leetcode link 题目简介 本题更像是一道数学题，题目给了我们两个数字 num1 与 num2，要求我们用 num1 减去多次 $2^i + num2$ 直到最终结果为 0 其中 i 的范围是 $0 \\le i \\le 60$ 解题思路 要解答这一题我们需要一些数学推导，推导前我们需要一些符号来简化描述： a 代表题目中的 num1 b 代表题目中的 num2 t 代表减去 $2^i + num2$ 的次数 c 代表一连串 2 的次方的和 下面进入推导： 有了 c，我们能很容易得出 2 的次方的个数，只要将 c 转换成二进制然后看看有几个 1 就好，这个个数我们使用 x 来代替 有了上述信息，我们可以给 t 一个范围 $x \\le t$：x 有可能小于 t 是因为会出现类似 $2^0 + 2^0 = 2^1$ 的情况，这种情况下我们只会算一个 1 $t \\le c$：在所有的 i 都为 0 的情况，t === c，否则 c > t 综上，我们得到 $x \\le t \\le c$ 的范围 接下来我们只需要在 0～60 的范围里面由小到大循环 i，直到找到符合上述范围的 i 就是我们的答案了 Javascript /** * @param {number} num1 * @param {number} num2 * @return {number} */ var makeTheIntegerZero = function (num1, num2) { const countOneInBits = num => num.toString(2).replace(/0/g, '').length for (let i = 1; i sumOfTwoPower) { return -1 } if(i >= oneInSumOfTwoPower) { return i } } return -1 }; "},"medium/2785.html":{"url":"medium/2785.html","title":"2785. Sort Vowels in a String(medium)","keywords":"","body":"2785. Sort Vowels in a String Leetcode link 题目简介 题目要求我们在给定的一个字符串中，挑出其中的母音（包括大小写）然后按照 ASC2 排序后放回原来母音的位置，最后返回新的字符串 解题思路 首先我们要准备一个排序好的大小写母音表字符串 sortedVowels（这一步能帮我们省一个排序的时间复杂度） 然后我们再准备一个与上述母音表长度相等的数组 vowelsCount，数组的元素代表同下标 sortedVowels 母音的个数，先给每个元素置 0 接着我们遍历字符串 s，挑出所有的母音字母，并给 vowelsCount 中的对应元素加上母音出现次数 最后我们再遍历一次字符串 s，替换母音字母 Javascript /** * @param {string} s * @return {string} */ var sortVowels = function(s) { const sortedVowels = 'AEIOUaeiou' const vowelsCount = new Array(sortedVowels.length).fill(0) const chars = s.split('') chars.forEach(c=> { const idx = sortedVowels.indexOf(c) if(idx > -1) { vowelsCount[idx]++ } }) let vowelsCountIdx = 0 const res = chars.map(c => { if(sortedVowels.includes(c)) { while(vowelsCount[vowelsCountIdx] === 0) { vowelsCountIdx++ } vowelsCount[vowelsCountIdx]-- return sortedVowels[vowelsCountIdx] } return c }) return res.join('') }; "},"medium/3025.html":{"url":"medium/3025.html","title":"3025. Find the Number of Ways to Place People I(medium)","keywords":"","body":"3025. Find the Number of Ways to Place People I Leetcode link 题目简介 本题会给我们若干个二维的点，要求我们找到由两个点组成的矩形，这个矩形要满足三点要求： 矩形由右下与左上的点组成 矩形的面积内不允许有其他的点 矩形可以是一条水平或垂直直线 题目要求找出符合条件的矩形个数 解题思路 由于题目要求我们找出矩形左上与右下的点，所以我们可以先给所有的点进行一个排序，排序规则如下： 所有的点按照 x 轴升序排列 如果有 x 轴相同的点，则按照 y 轴降序排列 由此排列之后的点会遵循着由左到右，由上到下的顺序 然后，我们需要一个双层的循环，来遍历图中的点 第一层循环中，我们选取第一个点，由此我们可以知道当前矩形 y 轴的上限就是第一个点的 y 坐标，我们记作 upperYLimit 在第二层循环中，我们遍历下一个点，如果遍历的点的 y 坐标小于等于 upperYLimit，那么就表示我们找到了一个符合的矩形，并将当前的 y 坐标标记为 lowerYLimit 接着我们继续在第二层循环中遍历下一个点，这个点是符合的矩形的要求就是在满足 y 坐标小于等于 upperYLimit 的情况下，y 坐标还要大于 lowerYLimit 否则该点就会出现在上一个矩形中 Javascrip /** * @param {number[][]} points * @return {number} */ var numberOfPairs = function (points) { points.sort((a, b) => { if (a[0] === b[0]) { return b[1] - a[1] } return a[0] - b[0] }) let count = 0 const n = points.length for (let i = 0; i lowerYLimit) { count++ lowerYLimit = curY if(curY === upperYLimit) { break } } } } return count }; "},"medium/3100.html":{"url":"medium/3100.html","title":"3100. Water Bottles II(medium)","keywords":"","body":"3100. Water Bottles II Leetcode link 题目简介 本题时 Water Battles 的变形，题目还是给我们两个参数：numBottles, numExchange 分别代表一开始有多少个装满水的瓶子以及多少个空瓶子能换一瓶水 但是本题加了两个条件： 每次用空瓶子换水最多只能换一瓶水 numExchange 的数量会随着交换水的次数增加，每次加一 解题思路 虽然条件修改了，但是我们还是一样用循环来模拟题目 比较容易混淆的是代码第 10 行，我们需要对 numExchange - 1，因为每次 exchange 都会换回来一个装满水的新瓶子，所以变相的，我们每次交换瓶子其实只需要 numExchange - 1 个空瓶子就好 Javascript：O(n^(1/2)) /** * @param {number} numBottles * @param {number} numExchange * @return {number} */ var maxBottlesDrunk = function (numBottles, numExchange) { let res = numBottles let emptyBottle = numBottles while (emptyBottle >= numExchange) { emptyBottle -= numExchange - 1 numExchange++ res++ } return res }; "},"medium/3147.html":{"url":"medium/3147.html","title":"3147. Taking Maximum Energy From the Mystic Dungeon(medium)","keywords":"","body":"3147. Taking Maximum Energy From the Mystic Dungeon Leetcode link 题目简介 本题提供两个参数： energy：数组，代表你经过每一个元素将会得到的能量，能量有可能为负的 k：数字，代表你每次经过元素需要略过的元素数量，假设有一个数组 [1, 2, 3, 4, 5]，而 k = 3，则如果你从第一个元素开始的话，你遍历的数组会是 [1, 4] 题目要求我们可以从数组的任何位置开始遍历，让我们求能够获得的最大能量是多少 解题思路1 从题目描述中我们不难看出，对于数组的最后 k 项，能够获得的能量就是 energy 数组的最后 k 个元素本身 所以我们接下来的关键在于，要怎么找到元素 i 与元素 i+k 之间的关系 假设我们使用数组 dp 来保存从当前元素开始遍历所能获得的能量总和，那么我们不难得出： dp[i] = dp[i+k] + energy[i] 解释：假设 i+k 是 energy 的最后一个元素，则我们从其 k 个元素前开始获取能量，我们可以多获得 energy[i] 个能量 有了这个等式，我们只要从后往前遍历数组，就能够得到所有的 dp 数组元素了，最后只要取最大值返回就是我们的答案了 Javascript /** * @param {number[]} energy * @param {number} k * @return {number} */ var maximumEnergy = function (energy, k) { const dp = [...energy] for (let i = dp.length - 1 - k; i >= 0; i--) { dp[i] = dp[i+k] + energy[i] } return Math.max(...dp) }; 解题思路2 如果仔细看我们的上一个解题思路，我们不难发现数组 dp 其实是可以被优化掉的 我们还是那个关键的等式：dp[i] = dp[i+k] + energy[i] 但是这次我们将一次的数组遍历拆开，拆成 k 次遍历，每次从 dp.length - k - i (0 开始遍历 并且记录遍历过程中的最大值，记录下来，等遍历结束直接返回就好 Javascript /** * @param {number[]} energy * @param {number} k * @return {number} */ var maximumEnergy = function (energy, k) { let res = Number.MIN_SAFE_INTEGER let step = k while (step > 0) { let totalEnergy = 0 for (let i = energy.length - step; i >= 0; i -= k) { totalEnergy += energy[i] res = Math.max(totalEnergy, res) } step-- } return res }; "},"medium/3186.html":{"url":"medium/3186.html","title":"3186. Maximum Total Damage With Spell Casting(medium)","keywords":"","body":"3186. Maximum Total Damage With Spell Casting Leetcode link 题目简介 本题给我们一个数组 power，数组的元素代表能够造成的伤害 题目限制我们如果我们输出了 power[i] 的伤害，则在 power[i]-2 ~ power[i]+2 范围内的其他伤害就无效了（注意如果有 n 个 power[i] 的伤害，我们是可以造成 power[i] * n 的伤害的 题目让我们求出我们所能打出的最高伤害是多少 解题思路 首先我们了解到，是否能打出伤害只跟伤害的值本身有关系，跟顺序无关，所以我们可以先对 power 升序排序 其次，这种累进的题目大多在考我们对于动态规划的理解，我们首先需要知道每个伤害之间的关系 假设我们有个数组 dp，它的元素代表了当前的 power 所能打出的最大伤害 接下来我们需要考虑如何构建这个数组 dp 在伤害最大化的前提，我们首选对最大的伤害 power[max] 分析一波，我们有两种选择：打出该伤害；不打出该伤害 在打出该伤害的情况下： 当前伤害 = power[max] * n（n 为伤害出现的次数） 其余伤害 = dp[j]（j 为小于 power[i]-2 的伤害中最大的那一个） 我们取和：power[max] * n + dp[j] 在不打出该伤害的情况下： 当前伤害 = 0 其余伤害 = dp[max - 1] 取和：dp[max - 1] 如果我们要伤害最大化，则对 max 来说，我们需要 dp[max] = max(dp[max - 1], power[max] * n + dp[j]) 如此一来 dp[dp.length - 1] 就会是我们的答案 但是我们还需要考虑到这个动态规划的入口，也就是我们要求 dp[i] 的时候，dp[i-1] 不能是 undefined 所以我们的 dp 数组长度需要是 power 数组去重之后的长度 + 1 Javascript /** * @param {number[]} power * @return {number} */ var maximumTotalDamage = function (power) { // { power[i]: count(power[i]) } const map = new Map() power.forEach(p => { map.set(p, (map.get(p) || 0) + 1) }) // deduplication the power const uniquePower = Array.from(map.keys()).sort((a, b) => a - b) const len = uniquePower.length const dp = new Array(len + 1).fill(0) for (let i = 0; i { let left = 0 let right = arr.length while (left > 1 if (arr[mid] >= target) { right = mid } else { left = mid + 1 } } return left } "},"medium/3227.html":{"url":"medium/3227.html","title":"3227. Vowels Game in a String(medium)","keywords":"","body":"3227. Vowels Game in a String Leetcode link 题目简介 题目给我们一个字符串 s，要求我们配合 Alice 与 Bob 玩一场游戏 首先是 Alice：Alice 需要从字符串中，找出含有奇数个母音字母的子字符串，将其从原有字符串中删除 紧接着是 Bob：Bob 需要从剩下来的字符串中，找出含有偶数个母音字母的子字符串，将其从原有字符串中删除 然后回到 Alice……以此类推 最后谁无法进行下一步则判定其输了，Alice 赢的话返回 true，反之返回 false 解题思路 我们可以用贪婪的思想来思考这道题，分三种可能性： 字符串中一个母音字符都没有：Bob 包赢（因为 Alice 第一步就没法走） 字符串中有奇数个母音字符：Alice 包赢（因为她可以在一开始把整个字符串都删除，导致 Bob 完全没法走） 字符串有偶数个母音字符：Alice 包赢（在第一句 Alice 删除后，字符串会变成奇数母音字符的字符串，此时 Bob 完成他的删除后，字符串仍然只会是含有奇数个母音字符的字符串，此时回到了第二种可能性，所以 Alice 包赢） 结论：除了字符串中一个母音字符都没有的情况下，Alice 包赢 Javascript /** * @param {string} s * @return {boolean} */ var doesAliceWin = function(s) { return [...s].some(c=> ['a', 'e', 'i', 'o', 'u'].includes(c)) }; "},"easy/3264.html":{"url":"easy/3264.html","title":"3264. Final Array State After K Multiplication Operations I(easy)","keywords":"","body":"3264. Final Array State After K Multiplication Operations I Leetcode link 解题思路 本题是简单题，题目说明也很简单 直接按照题目，四个步骤： 找到最小值 确保最小值第一次在数组出现的下标 将数组该下标乘以 multiplier 将上述步骤执行 k 次 Javascript /** * @param {number[]} nums * @param {number} k * @param {number} multiplier * @return {number[]} */ var getFinalState = function(nums, k, multiplier) { while(k-- > 0) { const min = Math.min(...nums) const index = nums.indexOf(min) nums[index] = min* multiplier } return nums }; "},"medium/3346.html":{"url":"medium/3346.html","title":"3346. Maximum Frequency of an Element After Performing Operations I(medium)","keywords":"","body":"3346. Maximum Frequency of an Element After Performing Operations I Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @param {number} numOperations * @return {number} */ 本题给了一个数字数组 nums，要求我们在 numOperations 次操作内，求出数组中相同数字出现最高的频率是多少 一次操作指的是我们在 nums 中选择没有操作过的元素，将其元素与 [-k, k] 范围内的整数求和 解题思路 本题题目需要我们通过操作尽可能将 nums 中的数字变成一样的（让某个数字出现频率最高） 出现频率最高的数字有两种可能： 该数字是原来 nums 中的元素 该数字不是 nums 中的元素 下面我们分开讨论 目标是 nums 中的元素 这个情况下，我们就可以省去给该元素操作的次数，然后将这些次数用来操作别的元素 那么怎么操作呢？ 首先我们需要对数组 nums 升序排序 然后我们需要遍历 nums 中的每一个元素 针对每一个元素，我们有两个指针：left、right left 指针指向的元素是比当前 nums[i] - k 大的最小的元素，也就是：nums[left] >= nums[i] - k right 指针指向的元素是比当前 nums[i] + k 大的最小元素，也就是：nums[right] > nums[i] + k 不难看出 right - left 就是当目标为 nums[i] 时，经过操作后能等于 nums[i] 的元素数量 但是题目还有一个操作限制，所以当目标是 nums[i] 时，出现的频率是：Math.min(right - left, numOperations + count) 其中 count 是 nums[i] 出现的次数 当我们把 nums 所有元素都遍历完了之后得到的最大值就是在目标是 nums 中的元素的情况下出现频率最高元素的出现次数了 目标不是nums 中的元素 在这种情况下，针对每一个 nums[i]，我们只需要看 [nums[i] - 2k, nums[i]] 这个范围内的元素个数就好 接下来我们把两种情况都处理完，得到的就是答案了 Javascript /** * @param {number[]} nums * @param {number} k * @param {number} numOperations * @return {number} */ var maxFrequency = function (nums, k, numOperations) { nums.sort((a, b) => a - b) const len = nums.length let res = 0 // if nums[i] is target let left = 0 let right = 0 // count the current element let count = 0 for (let i = 0; i = nums[i] - k while(nums[left] nums[i] + k while(right = numOperations) { return res } // now, we can handle the situation that nums[i] is not a target left = 0 const BOUNDARY = k*2 for(right = 0;right BOUNDARY) { left++ } const size = right - left + 1 res = Math.max(res, Math.min(numOperations, size)) } return res }; "},"medium/3350.html":{"url":"medium/3350.html","title":"3350. Adjacent Increasing Subarrays Detection II(medium)","keywords":"","body":"3350. Adjacent Increasing Subarrays Detection II Leetcode link 题目简介 本题是 3349 的变体 题目一样给的是数字数组 nums，这次需要我们把 k 求出来 /** * @param {number[]} nums * @return {number} */ 题目要求我们从 nums 中找出两个等长递增子数组，并且要求我们返回这个长度的最大值 k 解题思路 本题的难点有两个： 如何找出递增子数组的长度 如何通过对比计算出最长的子数组长度 第一个难点我们可以用滑动窗口来求解：我们可以定义一个 left 代表窗口的左边界、right 代表窗口的右边界 此时 right 能够增加的条件就是 right+1 nums[right]（right 没有触碰到数组边界且其下一个元素比当前元素大） 当我们确定了 right 之后，我们可以用 right - left + 1 来确定一个递增子数组的长度 为了计算最长子数组长度，我们可以通过一个变量 res 来保存当前的最长子数组长度，一开始为 1 res 的值由两个部份决定： 当前求得的最长子数组长度的一半（将一个递增子数组平均的拆成两个） 当前找到的最长子数组的长度，以及上一次找到最长子数组长度中最小的那一个（为了满足题目条件，长的需要配合短的） 于是我们可以得到 res = max(res, curSubLen >> 1, min(curSubLen, prevSubLen)) 其中 curSubLen 代表当前找到的递增子数组长度，prevSubLen 代表上一次找到的最长子数组长度 Javascript /** * @param {number[]} nums * @return {number} */ var maxIncreasingSubarrays = function (nums) { const len = nums.length let prevSubLen = 1 let left = 0 let res = 0 while (left > 1, Math.min(curSubLen, prevSubLen)) prevSubLen = curSubLen left = right + 1 } return res }; "},"medium/3397.html":{"url":"medium/3397.html","title":"3397. Maximum Number of Distinct Elements After Operations(medium)","keywords":"","body":"3397. Maximum Number of Distinct Elements After Operations Leetcode link 题目简介 /** * @param {number[]} nums * @param {number} k * @return {number} */ 本题给我们一个数字数组 nums 以及一个数字 k 我们可以对 nums 的每一个元素进行一次操作，操作内容是可以任意加 [-k ~ k] 的数字到自身 题目要求我们得出经过操作之后可以得到多少个不重复的数组元素 解题思路 假设我们有一个输入是这样的：nums = [1,2,2,3,3,4], k = 2 那么我们可以得知，要让一个数组重复数字最少的话，就要将每个数字变成允许范围内的最小值 具体来说，我们要执行以下步骤： 将 nums 数组按照升序排序；用 curLimit 表示当前元素经过操作后的最大值；用 count 记录没有重复的元素 遍历数组元素 对于每一个 nums[i] ，求 nums[i]-k（代表当前元素可以变成的最小值） 判断 curLimit+1 与 nums[i]-k 谁大 如果 nums[i]-k 大就表示当前位置没有重复元素，可以将 nums[i] 放在这个位置，此时我们需要更新 curLimit ，然后把 count++ 如果 curLimit+1 大则代表 nums[i]-k 的位置已经被占据了，我们需要进一步判断，curLimit+1 与 nums[i]+k 谁大 如果 nums[i]+k 大，表示 nums[i] 还有放的位置，我们把它放在 curLimit+1 的位置上（更新 curLimit，count++） 如果 curLimit+1 大，表示当前的元素没办法通过操作变成不重复的元素了，我们直接跳过遍历下个元素去了 遍历结束返回 count Javascript /** * @param {number[]} nums * @param {number} k * @return {number} */ var maxDistinctElements = function (nums, k) { let count = 0 let curLimit = -Infinity nums.sort((a, b) => a - b) for (const num of nums) { const minPossibleNum = Math.max(num - k, curLimit + 1) if(minPossibleNum > num + k) { continue; } curLimit = minPossibleNum count++ } return count }; "},"medium/3408.html":{"url":"medium/3408.html","title":"3408. Design Task Manager(medium)","keywords":"","body":"3408. Design Task Manager Leetcode link 题目简介 题目要求我们实现一个 TaskManager 系统用于管理任务，并实现以下方法： add(int userId, int taskId, int priority) edit(int taskId, int newPriority) rmv(int taskId) execTop() 解题思路 这题也是在考我们关于大顶堆的实现 在构造函数的时候，我们需要用 map 来建立 task 跟 user 以及 priority 的映射，以及构建好大顶堆 在实现 add 方法的时候我们只需要将新的映射 add 进 map 中，并且 push 到大顶堆中就好 edit 与 add 相似，只是需要从 map 中将原来的映射覆盖，大顶堆中的数据则先搁置不需要删除 rmv 也是一样的，区别在于要将原来 map 中的 task 删除 execTop 时，我们需要对比当前大顶堆堆顶的数据是否还在 map 中，如果不是需要重新获取堆顶直到获取到了与 map 数据符合的 task，此时我们返回 userId 并将当前 task 使用 rmv 删除就好 Javascript（自己构建 maxHeap） /** * @param {number[][]} tasks */ var TaskManager = function (tasks) { this.taskToUserId = new Map() this.taskToPriority = new Map() this.maxHeap = new MyMaxHeap() for (const [userId, taskId, priority] of tasks) { this.taskToUserId.set(taskId, userId) this.taskToPriority.set(taskId, priority) this.maxHeap.push([taskId, priority]) } }; /** * @param {number} userId * @param {number} taskId * @param {number} priority * @return {void} */ TaskManager.prototype.add = function (userId, taskId, priority) { this.taskToUserId.set(taskId, userId) this.taskToPriority.set(taskId, priority) this.maxHeap.push([taskId, priority]) }; /** * @param {number} taskId * @param {number} newPriority * @return {void} */ TaskManager.prototype.edit = function (taskId, newPriority) { this.taskToPriority.set(taskId, newPriority) this.maxHeap.push([taskId, newPriority]) }; /** * @param {number} taskId * @return {void} */ TaskManager.prototype.rmv = function (taskId) { this.taskToPriority.delete(taskId) this.taskToUserId.delete(taskId) }; /** * @return {number} */ TaskManager.prototype.execTop = function () { while (!this.maxHeap.isEmpty()) { const [taskId, priority] = this.maxHeap.pop() if (this.taskToPriority.has(taskId) && priority === this.taskToPriority.get(taskId)) { const userId = this.taskToUserId.get(taskId) this.rmv(taskId) return userId } } return -1 }; class MyMaxHeap { constructor() { this.heap = [] } isEmpty() { return this.heap.length === 0 } peek() { return this.heap[0] } push(item) { this.heap.push(item) this.heapifyUp(this.heap.length - 1) } pop() { if (this.heap.length = 0 && this.compare(this.heap[parent], this.heap[index]) > 0) { [this.heap[parent], this.heap[index]] = [this.heap[index], this.heap[parent]] this.heapifyUp(parent) } } heapifyDown(index) { const left = index * 2 + 1 const right = index * 2 + 2 let max = index if (left Javascript（使用 PriorityQueue） /** * @param {number[][]} tasks */ var TaskManager = function(tasks) { this.taskToUserId = new Map() this.taskToPriority = new Map() this.queue = new PriorityQueue(([taskA, priorityA], [taskB, priorityB]) => { if(priorityA === priorityB) { return taskB - taskA } return priorityB - priorityA }) for(const [userId, taskId, priority] of tasks) { this.taskToUserId.set(taskId, userId) this.taskToPriority.set(taskId, priority) this.queue.enqueue([taskId, priority]) } }; /** * @param {number} userId * @param {number} taskId * @param {number} priority * @return {void} */ TaskManager.prototype.add = function(userId, taskId, priority) { this.taskToUserId.set(taskId, userId) this.taskToPriority.set(taskId, priority) this.queue.enqueue([taskId, priority]) }; /** * @param {number} taskId * @param {number} newPriority * @return {void} */ TaskManager.prototype.edit = function(taskId, newPriority) { this.taskToPriority.set(taskId, newPriority) this.queue.enqueue([taskId, newPriority]) }; /** * @param {number} taskId * @return {void} */ TaskManager.prototype.rmv = function(taskId) { this.taskToPriority.delete(taskId) this.taskToUserId.delete(taskId) }; /** * @return {number} */ TaskManager.prototype.execTop = function() { while (!this.queue.isEmpty()) { const [taskId, priority] = this.queue.dequeue() if (this.taskToPriority.has(taskId) && priority === this.taskToPriority.get(taskId)) { const userId = this.taskToUserId.get(taskId) this.rmv(taskId) return userId } } return -1 }; /** * Your TaskManager object will be instantiated and called as such: * var obj = new TaskManager(tasks) * obj.add(userId,taskId,priority) * obj.edit(taskId,newPriority) * obj.rmv(taskId) * var param_4 = obj.execTop() */ "},"medium/3484.html":{"url":"medium/3484.html","title":"3484. Design Spreadsheet(medium)","keywords":"","body":"3484. Design Spreadsheet Leetcode link 题目简介 题目要求我们实现一个由 26 列（字母A-Z）rows 行所组成的表格并实现如下功能： void setCell(String cell, int value)：设置特定的格子为 value void resetCell(String cell)：重置特定格子为 0 int getValue(String formula)：使用 =X+Y 公式计算两个格子的和，其中 X 与 Y 可以是格子，也可以是数字 格子的表达方式为字母+数字，比如：A1, B10 解题思路 这题一开始会让人想到用一个二维数组来将表格构建出来，但是其实不用这么麻烦 我们只需要一个 Map 来保存格子与值的对应关系就好，对于没有在 map 中的格子，我们默认置零 需要特别注意的是，公式的字一个字符是 =，且公式有可能包含纯数字，所以需要判断一下 Javascript /** * @param {number} rows */ var Spreadsheet = function(rows) { this.map = new Map() }; /** * @param {string} cell * @param {number} value * @return {void} */ Spreadsheet.prototype.setCell = function(cell, value) { this.map.set(cell, value) }; /** * @param {string} cell * @return {void} */ Spreadsheet.prototype.resetCell = function(cell) { this.map.delete(cell) }; /** * @param {string} formula * @return {number} */ Spreadsheet.prototype.getValue = function(formula) { const [c1, c2] = formula.substring(1).split('+') let v1 = 0 if(!(/^[A-Za-z]$/.test(c1[0]))) { v1 = parseInt(c1) }else if(this.map.has(c1)) { v1 = this.map.get(c1) } let v2 = 0 if(!(/^[A-Za-z]$/.test(c2[0]))) { v2 = parseInt(c2) }else if(this.map.has(c2)) { v2 = this.map.get(c2) } return v1 + v2 }; "},"medium/3508.html":{"url":"medium/3508.html","title":"3508. Implement Router(medium)","keywords":"","body":"3508. Implement Router Leetcode link 题目简介 本题要求我们实现一个基于 FIFO 的网络路由，并实现一下功能 Route：构造函数，接受一个 memoryLimit 参数来表示能够缓存的网络包，如果超过会把最先缓存的包丢弃 addPacket：添加缓存包，接受 source, destination, timestamp 三个参数，分别代表数据来源、数据目的地、到达路由的时间戳；如果当前添加的缓存包数量超过了 memoryLimit，需要把最先进入路由的包丢弃；如果到达的包与当前缓存的包一致（冗余），需要丢弃到达的包并返回 false，否则返回 true forwardPacket：转发包，将最先进入路由的包转发出去，如果当前缓存为空，则返回空数组 getCount：接受 destination, startTime, endTime 三个参数，表示从当前缓存中寻找目的地为 destination 且到达时间戳在 [startTime, endTime] 的包数量 解题思路 本题主要考察的是二分搜索，难点在于要如何快速的从同样的 destination 中找出符合时间范围的包数量 为了满足题意，我们需要以下数据结构： packets：缓存队列，满足 FIFO 诉求 destToTime：由目的地到所有该目的地的数据包到达时间戳的映射（destination => [time1, time2, time3, ...]） packetKeySet：标识当前数据包的唯一标识符，用 \"source#destination#timestamp\" 构成 Javascript /** * @param {number} memoryLimit */ var Router = function (memoryLimit) { this.sizeLimit = memoryLimit this.packets = [] // map destination to timeStamp array this.destToTime = new Map() // use \"source#destination#timestamp\" as key this.packetKeySet = new Set() }; /** * @param {number} source * @param {number} destination * @param {number} timestamp * @return {boolean} */ Router.prototype.addPacket = function (source, destination, timestamp) { const key = makeKey(source, destination, timestamp) if (this.packetKeySet.has(key)) { return false } this.packetKeySet.add(key) if (this.packets.length >= this.sizeLimit) { this.forwardPacket() } this.packets.push([source, destination, timestamp]) if (!this.destToTime.has(destination)) { this.destToTime.set(destination, []) } this.destToTime.get(destination).push(timestamp) return true }; /** * @return {number[]} */ Router.prototype.forwardPacket = function () { if (this.packets.length === 0) { return [] } const [source, destination, timestamp] = this.packets.shift() const key = makeKey(source, destination, timestamp) this.packetKeySet.delete(key) this.destToTime.get(destination).shift() return [source, destination, timestamp] }; /** * @param {number} destination * @param {number} startTime * @param {number} endTime * @return {number} */ Router.prototype.getCount = function (destination, startTime, endTime) { if (!this.destToTime.has(destination)) { return 0 } const timeArr = this.destToTime.get(destination) const upperIdx = upperBound(timeArr, endTime) const lowerIdx = lowerBound(timeArr, startTime) return upperIdx - lowerIdx - 1 }; const makeKey = (source, destination, timestamp) => { return `${source}#${destination}#${timestamp}` } const upperBound = (arr, target) => { let left = 0 let right = arr.length - 1 let bound = arr.length while (left { let left = 0 let right = arr.length - 1 let bound = -1 while (left "},"hard/":{"url":"hard/","title":"Hard","keywords":"","body":"Hard "},"hard/32.html":{"url":"hard/32.html","title":"32. Longest Valid Parentheses(hard)","keywords":"","body":"32. Longest Valid Parentheses Leetcode link 解题思路——DP TC：O(n) SC：O(n) 题目要求我们求出最长且可以左右配对的括号子字符串长度 求极值的问题可以用动态规划来解，我们需要一个一维数组 dp，dp[i] 表示以下标 i 字符结尾的最长有效括号子字符串长度 首先，以 ( 结尾的子串它的 dp 数组对应值肯定是 0 所以我们只需要判断以 ) 结尾的部分就好，总共有两种可能性： s[i-1] == '(' && s[i] == ')'：也就是最后两位是有效括号，这个时候 dp[i] = dp[i - 2] + 2 s[i-1] == ')' && s[i] == ')'：也就是最后两位都是右括号，这个时候需要往左边找第一个未匹配的左括号 如果 s[i - dp[i - 1] - 1] == '(' 成立的话，我们可以推导出这种情况的状态转移方程为 dp[i] = dp[i - 1] + 2 + dp[i - d[i - 1] - 2] 举个例子：有个字符串 () ( () ) 首先建立一个数组 dp，初始化为 0 遍历字符串，找出上述两种情况 当 i == 1，为第一种情况，用 dp[i] = dp[i - 2] + 2 更新 dp 当 i == 4 ，为第一种情况，用 dp[i] = dp[i - 2] + 2 更新 dp 当 i == 5，为第二种情况，这个时候找到最近为匹配左括号的方法是，用自己的下标减去左边 dp 数组的匹配数量，再减去 1 如果有找到，则 i == 2 到 i == 5 这一段的 dp 可以用dp[i] = dp[i - 2] + 2 来更新 但是考虑到之前也有可能出现匹配的子串，比如这里的 s[0] 跟 s[1]，所以需要加上 dp[i - d[i - 1] - 2]，也就是 dp[1] 的值 s[0] = ( s[1] = ) s[2] = ( s[3] = ( s[4] = ) s[5] = ) 初始值 0 0 0 0 0 0 i == 1 更新后 0 2 0 0 0 0 i == 4 更新后 0 2 0 0 2 0 i == 5 更新后 0 2 0 0 2 6 C++ class Solution { public: int longestValidParentheses(string s) { vector dp(s.size(), 0); int res = 0; for(int i = 1;i=2 ? dp[i-2] : 0) + 2; } else if((i-dp[i-1]-1 >= 0) && (s[i - dp[i - 1] - 1] == '(')) { // ...)) 的情况，除了要判断最后的有效子串长度还要加上前面的子串 dp[i] = dp[i-1] + 2 + ((i - 2 - dp[i - 1] >=0) ? dp[i - 2 - dp[i - 1]] : 0); } } res = max(res, dp[i]); } return res; } }; Javascript var longestValidParentheses = function(s) { let res = 0; let dp = new Array(s.length).fill(0); for(let i=1;i=2 ? dp[i-2] : 0) + 2; } else if((i-1-dp[i-1] >= 0) && s[i-1-dp[i-1]] === '(') { dp[i] = dp[i-1] + 2 + (i-dp[i-1]>=2 ? dp[i-dp[i-1] - 2] : 0); } } res = Math.max(dp[i], res); } return res; }; 解题思路——双向遍历 TC: O(n) SC: O(1) 还有另一种方法是双向遍历，首先我们先考虑一种方法：用两个计数器 left 跟 right 分别计算左括号跟右括号出现的次数 具体步骤如下： 从左往右遍历字符串 如果遇到左括号，left++；如果遇到右括号，right++ 当 left == right 的时候，表示当前遍历的字符串是有效的，保存结果 当 right > left 的时候，表示右括号大于左括号，而单独的右括号不能组成有效字符串，所以重置 left = right = 0 上述步骤可以处理大部分的问题，但是还有一种组合会被忽略：(() 所以我们需要从右往左再遍历一次，只是这次重置条件就变成 left > right了 C++ class Solution { public: int longestValidParentheses(string s) { int res = 0; int left = 0, right = 0; for(int i=0;i left) { left = right = 0; } } left = right = 0; for(int i = s.size()-1;i>=0;i--) { if(s[i] == '(') { left++; }else { right++; } if(left == right) { res = max(res, right * 2); } if(left > right) { left = right = 0; } } return res; } }; Javascript var longestValidParentheses = function(s) { let right = 0, left = 0, res = 0; for(let i=0;i left) { right = left = 0; } } right = left = 0; for(let i = s.length-1;i>=0;i--) { if(s[i] == '(') { left++; } else { right++; } if(left === right) { res = Math.max(res, 2 * right); } else if(left > right) { right = left = 0; } } return res; }; "},"hard/51.html":{"url":"hard/51.html","title":"51. N-Queens(hard)","keywords":"","body":"51. N-Queens Leetcode link 前言 这是一道经典的 hard 题目 题目给我们一个整数 n，表示一个 n * n 的棋盘，我们的目标在于将 n 个皇后放进这个棋盘中 放置的规则就是：皇不见皇（皇后不能在彼此的同一行、同一列、同一斜线上） 暴力破解显然是不可行的，我们考虑回溯的办法 首先我们需要一个数组 queens 来记录皇后在每一行的坐标 然后我们依次在每一行放一个皇后，每个皇后的位置都要符合皇不见皇的原则 直到放到最后一行的时候，我们就能找出其中一个解了 为了要让放置的每一个皇后都能快速判断是否符合皇不见皇原则，我们有两种方法 详情见下方解题思路 解题思路——集合 TC: O(n!) SC: O(n)，其中保存皇后信息的空间复杂度是 O(n) 对每一个新行来说，有三种可能会不符合皇不见皇原则： 跟之前的皇后在同一列上 跟之前的皇后在同一斜线（右上 - 左下）上 跟之前的皇后在同一反斜线（左上 - 右下）上 所以我们可以通过三个集合来记录这三种可能： col：记录之前皇后放置的列 slash：记录之前皇后放置的行减列的差（因为在同一斜线上这个值是一样的） backslash：记录之前皇后放置的行与列的和（同理，在同一反斜线上这个值是一样的） C++ class Solution { public: vector> solveNQueens(int n) { // 存放最后的所有结果 vector> result; // 存放其中一种结果 vector queens(n, -1); // 存放已经被其他 queen 占用的列 unordered_set col; // 存放已经被其他 queen 占用的斜线（右上 - 左下） unordered_set slash; // 存放已经被其他 queen 占用的反斜线（左上 - 右下） unordered_set backslash; backtrack(n, 0, result, queens, col, slash, backslash); return result; } // 回溯法找到可以符合要求的排列 void backtrack(int n, int row, vector> &result, vector &queens, unordered_set &col, unordered_set &slash, unordered_set &backslash) { if(row == n) { // 表示找到了其中一种 vector board = generateBoard(queens, n); result.push_back(board); } else { // 遍历第 row 行的所有列 for(int i=0;i generateBoard(vector &queens, int n) { vector board; for(int i=0;i 解题思路——位运算 TC: O(n!) SC: O(n)，其中保存皇后信息的空间复杂度是 O(1) 上一个解法使用了三个集合，用了 O(n) 的空间复杂度，这个解法我们用位运算来把这部分复杂度减少到 O(1) 我们这次使用三个整数 col、slash、backslash，这三个整数的 n 个二进制位代表了可不可以放置新的皇后 如果可以放置皇后则为 0，不可以则为 1. 举个例子： 假设我们今天在第 i 行把皇后放在了第 j 列，那么这个时候我们可以先将这三个整数的第 j 位设为1 然后进入到第 i + 1 行，我们要先做三件事： col 不变 slash 左移一位 backslash 右移一位 这样我们要放置新皇后的时候，就可以用 来获取可用的位置 C++ class Solution { public: vector> solveNQueens(int n) { // 存放最后的所有结果 vector> result; // 存放其中一种结果 vector queens(n, -1); backtrack(n, 0, result, queens, 0, 0, 0); return result; } void backtrack(int n, int row, vector> &result, vector &queens, int col, int slash, int backslash) { if(n == row) { vector board = generateBoard(queens, n); result.push_back(board); } else { int available =((1 >1); queens[row] = -1; } } } // 根据找到的排列构造返回结果 vector generateBoard(vector &queens, int n) { vector board; for(int i=0;i "},"hard/52.html":{"url":"hard/52.html","title":"52. N-Queens II(hard)","keywords":"","body":"52. N-Queens II Leetcode link 解题思路 本题本质上跟 51 题的 N-Queens 是一个题，区别在于这题只需要计算个数就好 详细思路见 N-Queens，这里就选了一种方法实现了一下 C++ class Solution { public: int res = 0; int totalNQueens(int n) { vector queens(n, -1); backtrack(n, 0, queens, 0, 0, 0); return res; } void backtrack(int n, int row, vector &queens, int col, int slash, int backslash) { if(row == n) { res++; } else { int available = ((1> 1); queens[row] = -1; } } } }; "},"hard/135.html":{"url":"hard/135.html","title":"135. Candy(hard)","keywords":"","body":"135. Candy Leetcode link 解题思路 本题要求我们给一排有排名的小朋友发糖果，规则有二： 每个小朋友至少要给一颗糖 相邻的小朋友如果有一方排名较高，则应该多给糖果 题目要求我们求出最少要给多少个糖果 我们可以拆分一下题目规则： 当我们从左边往右边发糖果的时候，如果右边的小孩比左边排名高，则多给一颗糖，否则就给一颗糖 当我们从右边网左边发糖果的时候，如果左边的小孩比右边的排名高，则多给一颗糖，否则就给一颗糖 所以我们只需要用两次遍历，然后在两种发糖果的方法中找出比较少的糖果组合返回就好 Javascript var candy = function(ratings) { const len = ratings.length; const left = new Array(len).fill(1); let res = 0; for(let i = 0;i 0 && ratings[i] > ratings[i - 1]) { left[i] = left[i - 1] + 1; } } let right = 1; for(let i = len - 1;i >= 0;i--) { if(i ratings[i + 1]) { right++; } else { right = 1; } res += Math.max(right, left[i]); } return res; }; "},"hard/329.html":{"url":"hard/329.html","title":"329. Longest Increasing Path in a Matrix(hard)","keywords":"","body":"329. Longest Increasing Path in a Matrix Leetcode link 解题思路 题目要求我们在 m * n 的矩阵中找出最长连续递增路径长度，且只能往上下左右走 这道题咋看之下只能用 dfs 针对每一个矩阵元素分别进行遍历，想当然这么做肯定 TLE 经过仔细观察我们不难发现，当前节点的最长连续递增路径长度（以下简称路径），等于它上下左右四个元素的最长路径 + 1 于是我们就可以用一个数组 dp 来保存计算过的元素路径，之后遇到直接返回就完事了 以下是代码思路： 对矩阵的每一个元素都进行一次 dfs，将每次 dfs 的结果与当前结果比较，保留比较大的那个 在 dfs 中，首先判断当前的元素在 dp 数组中是否存在路径，存在的话直接返回 不存在的话则需要对它的上下左右四个方向节点进行判断： 是否越界 是否比当前元素大 如果没有越界且比当前元素大，则对其进行 dfs 最后将 dfs 的结果 +1 与当前路径做比较，保存比较长的路径 更新 dp C++ class Solution { public: vector> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; int longestIncreasingPath(vector>& matrix) { int m = matrix[0].size(), n = matrix.size(); vector> dp(n, vector(m, 0)); int res = 0; for(int i = 0;i > &dp, vector> &matrix) { if(dp[i][j]) { return dp[i][j]; } int m = matrix[0].size(), n = matrix.size(); int path = 1; for(vector dir: dirs) { int x = i + dir[0], y = j + dir[1]; if(x = n || y = m || matrix[x][y] Javascript const dirs = [[0,1], [0,-1], [1,0], [-1,0]]; var longestIncreasingPath = function(matrix) { // dp[i][j]: 从 [i, j] 开始的最长递增路径 let dp = new Array(matrix.length) for(let i=0;i= n || x = m || matrix[x][y] "},"hard/330.html":{"url":"hard/330.html","title":"330. Patching Array(hard)","keywords":"","body":"330. Patching Array Leetcode link 解题思路 本题是个 hard。 题目给了我们两个参数：数组、一个数字 n。题目要求我们在给定数组中插入最少的数字让这个数组的元素能组合出 1～n 的数字 我们可以直接用一个例子来讲解：nums=[3, 5, 20]， n = 30 首先，我们需要一个变量来表示当前缺少的数，我们取名为 miss 并且初始值为 1 接着我们需要挨个比较 miss 与当前数组中的数字（用 i 作为数组遍历的下标），此时有两种情况： miss ：这种情况表示当前缺失的数字无法被数组中最小的数字补充，此时为了插入最少的数（最大化插入每个数的表示范围），我们应该插入一个 miss，此时的表达范围来到了 [0, miss*2) miss >= nums[i]：这种情况表示当前数组中有比当前缺失数字小的数，如果把它加进来，我们的表达范围变成了 [0, miss+nums[i]) 接下来我们需要做的就是遍历整个数组，直到 miss > n ，因为此时的可表示范围已经超过了 n（可表示范围来到了 [0, miss) ） 介绍完原理我们来过一次这个逻辑： 一开始我们的 miss = 1，小于 n，于是我们遍历数组第一个元素 3，发现 miss （情况 1），于是我们需要插入 1 到数组，此时我们的表示范围为 [0, 2) （2 代表 miss 2）（*注意右侧为开区间） 此时 miss = 2，我们依然比较第一个元素 3，发现 miss （情况 1），于是我们需要插入数字 2 到数组，此时我们的表示范围来到了 [0, 4) （4 代表 miss * 2） 此时 miss = 4，我们依然比较第一个元素 3 ，发现 miss > 3（情况 2），于是我们把数组元素 3 加进来，此时我们的表示范围来到了 [0, 7) （7 代表 miss + 3） 此时 miss = 7，我们比较数组的下一个元素 5，发现 miss > 5（情况 2），于是我们把数组元素 5 加进来，此时我们的表示范围来到了 [0, 12) （7 代表 miss + 5） 此时 miss = 12，我们比较数组的下一个元素 20，发现 miss （情况 1），于是我们需要插入 12 到数组，此时我们的表示范围为 [0, 24) （24 代表 miss * 2） 此时 miss = 24，我们比较数组的当前元素 20，发现 miss > 20（情况 2），于是我们把数组元素 20 加进来，此时我们的表示范围来到了 [0, 44) （44 代表 miss + 20） 此时我们数组能表示的范围已经超过了题目的 n，所以循环结束，回顾我们循环，发现只有情况 1 之下会需要插入新的数字到数组，而情况 1 出现了 3 次，所以我们的答案是 3 Javascript /** * @param {number[]} nums * @param {number} n * @return {number} */ var minPatches = function(nums, n) { let i = 0; let miss = 1; let result = 0; while(miss "},"hard/354.html":{"url":"hard/354.html","title":"354. Russian Doll Envelopes(hard)","keywords":"","body":"354. Russian Doll Envelopes Leetcode link 解题思路 本题给了我们一个二维数组，数组的每一个项代表信封的长跟宽，要求我们求出这些信封最多能套几层娃 一个简单的暴力思路是将二维数组元素依照进行升序排序，如果第一位相等则对第二位升序排序 这样一来我们只需要用两个 for 循环再加上一个 dp 数组就能够穷举出所有的可能性，最后选择最大的就好了 代码如下，只是会 TLE： C++ class Solution { public: int maxEnvelopes(vector>& envelopes) { int len = envelopes.size(); int res = 0; vector dp(len, 1); sort(envelopes.begin(), envelopes.end()); for(int i=0;i envelopes[j][0] && envelopes[i][1] > envelopes[j][1]) { dp[i] = max(dp[i], dp[j] + 1); } } res = max(dp[i], res); } return res; } }; Javascript /** * @param {number[][]} envelopes * @return {number} */ var maxEnvelopes = function(envelopes) { let len = envelopes.length; let dp = new Array(len).fill(1); envelopes.sort((a, b) => { if(a[0] === b[0]) { return a[1] - b[1]; } return a[0] - b[0]; }) for(let i=0;i envelopes[j][0] && envelopes[i][1] > envelopes[j][1] ){ dp[i] = Math.max(dp[i], dp[j]+1); } } } return Math.max(...dp); }; 既然会 TLE，为什么还要写出来呢？因为上述的解法有优化的空间 具体来说，我们可以基于上述的思路，加上一点二分搜索的操作降低复杂度： 首先对二维数组元素的排序规则改为：先对第一位进行升序，如果第一位相等，则对第二位进行降序 这样一来，我们就可以保证当数组元素第二位是升序的时候，前面的信封可以被放到后面的信封里 说明：因为元素第一位相同的情况下，第二位为降序；所以如果元素经过排序后的第二位是升序的话，则只可能是因为第一位是越来越大的，这个条件恰好符合可以放进去的约束 如此一来，我们就可以把问题简化成：求排序后的数组元素第二位的最长升序子数组长度 求最长升序子数组，我们可以用二分查找的方法： 首先维护一个一维数组 dp，把首元素先放进数组中 然后遍历比较之后的元素，如果之后的元素比首元素小，则将新元素替换旧的首元素 如果新的元素比 dp 数组中末尾元素还大的话，则 push 新元素进 dp 末尾 如果新元素介于首元素与尾元素之间，则用二分搜索找到第一个不小于新元素的元素，且用新元素替换掉它 最后我们只需要查看 dp 数组的长度就能够得出最长升序子数组的长度了 具体看代码： C++ class Solution { public: int maxEnvelopes(vector>& envelopes) { vector dp; sort(envelopes.begin(), envelopes.end(), [](const vector &a,const vector &b) { if(a[0] == b[0]) { return a[1] > b[1]; } return a[0] =dp.size()) { dp.push_back(value); }else { dp[right] = value; } } return dp.size(); } }; Javascript /** * @param {number[][]} envelopes * @return {number} */ var maxEnvelopes = function(envelopes) { let dp = []; envelopes.sort((a, b)=>{ if(a[0] === b[0]) { return b[1] - a[1]; } return a[0] - b[0]; }); for(let i=0;i dp[mid]) { left = mid + 1; }else { right = mid; } } if(right >= dp.length) { dp.push(value); }else { dp[right] = value; } } return dp.length; }; "},"hard/407.html":{"url":"hard/407.html","title":"407. Trapping Rain Water II(hard)","keywords":"","body":"407. Trapping Rain Water II Leetcode link 题目简介 本题是一道困难题，题目只给我们一个参数 heightMap 代表一个有 m*n 个格子的矩阵，每个矩阵上有 heightMap[m][n] 个格子 题目要我们求如果下雨的话，这个矩阵上面的格子最多能留下多少格的雨水 解题思路 这题我们需要先从格子的边缘开始寻找思路 我们知道一个桶最多能接多少水取决于桶子的短板，所以我们第一步要先找到矩阵边缘最低的格子，然后将其与相邻的格子对比高度： 如果相邻格子比边缘最低的格子低，那么相邻格子就可以留下 边缘最低格子高度 - 相邻格子高度 的水 如果相邻格子比边缘最低的格子高，那么我们就再找到边缘第二低的格子……以此类推 换成算法的思路的话，我们要重复如下步骤： 创建一个与 heightMap 大小相同的数组 visited 来保存已经访问过的位置 创建一个小顶堆 minHeap 并且将所有的边缘格子放进其中，将 visited 数组中边缘格子的位置设置为 true 表示已经访问过了（因为边缘的格子之间已经在小顶堆中比较过了，不需要加入相邻的比较中） 取出 minHeap 的堆顶元素，将其与相邻且还没访问过的格子比较 如果当前格子比相邻格子高，把高度加到结果 res 中，然后将当前相邻格子加到 minHeap 中，并且相邻格子的高度要取当前格子与相邻格子中较高的高度 如果当前格子比相邻格子低，则跳过 重复步骤 3，直到 minHeap 为空 返回结果 res Javascript /** * @param {number[][]} heightMap * @return {number} */ var trapRainWater = function (heightMap) { const len = heightMap.length const width = heightMap[0].length const visited = new Array(len).fill().map(item => new Array(width).fill(false)) // [height, x, y] const minHeap = new PriorityQueue((a, b) => a[0] - b[0]) // push all the edge to the minHeap and mark visited as true for (let i = 0; i = 0 && nx = 0 && ny "},"hard/410.html":{"url":"hard/410.html","title":"410. Split Array Largest Sum(hard)","keywords":"","body":"410. Split Array Largest Sum Leetcode link 解题思路——Dynamic Programming TC: SC: 本题要求我们将一个数组切割为 m 个非空子数组。考虑到切割为 m 个数组与需要参考切割为 m - 1 个数组的结果，所以可以使用动态规划来做，具体思考如下： 首先我们需要一个二维数组来保存切割数组前 i 个数为 j 个子数组的全局最小值，把它命名为 dp]i][j] 接着我们思考一下，当 j 为 1 的时候的情况：dp[i][1] 表示将数组前 i 个数切割为一组的最小值，也就是数组前 i 个数的加总，我们记为 sum[i] 接下来我们考虑 j > 1 的情况，这种情况我们可以简化一下： 首先把划分为 j 个组看成，对于前 k 个数，划分为 j - 1 个组，最后从 k + 1 到 i 划分为一组，对单个 k 计算出来的结果取最大值就是符合题目要求的一种可能性了。 我们可以对 k 做遍历之后，对所有计算出来的 dp[i][j] 取最小值就是全局最优解了 动态规划公式： C++ class Solution { public: int splitArray(vector& nums, int m) { int len = nums.size(); // sum[i]：记录前 i 个数的总和（下标从 1 开始） vector sum(len + 1, 0); // dp[i][j]：记录前 i 个数倍分割为 j 个组的全局最小值（下标从 1 开始） vector> dp(len + 1, vector(m + 1, UINT_MAX)); // 计算 sum 数组的值 for (int i = 1; i Javascript var splitArray = function(nums, m) { const len = nums.length; // sum[i]：记录前 i 个数的总和（下标从 1 开始） const sum = new Array(len +1).fill(0); // dp[i][j]：记录前 i 个数倍分割为 j 个组的全局最小值（下标从 1 开始） const dp = new Array(len + 1); for(let i = 0;i 解题思路——二分法 TC: ，sum 表示数组元素加总， maxNum 表示数组最大的元素 SC: 首先我们要先说明一下什么情况能用二分法求解：能用二分法求解的问题一定是连续且能被判断出边距的。 拿本题为例，本题要求的是所有子数组和的最大值的最小值。 接下来我们来探讨一下子数组和最大与最小的情况： 最大：当只有一个子数组的情况下，也就是 m = 1，且这个最大值为所有数组元素的加总 最小：当数组的每个元素都是一个子数组时，也就是 m = nums.size()，且这个时候最小值为数组元素的最大值 综上所述，我们的答案将会落在 [数组元素的最大值, 所有数组元素的加总] 这个范围之间。 有了边距之后，我们需要一个方法来判断结果会落在哪一边，所以我们分别讨论一下当目标太大或太小会有什么结果： 目标太大：如果我们二分的落点比较大，那么数组必须拆分的子数组就比较少（ 子数组数量 ），符合题意但需要继续缩小范围，所以我们会把右边界 right 移到二分落点 mid 上 目标太小：如果二分落点太小，数组必须拆分更多子数组，将导致 子数组数量 > m，不符合题意，所以需要将左边界 left 移到 mid + 1 C++ class Solution { public: // 检查当前的 target 是否可以实现 bool isValid(vector& nums, int m, unsigned int target) { // group 记录为了满足当前的 target 需要拆分的子数组数量 int group = 1, sum = 0; for (int i = 0; i target) { sum = nums[i]; group++; } else { sum += nums[i]; } } return group & nums, int m) { // 二分左边界应该是数组的最大值，右边界应该是数组所有元素的加总 unsigned int left = 0, right = 0, mid; for (unsigned int num : nums) { if (num > left) left = num; right += num; } while (left Javascript /** * @param {number[]} nums * @param {number} m * @return {number} */ var splitArray = function(nums, m) { // 二分左边界应该是数组的最大值，右边界应该是数组所有元素的加总 let left = 0, right = 0, mid; for (let num of nums) { if (num > left) left = num; right += num; } while (left target) { sum = nums[i]; group++; } else { sum += nums[i]; } } return group Reference 小旭讲解 LeetCode 410. 分割数组的最大值 - EP34 "},"hard/726.html":{"url":"hard/726.html","title":"726. Number of Atoms(hard)","keywords":"","body":"726. Number of Atoms Leetcode link 解题思路 本题是一道 hard 的题目 这道题第一眼看感觉还蛮简单的，但是仔细研究之后发现其中还是有蛮多坑的，我们先来研究一下题目本身： 首先本题只有一个参数，就是 formula，他代表一个化学表达式，它包含三个部分： element：元素名称，可能是一个大写的字母（比如 O），也可能是一个大写字母跟着小写字母的组合（比如 He） count：原子的个数，如果没写就是一个（比如 O2 代表两个氧原子，O 代表一个） ()：括号，代表一组元素，如果括号后面有数字，则代表有多少组括号内的元素（比如 (HO)3 代表有 3 个氢、1 个氧） 题目要求我们把括号去除掉，按照字母顺序返回所有元素及其对应的个数（比如：Mg(OH)2 变成 H2MgO2，元素按照字母顺序排列，元素的个数紧跟其后） 一般解决这种字符串嵌套有两种思路：递归、堆栈 因为递归比较好理解，我们这里使用递归的思路来去做讲解 首先我们还是要正常的去遍历题目给到的字符串，在遍历的时候会出现三种可能： 遇到字母 & 数字：持续遍历字符串，并且把对应的元素与数量保存到一个对象中 遇到 (：需要遍历到下一个字符，然后递归调用分析函数 遇到 )：需要找到后面的数字，并且将其乘到当前括号的元素内，最后需要返回当前保存的对象 等到最后递归函数处理完成后，我们需要把对象返回给原函数，原函数会对对象数据进行排序、字符串化后返回结果 Javascript /** * @param {string} formula * @return {string} */ var countOfAtoms = function (formula) { let result = []; const { res: resultMap } = parse(formula, 0); // 将对象数据整理成期望的格式 for (const [element, count] of Object.entries(resultMap)) { result.push(element + (count === 1 ? \"\" : count)); } // 记得排序后字符串化解答 return result.sort().join(''); }; const parse = (formula, i) => { let res = {}; while (i "},"hard/778.html":{"url":"hard/778.html","title":"778. Swim in Rising Water(hard)","keywords":"","body":"778. Swim in Rising Water Leetcode link 解题思路 这道题有两个解决思路，一个是用 DFS+binary search；一个是用 dijkstra + priority queue DFS+binary search 题目要求我们从左上角游到右下角，并且要求路线上最高的那个点最小的路线 从点 A 到点 B 的路线我们可以用 dfs 来搜索，但是 dfs 在找到点 B 之前无法判断当前路径是否是最优路径 所以我们可以用 grid[i][j] 这个因素来限制 dfs，其范围是：0 所以我们可以用二分法来缩小 dfs 找到最优路径的范围 步骤如下： 首先划定答案范围：max(grid[0][0], grid[n - 1][n - 1]) ～ n*n - 1，其中 n === grid.length === grid[0].length 取得范围的中间值 mid，然后从 grid[0][0] 开始进行 dfs 一旦 dfs 过程中发现所需时间大于 mid，则终止 dfs，并且将范围改为 mid ～ n*n-1 如果该 dfs 成功到达了 grid[n - 1][n - 1]，则将范围改为 max(grid[0][0], grid[n - 1][n - 1]) ～ mid 不断缩小范围直到找到最小的时间 其中二分法的复杂度是 O(logn)、dfs 的复杂度是 O(n^2) 所以这个方法的时间复杂度就是 O(n^2 logn) Javascript /** * @param {number[][]} grid * @return {number} */ var swimInWater = function (grid) { const len = grid.length const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]] const canReachInTime = (time) => { const visited = Array.from({ length: len }, _ => Array(len).fill(false)) const dfs = (x, y) => { if (x === len - 1 && y === len - 1) { return true } visited[x][y] = true for (const [dx, dy] of dirs) { const nx = x + dx const ny = y + dy if (nx >= 0 && nx = 0 && ny > 1 if (canReachInTime(mid)) { right = mid } else { left = mid + 1 } } return left }; dijkstra + priority queue 第二个方法我们用 dijkstra 来找图上两点的最短路径 dijkstra 算法的思想就是每次从已到达的点中选择它们与未到达的点的边中最小的边来搜索 所以我们要借用小顶堆来辅助 算法步骤如下： 我们先将 grid[0][0] 放入 minHeap 中 然后我们对 minHeap 进行遍历 每次遍历都取出当前堆顶元素（同时该元素也是当前堆里面最小的元素） 如果当前元素已经经过了，则忽略当前元素，返回步骤 3 如果当前元素已经到达了 grid[n - 1][n - 1]，则直接返回当前所需时间 否则将当前元素的相邻元素全部放入堆中，返回步骤 3 其中小顶堆每次入栈或出栈的复杂度是 O(logn)、对 grid 遍历的复杂度是 O(n^2) 所以这个方法的时间复杂度就是 O(n^2 logn) Javascript /** * @param {number[][]} grid * @return {number} */ var swimInWater = function (grid) { const len = grid.length // [time, x, y] const minHeap = new PriorityQueue((a, b) => a[0] - b[0]) const visited = Array.from({ length: len }, _ => Array(len).fill(false)) const dirs =[[0, 1], [0, -1], [1, 0], [-1, 0]] minHeap.enqueue([grid[0][0], 0, 0]) while(!minHeap.isEmpty()) { const [time, x, y] = minHeap.dequeue() if(visited[x][y]) { continue } visited[x][y] = true if(x === len - 1 && y === len - 1) { return time } for(const [dx, dy] of dirs) { const nx = x + dx const ny = y + dy if(nx >=0 && nx =0 && ny "},"hard/968.html":{"url":"hard/968.html","title":"968. Binary Tree Cameras(hard)","keywords":"","body":"968. Binary Tree Cameras Leetcode link 解题思路 题目让我们在一棵二叉树上安装摄像头，摄像头可以观察相邻的节点，要求我们求出能观察到完整的二叉树所需的最少摄像头个数 首先，要想让摄像头个数最少，必须让每一个摄像头的观察范围最大，这就表示我们应该尽可能的在叶子节点的父节点上安装摄像头 为了达到这个目的，我们考虑一种从下晚上遍历整个树的方法，后序遍历（左子树 -> 右子树 -> 根节点） 我们观察到，加入摄像头之后，二叉树的节点会有三种情况： 未覆盖，我们记为 0 有摄像头： 我们记为 1 已覆盖： 我们记为 2 接下来，我们的目的就是在后序遍历二叉树的时候，为每个节点判断状态： 首先是空节点，空节点肯定不能放摄像头，所以不会是状态 1；其次，如果我们把空节点记为状态 0 未覆盖的话，遍历到叶子节点的时候就必须放摄像头了，这个与我们的原则不符。所以空节点都记为状态 2，已覆盖 其次，当我们更新到中间任意节点的时候，会有四种可能： 左节点跟右节点都有覆盖了 left == 2 && right == 2：这种情况我们就把当前节点设置为 0，未覆盖 左节点跟右节点有一个是未覆盖 left == 0 || right == 0：这种情况我们必须把当前节点设置为 1，放一个摄像头 左节点跟有节点至少有一个放了摄像头 left == 1 || right == 1：我们把当前节点设置为 2，已覆盖 最后，当我们遍历到根节点的时候，如果根节点的状态是 0，则需要为根节点再加一个摄像头 C++ class Solution { public: int res = 0; int minCameraCover(TreeNode* root) { // 0: 无覆盖 // 1: 有摄像头 // 2: 有覆盖 if(traversal(root) == 0) { res++; } return res; } int traversal(TreeNode* root) { if(root == nullptr) { return 2; } int left = traversal(root->left); int right = traversal(root->right); // 如果两个都有覆盖了 if(left == 2 && right == 2) { return 0; } // 如果其中一个子节点没有覆盖，在当前节点放一个摄像头 if(left == 0 || right == 0) { res++; return 1; } // 如果至少一个子节点有摄像头 if(left = 1 || right == 1) { return 2; } // 这里永远不会走到 return -1; } }; Javascript var minCameraCover = function(root) { // 摄像头个数 let res = 0; // 0: 无覆盖 // 1: 有摄像头 // 2: 有覆盖 let traversal = (node) => { // 空节点：有覆盖 if(node == null) { return 2; } // 左子树 -> 右子树 -> 父节点 let left = traversal(node.left); let right = traversal(node.right); // 如果左右节点都覆盖了，表示当前节点还没被覆盖 if(left === 2 && right === 2) { return 0; } // 如果其中一个子节点还没被覆盖，则在当前节点加一个摄像头 if(left === 0 || right === 0) { res++; return 1; } // 如果其中一个子节点有摄像头，当前节点就是有覆盖状态 if(left === 1 || right === 1) { return 2; } } // 如果遍历到根节点发现根节点是没覆盖的，要加一个摄像头在根节点上 if(traversal(root) === 0) { res++; } return res; }; Reference https://leetcode.cn/problems/binary-tree-cameras/solution/968-jian-kong-er-cha-shu-di-gui-shang-de-zhuang-ta/ "},"hard/1192.html":{"url":"hard/1192.html","title":"1192. Critical Connections in a Network(hard)","keywords":"","body":"1192. Critical Connections in a Network Leetcode link 解题思路 本题是个 hard。 题目要求我们找出关键链接，所谓关键链接就是如果去掉的话，会导致本来连通的节点不连通了 观察题目给出的图示，我们不难看出，关键链接就是不在环上的链接（因为只要有多个节点成环了，那么环内的每个节点至少会有两条边） 有了上述结论，我们可以把问题抽象为：找出图中所有的环，并忽略环上的边，剩下的边就是关键链接 比如题目中的 Example 1 可以看成： 这样一来，问题就变成了两个： Q：如何标记一个环？ ​ A：我们给每一个每一个节点一个独一无二 id，如果成环了，则环内节点 id 全部设置为当前环内节点 id 的最小值 Q：如何在图中找出环？ ​ A：使用 dfs，只要遍历过程中遇到了遍历过的节点，就表示遇到环了，dfs 返回当前节点的 id 接下来，我们来理一下算法的思路： 首先我们需要建立一个表 map，保存所有节点的邻接节点 然后我们需要一个数组 groupId，保存每个节点的 id，初始化为 -1 任选一个节点为根节点，对其进行 dfs，将根节点的 id 置为 0 在 dfs 中，然后遍历当前节点的邻接节点，此时会有三种可能性： 邻接节点为当前节点的父节点：直接 continue 邻接节点还没遍历过 id == -1：对邻接节点进行 dfs，设置其 id 为当前 id+1，如果 dfs 返回的 id 比当前 id 小，更新当前 id 邻接节点遍历过了 id != -1：表示遇到环了，更新 id 为环内最小的 id 遍历并更新完邻接节点之后，我们判断一下一开始传入的 id 与更新后的 id 是否相同 如果相同则表示当前节点的子节点无法遍历到父节点（因为如果可以的话 id 应该比传入 id 更小），当前节点与父节点的链接就是关键链接 判断完之后返回当前节点的最终 id 结束 dfs 之后，返回关键链接的集合就好 C++ class Solution { public: vector> criticalConnections(int n, vector> &connections) { // 构造一个节点与其邻接节点的映射表 unordered_map> map; buildMap(map, connections); // id 用来表示节点是否属于同一个组（是否成环） vector groupId(n, -1); // 存放 critical connections vector> res; dfs(0, -1, 0, groupId, map, res); return res; } void buildMap(unordered_map> &map, vector> &connections) { for (auto connection : connections) { map[connection[0]].push_back(connection[1]); map[connection[1]].push_back(connection[0]); } } int dfs(int cur, int parent, int id, vector &groupId, unordered_map> &map, vector> &res) { groupId[cur] = id; // 遍历当前的邻接节点 for (int node : map[cur]) { if (node == parent) { // 邻接节点是父节点直接略过 continue; } else if (groupId[node] == -1) { // 如果子节点没有遍历过，对其 dfs 计算子节点的 id // 如果子节点的 id 小于当前 id，表示成环了，要更新当前 id groupId[cur] = min(groupId[cur], dfs(node, cur, id + 1, groupId, map, res)); } else { // 如果邻接节点有遍历过且 id 比较小，表示成环，需要更新当前 id groupId[cur] = min(groupId[cur], groupId[node]); } } // 如果传入的 id 跟计算之后的 id 相等，表示当前节点跟父节点不在同一个环内，两者之间的链接就是 critical connection if (id == groupId[cur] && cur != 0) { res.push_back({parent, cur}); } return groupId[cur]; } }; Javascript /** * @param {number} n * @param {number[][]} connections * @return {number[][]} */ var criticalConnections = function(n, connections) { // 构造一个节点与其邻接节点的映射表 let map = {}; buildMap(map, connections); // id 用来表示节点是否属于同一个组（是否成环） let groupId = new Array(n).fill(-1); // 存放 critical connections let res = []; dfs(0, -1, 0, groupId, map, res); return res; }; var buildMap = function(map, connections) { for(let connection of connections) { map[connection[0]] ? map[connection[0]].push(connection[1]) : map[connection[0]] = [connection[1]]; map[connection[1]] ? map[connection[1]].push(connection[0]) : map[connection[1]] = [connection[0]]; } } /** * @param cur 当前遍历节点 * @param parent 当前遍历节点的父节点 * @param id 当前节点的默认 id * @param groupId 存放所有节点 id 的数组 * @param map 存放所有节点与其邻接节点的映射表 * @param res 用来放 critical connections * @return id 当前节点计算后的 id */ var dfs = function(cur, parent, id, groupId, map, res) { groupId[cur] = id; // 遍历当前的邻接节点 for(let node of map[cur]) { if(node == parent) { // 邻接节点是父节点直接略过 continue; } else if(groupId[node] === -1) { // 如果子节点没有遍历过，对其 dfs 计算子节点的 id // 如果子节点的 id 小于当前 id，表示成环了，要更新当前 id groupId[cur] = Math.min(groupId[cur], dfs(node, cur, id+1, groupId, map, res)); } else { // 如果邻接节点有遍历过且 id 比较小，表示成环，需要更新当前 id groupId[cur] = Math.min(groupId[cur], groupId[node]); } } // 如果传入的 id 跟计算之后的 id 相等，表示当前节点跟父节点不在同一个环内，两者之间的链接就是 critical connection if(groupId[cur] === id && cur!= 0) { res.push([parent, cur]); } return groupId[cur]; } Reference https://www.bilibili.com/video/BV15t4y197eq?spm_id_from=333.337.search-card.all.click "},"hard/1526.html":{"url":"hard/1526.html","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array(hard)","keywords":"","body":"1526. Minimum Number of Increments on Subarrays to Form a Target Array Leetcode link 题目简介 /** * @param {number[]} target * @return {number} */ 题目在一开始给我们一个长度为 target.length 的全 0 数组，要求我们每次选择其中的一个子数组给子数组每个元素 +1，使其最后变成 target 数组 题目要求我们返回最少的选择步骤需要多少步 解题思路 这题乍看是一道 hard，其实要比想像中简单 我们从数组的第一个元素开始看： 要将 0 变成 target[0] 需要 target[0] 步 如果 target[1] 比 target[0] 小（或相等），我们可以把 target[1] 跟 target[0] 划分到同一个子数组中，在这种情况下将 0 变成 target[1] 也只需要 target[0] 步 反之如果 target[1] 比 target[0] 大，则我们还需要 target[1] - target[0] 步才能将 0 也变成 target[1] 结合上面三点，我们只需要一次遍历就可以搞定 Javascript /** * @param {number[]} target * @return {number} */ var minNumberOperations = function (target) { let res = target[0] for (let i = 1; i target[i - 1]) { res += target[i] - target[i - 1] } } return res }; "},"hard/1912.html":{"url":"hard/1912.html","title":"1912. Design Movie Rental System(hard)","keywords":"","body":"1912. Design Movie Rental System Leetcode link 题目简介 这是一道困难题，而且是比较有意思的系统设计题 题目要求我们设计一个电影租赁系统，题目要求我们实现以下方法： MovieRentingSystem(int n, int[][] entries)：构造函数，参数 n 代表我们有 n 家店、参数 entries 代表 [shop, movie, price] 三元组，表示在 shop 中有 movie 可以租借，价格为 money List search(int movie)：搜索所有有 movie 且还未出租的店家，找到 price 最低的前 5 家店返回，如果 price 一样，则 shop 低的优先返回 void rent(int shop, int movie)：将 movie 从 shop 中租出去 void drop(int shop, int movie)：把 movie 还到 shop（只能还回原 shop） List> report()：从所有租出去的电影中，返回最便宜的前五个电影的 [shop, movie] 二元组，如果 price 一致，返回 shop 低的，如果 shop 也一致，返回 movie 低的 解题思路 这题的思路有两个： 排序数组 小顶堆 前者在数据量大的情况下性能表现不如后者，但是在 leetcode 的测试 case 中性能会比后者好一些，我直接放代码，不赘述，后面主要讲解小顶堆的思路 这道题的关键在于 search 与 report 方法，要想办法减少这两个方法的复杂度 search 方法我们可以用一个 movie => heap 的 movieHeap 来保存从 map 到小顶堆的映射，此处的 heap 只需要保存 [shop, price] 就好；除了 map 之外，我们还需要一个 Set unRentedMovie 来保存还未出租的 movie，用来筛选 map 返回 report 方法我们可以直接维护一个小顶堆 rentedHeap 来保存所有已经出租出去的电影，这个 heap 我们保存 [shop, movie, price] 最后在 rent 的时候，题目给的参数没有给 price，所以我们还需要一个 map priceMap 来保存从 [shop, movie] 到 price 的映射 Javascript（小顶堆） /** * @param {number} n * @param {number[][]} entries */ var MovieRentingSystem = function (n, entries) { this.resultLimit = 5 // movie => Heap([shop, price]) for search this.movieHeap = new Map() // shop#movie this.unRentedMovie = new Set() // Heap([shop, movie, price]) for report this.rentedHeap = new MyHeap(([sA, mA, pA], [sB, mB, pB]) => { return pA - pB || sA - sB || mA - mB }) // shop#movie => price this.priceMap = new Map() for (const [shop, movie, price] of entries) { const key = getKey(shop, movie) this.unRentedMovie.add(key) this.priceMap.set(key, price) if (!this.movieHeap.has(movie)) { this.movieHeap.set(movie, new MyHeap(([sA, pA], [sB, pB]) => { return pA - pB || sA - sB })) } this.movieHeap.get(movie).push([shop, price]) } }; /** * @param {number} movie * @return {number[]} */ MovieRentingSystem.prototype.search = function (movie) { if (!this.movieHeap.has(movie)) { return [] } const res = [] const retain = [] const heap = this.movieHeap.get(movie) const seen = new Set() while (!heap.isEmpty() && res.length heap.push(item)) return res }; /** * @param {number} shop * @param {number} movie * @return {void} */ MovieRentingSystem.prototype.rent = function (shop, movie) { const key = getKey(shop, movie) if (this.unRentedMovie.has(key)) { this.unRentedMovie.delete(key) } // test case ensure to have shop and movie in shop's unrent list const price = this.priceMap.get(key) this.rentedHeap.push([shop, movie, price]) }; /** * @param {number} shop * @param {number} movie * @return {void} */ MovieRentingSystem.prototype.drop = function (shop, movie) { const key = getKey(shop, movie) this.unRentedMovie.add(key) if (!this.movieHeap.has(movie)) { this.movieHeap.set(movie, new MyHeap(([sA, pA], [sB, pB]) => { return pA - pB || sA - sB })) } const price = this.priceMap.get(key) this.movieHeap.get(movie).push([shop, price]) // we will adjust the rentedHeap later }; /** * @return {number[][]} */ MovieRentingSystem.prototype.report = function () { const res = [] const retain = [] // prevent duplicate data const seen = new Set() while (!this.rentedHeap.isEmpty() && res.length this.rentedHeap.push(item)) return res }; const getKey = (shop, movie) => { return `${shop}#${movie}` } class MyHeap { constructor(compare) { this.heap = [] this.compare = compare } peek() { return this.heap[0] } isEmpty() { return this.heap.length === 0 } push(item) { this.heap.push(item) this.heapifyUp(this.heap.length - 1) } pop() { if (this.heap.length > 1 if (parent >= 0 && this.compare(this.heap[index], this.heap[parent]) Javascript（排序数组） /** * @param {number} n * @param {number[][]} entries */ var MovieRentingSystem = function (_n, entries) { this.maxNumSearchResults = 5; let sorted = [...entries] .sort(([shop1, _1, price1], [shop2, _2, price2]) => { let priceDiff = price1 - price2; return priceDiff? priceDiff: shop1 - shop2; }); //{ movie: [ [shop1, priceLowest] ... [shopN, priceHighest] ] } this.movies = sorted .reduce((movies, [shop, movie]) => { let shops = movies[movie]; if(shops == undefined) shops = movies[movie] = []; shops.push(shop); return movies; }, {}); /* { shop: { movie: { price } } } */ this.shops = sorted .reduce((shops, [shop, movie, price]) => { let data = shops[shop]; if(data == undefined) data = shops[shop] = {}; data[movie] = {price}; return shops; }, {}); //i = [shop, movie] this.rented = []; }; /** * @param {number} movie * @return {number[]} */ MovieRentingSystem.prototype.search = function (movie) { let results = [], shops = this.movies[movie]; if (shops) { for (let i = 0, l = shops.length; results.length { let priceDiff = this.shops[shop1][movie1].price - this.shops[shop2][movie2].price; if(!priceDiff) return shop1 == shop2? movie1 - movie2 : shop1 - shop2; return priceDiff; }) .slice(0, this.maxNumSearchResults); }; /** * Your MovieRentingSystem object will be instantiated and called as such: * var obj = new MovieRentingSystem(n, entries) * var param_1 = obj.search(movie) * obj.rent(shop,movie) * obj.drop(shop,movie) * var param_4 = obj.report() */ "},"hard/2197.html":{"url":"hard/2197.html","title":"2197. Replace Non-Coprime Numbers in Array(hard)","keywords":"","body":"2197. Replace Non-Coprime Numbers in Array Leetcode link 题目简介 这是一道 hard，题目会给一个数字组成的数组 nums 要求我们按照以下步骤求出新的数组： 寻找连续两个相邻的互质数（也就是最大公因数 GCD 为 1） 将这两个相邻的互质数用两数的最小公倍数 LCM 替代 回到第一步继续寻找直到没有互质数则直接结束返回数组 解题思路 这题的难点其实有三个： 最大公因数 GCD 怎么求 最小公倍数 LCM 怎么求 如何处理好数组替换的操作 第一个难点，GCD 可以通过欧几里得算法来求解：gcd(a, b) = gcd(a, a mod b)，复杂度为 O(logM), M = min(a, b) 第二个难点，LCM 可以通过以下等式来获得：lcm(a, b) * gcd(a, b) = a * b => lcm(a, b) = a * b / gcd(a, b) 最后一个难点，我们只要维护一个栈，在遍历 nums 的时候只需要取栈顶元素与其对比后 push 对应的数字进栈即可 最后算法复杂度为 O(nlogM) Javascript /** * @param {number[]} nums * @return {number[]} */ var replaceNonCoprimes = function (nums) { const stack = [] // gcd(a, b) = gcd(a, a mod b) const gcd = (a, b) => { while (b !== 0) { let temp = b b = a % b a = temp } return a } for(let num of nums) { while(stack.length > 0) { const top = stack[stack.length-1] const g = gcd(top, num) // if coprime if(g === 1) { break } stack.pop(top) // gcd(a, b) * lcm(a, b) = a * b => lcm(a, b) = a * b / gcd(a, b) num = num * top / g } stack.push(num) } return stack }; "},"hard/2751.html":{"url":"hard/2751.html","title":"2751. Robot Collisions(hard)","keywords":"","body":"2751. Robot Collisions Leetcode link 解题思路 这是一道久违的 hard！ 题目会给我们若干机器人，每个机器人都有各自的三个属性：位置 position、生命值 health、行走方向 direction 因为机器人有不同的行走方向，所以有些机器人可能会发生碰撞，发生碰撞后有三个结果： 往右走的机器人生命值高于往左走的机器人：往右走的机器人生命值 -1；往左走的机器人生命值归 0 往右走的机器人生命值低于往左走的机器人：往右走的机器人生命值归 0；往左走的机器人生命值 -1 两个机器人生命值相同：同归于尽，两个机器人生命值都归 0 题目要我们求最后的均衡状态（不会在发生碰撞了）下，还活着的机器人的生命值（需要按照一开始的顺序） 题目在我看来有两个难点： 要怎么去模拟碰撞情况 要怎么保证记住一开始机器人的位置 我们先关注第一个难点，要模拟碰撞，我们需要以下几步： 我们需要先把机器人按照位置顺序排序出来 我们从左往右遍历位置，会有两种情况： 遇到了向右走的机器人，这个时候先保存起来（由于碰撞本质上是一种按照先进后出的消耗，所以使用栈来保存） 遇到了向左走的机器人，此时取出栈顶机器人去碰撞（因为栈顶一定是最靠近的向右走机器人） 发生碰撞无非就是上述的三个结果，我们分别进行判断 等到遍历结束，我们把最后生命值大于 0 的机器人收集起来返回 这个步骤中，最难的一步是，我们要怎么保证前期按照位置排序后，后面收集的生命值的顺序呢？ 第一步：我们可以引入一个辅助数组 indices，它保存着原来机器人顺序的下标 第二步：我们把 indices 按照 positions 同下标的值从小到大排序，这样我们遍历 indices 就相当于遍历了排序后的 positions, healths, directions Javascript /** * @param {number[]} positions * @param {number[]} healths * @param {string} directions * @return {number[]} */ var survivedRobotsHealths = function(positions, healths, directions) { // 辅助数组，用于维持 positions, healths, directions 之间的联系 const indices = Array.from({length: positions.length}, (_, i) => i); // 把辅助函数按照位置从左到右排序 indices.sort((a, b) => positions[a] - positions[b]); // 我们把往右走的 robot 用一个栈维护起来 const stack = []; const result = []; for(const i of indices) { // 从位置的左到右遍历，如果遇到往右走的 robot 先存起来 if(directions[i] === 'R') { stack.push(i); continue; } // 遇到了往左走的 robot 需要处理一下 while(healths[i] > 0 && stack.length > 0) { const top = stack.pop(); // 处理发生碰撞的情况 if(healths[top] > healths[i]) { // 情况1: 栈顶往右走的 robot 生命值大于当前往左走的 robot healths[top]--; healths[i] = 0; if(healths[top] > 0) { stack.push(top); } } else if(healths[top] 0) { result.push(health); } } return result; }; "},"hard/2872.html":{"url":"hard/2872.html","title":"2872. Maximum Number of K-Divisible Components(hard)","keywords":"","body":"2872. Maximum Number of K-Divisible Components Leetcode link 题目简介 本题是个 hard，而且题目特别长，看的人晕头转向的，我这边先简单描述一下题目给的参数都是干嘛的： n：代表题目给的树有几个节点 edges：是一个二维数组，数组的每一项有两个节点，代表这两个节点之间有边 values：是一个数组，每一项代表当前下标对应的节点的值 k：一个 number，作用后面会将 通过前三个参数，我们可以画出一棵树出来，题目要求我们可以任意斩断树节点之间的连接，但是前提是斩断的两边的节点只和，都要能够被 k 整除，并且题目要求我们求出最多能够切成多少个 解题思路 这种要把树分开的题目，一般都需要遍历树，这题主要有两个难点： 如何根据前三个参数把树构建出来 如何根据自己构建的树，通过遍历将其拆分成尽可能多的树枝 首先第一个难点，我们可以通过自己构建一个简单的二维数组来表示一棵树，这个二维数组的长度是 n，而二维数组内部储存的数组则表示与当前数组下标节点有存在边的节点 举个例子：[[1,2], [0], [0]] 表示节点 0 有两条边，分别连接到了节点 1 与节点 2，而节点 1 只与节点 0 相连；同理节点 2 也只与节点 0 相连 0 | \\ 1 2 然后，第二步就是要看要如何遍历这颗树 我们可以从叶子节点开始思考，有两种可能： 如果当前叶子节点能够被 k 整除，那么我们就可以将其与其父节点的连接斩断 如果当前叶子节点不能被 k 整除，那么我们要将它的值往其父节点累加，直到累加的值可以被 k 整除，再将整棵子树与其他树的连接切断 这种往父节点累加的遍历，自然而然就想到了 dfs 于是我们就得到了代码： Javascript /** * @param {number} n * @param {number[][]} edges * @param {number[]} values * @param {number} k * @return {number} */ var maxKDivisibleComponents = function (n, edges, values, k) { let result = 0 // first step: create the tree const tree = Array.from(new Array(n), () => new Array()) edges.forEach(([n1, n2])=>{ tree[n1].push(n2) tree[n2].push(n1) }) // second step: dfs const dfs = (node, parent) => { let sum = values[node] for(const pair of tree[node]) { if(pair === parent) { continue } sum+= dfs(pair, node) } if(sum % k === 0) { result++ } return sum } // Each node can be the root, we use 0 just for convenience dfs(0) return result }; "},"hard/3027.html":{"url":"hard/3027.html","title":"3027. Find the Number of Ways to Place People II(hard)","keywords":"","body":"3027. Find the Number of Ways to Place People II Leetcode link 题目简介 这一题跟 3025 唯一的差别就是把参数的范围提高了，所以对算法复杂度的要求理论上会更高，但我们之前的算法复杂度已经是 O(n^2) 了，所以直接套用就好 解题思路 直接套用 3025 的代码 Javascript /** * @param {number[][]} points * @return {number} */ var numberOfPairs = function(points) { points.sort((a, b) => { if (a[0] === b[0]) { return b[1] - a[1] } return a[0] - b[0] }) let count = 0 const n = points.length for (let i = 0; i lowerYLimit) { count++ lowerYLimit = curY if(curY === upperYLimit) { break } } } } return count }; "},"hard/3347.html":{"url":"hard/3347.html","title":"3347. Maximum Frequency of an Element After Performing Operations II(hard)","keywords":"","body":"3347. Maximum Frequency of an Element After Performing Operations II Leetcode link 题目简介 这题跟 3346 的唯一区别就是 nums[i] 跟 k 的范围更大了，所以对算法复杂度的要求会更高，但是解法直接用 3346 的就行 解题思路 见 3346 Javascript /** * @param {number[]} nums * @param {number} k * @param {number} numOperations * @return {number} */ var maxFrequency = function (nums, k, numOperations) { nums.sort((a, b) => a - b) const len = nums.length let res = 0 // if nums[i] is target let left = 0 let right = 0 // count the current element let count = 0 for (let i = 0; i = nums[i] - k while(nums[left] nums[i] + k while(right = numOperations) { return res } // now, we can handle the situation that nums[i] is not a target left = 0 const BOUNDARY = k*2 for(right = 0;right BOUNDARY) { left++ } const size = right - left + 1 res = Math.max(res, Math.min(numOperations, size)) } return res }; "},"hard/3495.html":{"url":"hard/3495.html","title":"3495. Minimum Operations to Make Array Elements Zero(hard)","keywords":"","body":"3495. Minimum Operations to Make Array Elements Zero Leetcode link 题目简介 这是一道 hard，题目给我们一个二维数组，数组中包含多个 [left, right] 形式的数组，代表从 left 到 right 的正整数 题目要求我们每次操作都从 l 到 r 中任意选择两个数字，并将其处以 4 后向下取整，直到数组中所有数字都变为 0 最后返回所有数组需要的操作次数 解题思路 这道题有两种解法，但是都服务于一个相同的思路，下面我们先聊聊解题思路 首先我们先来分析一下，任意一个数字被 4 整除之后向下取整需要几步： 对于 1, 2, 3 来说，只需要一步，因为他们小于 $4^1$ 对于 4, 5, ..., 15 来说，需要两步，因为他们小于 $4^2$ 对于 16, 17, ..., 63 来说，需要三步，因为他们小于 $4^3$ 以此类推 知道了这个规律之后，我们不难想到可以针对 l 到 r 的正整数序列进行分堆，然后针对每一堆的数量乘以他们需要的步骤之后相加，就可以求得任意一个 [left, right] 组合中每一个数字变为 0 需要的步骤了，最后再将其除以 2 之后向上取整，就能得到题目所求的操作次数了 举个例子：有一个数组是 [3, 17] 我们可以将其分为三组： 3 自己一组，因为它只需要一次除法 4~15 一组，因为他们需要两次除法 16, 17 一组，因为需要三次除法 我们可以得到需要 31 (1*1 + (15-4+1) * 2 + 2 * 3) 次除法才能够将所有数字变为 0，那么题目需要的操作次数就是 Ceil(31/2) = 16 了解了这个思路之后，接下来有两种解决方案： 用数字来寻找相同组 遍历所有组，并找到各组内的数字 用数字寻找组 用数字寻找范围的精髓在于，通过题目给出的数字，来判断他们分别属于哪些范围，然后再进行求和计算 为了算法的通用性，我们可以设计一个能够计算 [1, n] 这个范围的算法，这样一来如果题目要求是 [left, right]，我们可以用 [1, right] 需要的除法计算减去 [1, left-1]需要的除法次数，然后再除以 2 向上取整就可以计算出题目所需的操作数量了 Javascript /** * @param {number[][]} queries * @return {number} */ var minOperations = function (queries) { let result = 0n queries.forEach(([l, r]) => { const leftOpCount = totalNeedOfOpsToNum(l - 1) const rightOpCount = totalNeedOfOpsToNum(r) result += (rightOpCount - leftOpCount + 1n) / 2n }) return Number(result) }; // 将数字分组，最后加总所需除法次数 const totalNeedOfOpsToNum = num => { let res = 0n; let needOfOps = 1; let base = 1; while (base 用组寻找数字 换一个角度来思考题目，如果我们可以知道总共有多少组，我们是不是就可以通过遍历所有的组来寻找各自组别有的数字了呢？ 我们可以看到题目对 left 跟 right 的 $1 \\le l \\lt r \\le 10^9$ 题目要求的除数是 4，所以我们可以知道这个组最多不超过 $log_{4}10^9 \\lt 15$ 于是我们就可以针对每一组 [l, r]，进行一次循环，从而找出所需要进行除法的次数 Javascript /** * @param {number[][]} queries * @return {number} */ var minOperations = function (queries) { let res = 0; queries.forEach(([left, right]) => { let needOfOps = 0 for (let i = 1; i "}}